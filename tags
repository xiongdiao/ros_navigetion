!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABSTRACT_LOCAL_PLANNER_ODOM_H_	base_local_planner/include/base_local_planner/local_planner_util.h	39;"	d
ALL	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^    ALL$/;"	e	enum:range_sensor_layer::RangeSensorLayer::InputSensorType
AMCLLaser	amcl/include/amcl/sensors/amcl_laser.h	/^class AMCLLaser : public AMCLSensor$/;"	c	namespace:amcl
AMCLLaser	amcl/src/amcl/sensors/amcl_laser.cpp	/^AMCLLaser::AMCLLaser(size_t max_beams, map_t* map) : AMCLSensor(), $/;"	f	class:AMCLLaser
AMCLLaserData	amcl/include/amcl/sensors/amcl_laser.h	/^    AMCLLaserData () {ranges=NULL;};$/;"	f	class:amcl::AMCLLaserData
AMCLLaserData	amcl/include/amcl/sensors/amcl_laser.h	/^class AMCLLaserData : public AMCLSensorData$/;"	c	namespace:amcl
AMCLOdom	amcl/include/amcl/sensors/amcl_odom.h	/^class AMCLOdom : public AMCLSensor$/;"	c	namespace:amcl
AMCLOdom	amcl/src/amcl/sensors/amcl_odom.cpp	/^AMCLOdom::AMCLOdom() : AMCLSensor()$/;"	f	class:AMCLOdom
AMCLOdomData	amcl/include/amcl/sensors/amcl_odom.h	/^class AMCLOdomData : public AMCLSensorData$/;"	c	namespace:amcl
AMCLSensor	amcl/include/amcl/sensors/amcl_sensor.h	/^class AMCLSensor$/;"	c	namespace:amcl
AMCLSensor	amcl/src/amcl/sensors/amcl_sensor.cpp	/^AMCLSensor::AMCLSensor()$/;"	f	class:AMCLSensor
AMCLSensorData	amcl/include/amcl/sensors/amcl_sensor.h	/^class AMCLSensorData$/;"	c	namespace:amcl
AMCL_LASER_H	amcl/include/amcl/sensors/amcl_laser.h	30;"	d
AMCL_ODOM_H	amcl/include/amcl/sensors/amcl_odom.h	30;"	d
AMCL_SENSOR_H	amcl/include/amcl/sensors/amcl_sensor.h	29;"	d
AStarExpansion	global_planner/include/global_planner/astar.h	/^class AStarExpansion : public Expander {$/;"	c	namespace:global_planner
AStarExpansion	global_planner/src/astar.cpp	/^AStarExpansion::AStarExpansion(PotentialCalculator* p_calc, int xs, int ys) :$/;"	f	class:global_planner::AStarExpansion
AmclNode	amcl/src/amcl_node.cpp	/^AmclNode::AmclNode() :$/;"	f	class:AmclNode
AmclNode	amcl/src/amcl_node.cpp	/^class AmclNode$/;"	c	file:
BACKWARD	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
BASE_LOCAL_PLANNER_GOAL_FUNCTIONS_H_	base_local_planner/include/base_local_planner/goal_functions.h	38;"	d
BaseGlobalPlanner	nav_core/include/nav_core/base_global_planner.h	/^      BaseGlobalPlanner(){}$/;"	f	class:nav_core::BaseGlobalPlanner
BaseGlobalPlanner	nav_core/include/nav_core/base_global_planner.h	/^  class BaseGlobalPlanner{$/;"	c	namespace:nav_core
BaseLocalPlanner	nav_core/include/nav_core/base_local_planner.h	/^      BaseLocalPlanner(){}$/;"	f	class:nav_core::BaseLocalPlanner
BaseLocalPlanner	nav_core/include/nav_core/base_local_planner.h	/^  class BaseLocalPlanner{$/;"	c	namespace:nav_core
BeamModel	amcl/src/amcl/sensors/amcl_laser.cpp	/^double AMCLLaser::BeamModel(AMCLLaserData *data, pf_sample_set_t* set)$/;"	f	class:AMCLLaser
CARROT_PLANNER_H_	carrot_planner/include/carrot_planner/carrot_planner.h	38;"	d
CHUNKY	base_local_planner/include/base_local_planner/odometry_helper_ros.h	91;"	d
CLEARING	move_base/include/move_base/move_base.h	/^    CLEARING$/;"	e	enum:move_base::MoveBaseState
CLEAR_COSTMAP_RECOVERY_H_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	38;"	d
CONTROLLING	move_base/include/move_base/move_base.h	/^    CONTROLLING,$/;"	e	enum:move_base::MoveBaseState
CONTROLLING_R	move_base/include/move_base/move_base.h	/^    CONTROLLING_R,$/;"	e	enum:move_base::RecoveryTrigger
COSTMAP_2D_ARRAY_PARSER_H	costmap_2d/include/costmap_2d/array_parser.h	32;"	d
COSTMAP_2D_COSTMAP_2D_H_	costmap_2d/include/costmap_2d/costmap_2d.h	39;"	d
COSTMAP_2D_COSTMAP_2D_PUBLISHER_H_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	39;"	d
COSTMAP_2D_COSTMAP_2D_ROS_H_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	39;"	d
COSTMAP_2D_COSTMAP_LAYER_H_	costmap_2d/include/costmap_2d/costmap_layer.h	39;"	d
COSTMAP_2D_COSTMAP_MATH_H_	costmap_2d/include/costmap_2d/costmap_math.h	39;"	d
COSTMAP_2D_COST_VALUES_H_	costmap_2d/include/costmap_2d/cost_values.h	38;"	d
COSTMAP_2D_FOOTPRINT_H	costmap_2d/include/costmap_2d/footprint.h	39;"	d
COSTMAP_2D_INFLATION_LAYER_H_	costmap_2d/include/costmap_2d/inflation_layer.h	39;"	d
COSTMAP_2D_LAYERED_COSTMAP_H_	costmap_2d/include/costmap_2d/layered_costmap.h	39;"	d
COSTMAP_2D_LAYER_H_	costmap_2d/include/costmap_2d/layer.h	38;"	d
COSTMAP_2D_OBSERVATION_BUFFER_H_	costmap_2d/include/costmap_2d/observation_buffer.h	38;"	d
COSTMAP_2D_OBSERVATION_H_	costmap_2d/include/costmap_2d/observation.h	33;"	d
COSTMAP_2D_OBSTACLE_LAYER_H_	costmap_2d/include/costmap_2d/obstacle_layer.h	39;"	d
COSTMAP_2D_STATIC_LAYER_H_	costmap_2d/include/costmap_2d/static_layer.h	39;"	d
COSTMAP_2D_TESTING_HELPER_H	costmap_2d/include/costmap_2d/testing_helper.h	2;"	d
COSTMAP_2D_VOXEL_LAYER_H_	costmap_2d/include/costmap_2d/voxel_layer.h	39;"	d
COSTTYPE	navfn/include/navfn/navfn.h	71;"	d
COST_FACTOR	navfn/include/navfn/navfn.h	65;"	d
COST_NEUTRAL	navfn/include/navfn/navfn.h	64;"	d
COST_OBS	navfn/include/navfn/navfn.h	51;"	d
COST_OBS_ROS	navfn/include/navfn/navfn.h	52;"	d
COST_UNKNOWN_ROS	navfn/include/navfn/navfn.h	50;"	d
CS	navfn/src/navtest.cpp	/^static int CS;$/;"	v	file:
CachedDistanceMap	amcl/src/amcl/map/map_cspace.cpp	/^    CachedDistanceMap(double scale, double max_dist) : $/;"	f	class:CachedDistanceMap
CachedDistanceMap	amcl/src/amcl/map/map_cspace.cpp	/^class CachedDistanceMap$/;"	c	file:
CarrotPlanner	carrot_planner/include/carrot_planner/carrot_planner.h	/^  class CarrotPlanner : public nav_core::BaseGlobalPlanner {$/;"	c	namespace:carrot_planner
CarrotPlanner	carrot_planner/src/carrot_planner.cpp	/^  CarrotPlanner::CarrotPlanner()$/;"	f	class:carrot_planner::CarrotPlanner
CarrotPlanner	carrot_planner/src/carrot_planner.cpp	/^  CarrotPlanner::CarrotPlanner(std::string name, costmap_2d::Costmap2DROS* costmap_ros)$/;"	f	class:carrot_planner::CarrotPlanner
Cell	costmap_2d/src/costmap_2d_cloud.cpp	/^struct Cell$/;"	s	file:
Cell	costmap_2d/src/costmap_2d_markers.cpp	/^struct Cell$/;"	s	file:
CellData	amcl/src/amcl/map/map_cspace.cpp	/^class CellData$/;"	c	file:
CellData	costmap_2d/include/costmap_2d/inflation_layer.h	/^  CellData(double i, unsigned int x, unsigned int y, unsigned int sx, unsigned int sy) :$/;"	f	class:costmap_2d::CellData
CellData	costmap_2d/include/costmap_2d/inflation_layer.h	/^class CellData$/;"	c	namespace:costmap_2d
ClearCostmapRecovery	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^  class ClearCostmapRecovery : public nav_core::RecoveryBehavior {$/;"	c	namespace:clear_costmap_recovery
ClearCostmapRecovery	clear_costmap_recovery/src/clear_costmap_recovery.cpp	/^            ClearCostmapRecovery::ClearCostmapRecovery(): global_costmap_(NULL), local_costmap_(NULL),$/;"	f	class:clear_costmap_recovery::ClearCostmapRecovery
ClearVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^    ClearVoxel(uint32_t* data): data_(data){}$/;"	f	class:voxel_grid::VoxelGrid::ClearVoxel
ClearVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^  class ClearVoxel$/;"	c	class:voxel_grid::VoxelGrid
ClearVoxelInMap	voxel_grid/include/voxel_grid/voxel_grid.h	/^    ClearVoxelInMap($/;"	f	class:voxel_grid::VoxelGrid::ClearVoxelInMap
ClearVoxelInMap	voxel_grid/include/voxel_grid/voxel_grid.h	/^  class ClearVoxelInMap$/;"	c	class:voxel_grid::VoxelGrid
CostAggregationType	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^enum CostAggregationType { Last, Sum, Product};$/;"	g	namespace:base_local_planner
Costmap2D	costmap_2d/include/costmap_2d/costmap_2d.h	/^class Costmap2D$/;"	c	namespace:costmap_2d
Costmap2D	costmap_2d/src/costmap_2d.cpp	/^    Costmap2D::Costmap2D() :$/;"	f	class:costmap_2d::Costmap2D
Costmap2D	costmap_2d/src/costmap_2d.cpp	/^    Costmap2D::Costmap2D(const Costmap2D& map) :$/;"	f	class:costmap_2d::Costmap2D
Costmap2D	costmap_2d/src/costmap_2d.cpp	/^    Costmap2D::Costmap2D(unsigned int cells_size_x, unsigned int cells_size_y, double resolution,$/;"	f	class:costmap_2d::Costmap2D
Costmap2DPublisher	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^class Costmap2DPublisher$/;"	c	namespace:costmap_2d
Costmap2DPublisher	costmap_2d/src/costmap_2d_publisher.cpp	/^    Costmap2DPublisher::Costmap2DPublisher(ros::NodeHandle * ros_node, Costmap2D* costmap, std::string global_frame,$/;"	f	class:costmap_2d::Costmap2DPublisher
Costmap2DROS	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^class Costmap2DROS$/;"	c	namespace:costmap_2d
Costmap2DROS	costmap_2d/src/costmap_2d_ros.cpp	/^    Costmap2DROS::Costmap2DROS(const std::string& name, tf2_ros::Buffer& tf) :$/;"	f	class:costmap_2d::Costmap2DROS
CostmapLayer	costmap_2d/include/costmap_2d/costmap_layer.h	/^  CostmapLayer() : has_extra_bounds_(false),$/;"	f	class:costmap_2d::CostmapLayer
CostmapLayer	costmap_2d/include/costmap_2d/costmap_layer.h	/^class CostmapLayer : public Layer, public Costmap2D$/;"	c	namespace:costmap_2d
CostmapModel	base_local_planner/include/base_local_planner/costmap_model.h	/^  class CostmapModel : public WorldModel {$/;"	c	namespace:base_local_planner
CostmapModel	base_local_planner/src/costmap_model.cpp	/^    CostmapModel::CostmapModel(const Costmap2D& ma) : costmap_(ma) {}$/;"	f	class:base_local_planner::CostmapModel
CostmapTester	costmap_2d/test/costmap_tester.cpp	/^CostmapTester::CostmapTester(tf2_ros::Buffer& tf): costmap_ros_("test_costmap", tf){}$/;"	f	class:costmap_2d::CostmapTester
CostmapTester	costmap_2d/test/costmap_tester.cpp	/^class CostmapTester : public testing::Test {$/;"	c	namespace:costmap_2d	file:
DBL_MAX	base_local_planner/include/base_local_planner/trajectory_inc.h	40;"	d
DBL_MIN	base_local_planner/include/base_local_planner/trajectory_inc.h	44;"	d
DWAPlanner	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^  class DWAPlanner {$/;"	c	namespace:dwa_local_planner
DWAPlanner	dwa_local_planner/src/dwa_planner.cpp	/^  DWAPlanner::DWAPlanner(std::string name, base_local_planner::LocalPlannerUtil *planner_util) :$/;"	f	class:dwa_local_planner::DWAPlanner
DWAPlannerROS	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^  class DWAPlannerROS : public nav_core::BaseLocalPlanner {$/;"	c	namespace:dwa_local_planner
DWAPlannerROS	dwa_local_planner/src/dwa_planner_ros.cpp	/^            DWAPlannerROS::DWAPlannerROS() : initialized_(false),$/;"	f	class:dwa_local_planner::DWAPlannerROS
DWA_LOCAL_PLANNER_DWA_PLANNER_H_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	38;"	d
DWA_LOCAL_PLANNER_DWA_PLANNER_ROS_H_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	38;"	d
DWA_LOCAL_PLANNER_VELOCITY_ITERATOR_H_	base_local_planner/include/base_local_planner/velocity_iterator.h	38;"	d
DijkstraExpansion	global_planner/include/global_planner/dijkstra.h	/^class DijkstraExpansion : public Expander {$/;"	c	namespace:global_planner
DijkstraExpansion	global_planner/src/dijkstra.cpp	/^DijkstraExpansion::DijkstraExpansion(PotentialCalculator* p_calc, int nx, int ny) :$/;"	f	class:global_planner::DijkstraExpansion
EMPTY_100_BY_100	costmap_2d/test/module_tests.cpp	/^std::vector<unsigned char> EMPTY_100_BY_100;$/;"	v
EMPTY_10_BY_10	costmap_2d/test/module_tests.cpp	/^std::vector<unsigned char> EMPTY_10_BY_10;$/;"	v
Expander	global_planner/include/global_planner/expander.h	/^        Expander(PotentialCalculator* p_calc, int nx, int ny) :$/;"	f	class:global_planner::Expander
Expander	global_planner/include/global_planner/expander.h	/^class Expander {$/;"	c	namespace:global_planner
FIXED	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^    FIXED,$/;"	e	enum:range_sensor_layer::RangeSensorLayer::InputSensorType
FOOTPRINT_HELPER_H_	base_local_planner/include/base_local_planner/footprint_helper.h	39;"	d
FORWARD	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
FORWARDTHENINTERPOLATE	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
FREE	voxel_grid/include/voxel_grid/voxel_grid.h	/^  FREE = 0,$/;"	e	enum:voxel_grid::VoxelStatus
FREE_SPACE	costmap_2d/include/costmap_2d/cost_values.h	/^static const unsigned char FREE_SPACE = 0;$/;"	m	namespace:costmap_2d
FakeOdomNode	fake_localization/fake_localization.cpp	/^    FakeOdomNode(void)$/;"	f	class:FakeOdomNode
FakeOdomNode	fake_localization/fake_localization.cpp	/^class FakeOdomNode$/;"	c	file:
FootprintHelper	base_local_planner/include/base_local_planner/footprint_helper.h	/^class FootprintHelper {$/;"	c	namespace:base_local_planner
FootprintHelper	base_local_planner/src/footprint_helper.cpp	/^FootprintHelper::FootprintHelper() {$/;"	f	class:base_local_planner::FootprintHelper
FootprintHelperTest	base_local_planner/test/footprint_helper_test.cpp	/^  FootprintHelperTest() {$/;"	f	class:base_local_planner::FootprintHelperTest
FootprintHelperTest	base_local_planner/test/footprint_helper_test.cpp	/^class FootprintHelperTest : public testing::Test {$/;"	c	namespace:base_local_planner	file:
GLOBAL_PLANNER_ORIENTATION_FILTER_H	global_planner/include/global_planner/orientation_filter.h	38;"	d
GOAL_ATTRIBUTE_UNUSED	base_local_planner/src/goal_functions.cpp	42;"	d	file:
GOAL_ATTRIBUTE_UNUSED	base_local_planner/src/goal_functions.cpp	44;"	d	file:
GlobalPlanner	global_planner/include/global_planner/planner_core.h	/^class GlobalPlanner : public nav_core::BaseGlobalPlanner {$/;"	c	namespace:global_planner
GlobalPlanner	global_planner/src/planner_core.cpp	/^GlobalPlanner::GlobalPlanner() :$/;"	f	class:global_planner::GlobalPlanner
GlobalPlanner	global_planner/src/planner_core.cpp	/^GlobalPlanner::GlobalPlanner(std::string name, costmap_2d::Costmap2D* costmap, std::string frame_id) :$/;"	f	class:global_planner::GlobalPlanner
GradientPath	global_planner/include/global_planner/gradient_path.h	/^class GradientPath : public Traceback {$/;"	c	namespace:global_planner
GradientPath	global_planner/src/gradient_path.cpp	/^GradientPath::GradientPath(PotentialCalculator* p_calc) :$/;"	f	class:global_planner::GradientPath
GridOffset	voxel_grid/include/voxel_grid/voxel_grid.h	/^    GridOffset(unsigned int &offset) : offset_(offset) {}$/;"	f	class:voxel_grid::VoxelGrid::GridOffset
GridOffset	voxel_grid/include/voxel_grid/voxel_grid.h	/^  class GridOffset$/;"	c	class:voxel_grid::VoxelGrid
GridPath	global_planner/include/global_planner/grid_path.h	/^        GridPath(PotentialCalculator* p_calc): Traceback(p_calc){}$/;"	f	class:global_planner::GridPath
GridPath	global_planner/include/global_planner/grid_path.h	/^class GridPath : public Traceback {$/;"	c	namespace:global_planner
INSCRIBED_INFLATED_OBSTACLE	costmap_2d/include/costmap_2d/cost_values.h	/^static const unsigned char INSCRIBED_INFLATED_OBSTACLE = 253;$/;"	m	namespace:costmap_2d
INTERPOLATE	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
INVSQRT2	global_planner/src/dijkstra.cpp	190;"	d	file:
INVSQRT2	navfn/src/navfn.cpp	437;"	d	file:
INVSQRT2	navfn/src/navfn.cpp	522;"	d	file:
Index	global_planner/include/global_planner/astar.h	/^        Index(int a, float b) {$/;"	f	class:global_planner::Index
Index	global_planner/include/global_planner/astar.h	/^class Index {$/;"	c	namespace:global_planner
InflationLayer	costmap_2d/include/costmap_2d/inflation_layer.h	/^class InflationLayer : public Layer$/;"	c	namespace:costmap_2d
InflationLayer	costmap_2d/plugins/inflation_layer.cpp	/^    InflationLayer::InflationLayer()$/;"	f	class:costmap_2d::InflationLayer
InitSensor	amcl/src/amcl/sensors/amcl_sensor.cpp	/^bool AMCLSensor::InitSensor(pf_t *pf, AMCLSensorData *data)$/;"	f	class:AMCLSensor
InputSensorType	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  enum InputSensorType$/;"	g	class:range_sensor_layer::RangeSensorLayer
LASER_MODEL_BEAM	amcl/include/amcl/sensors/amcl_laser.h	/^  LASER_MODEL_BEAM,$/;"	e	enum:amcl::__anon10
LASER_MODEL_LIKELIHOOD_FIELD	amcl/include/amcl/sensors/amcl_laser.h	/^  LASER_MODEL_LIKELIHOOD_FIELD,$/;"	e	enum:amcl::__anon10
LASER_MODEL_LIKELIHOOD_FIELD_PROB	amcl/include/amcl/sensors/amcl_laser.h	/^  LASER_MODEL_LIKELIHOOD_FIELD_PROB$/;"	e	enum:amcl::__anon10
LATCHED_STOP_ROTATE_CONTROLLER_H_	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	9;"	d
LEFTWARD	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
LETHAL_OBSTACLE	costmap_2d/include/costmap_2d/cost_values.h	/^static const unsigned char LETHAL_OBSTACLE = 254;$/;"	m	namespace:costmap_2d
LETHAL_OBSTACLE_INFLATION	costmap_2d/include/costmap_2d/cost_values.h	/^static const unsigned char LETHAL_OBSTACLE_INFLATION = 254;$/;"	m	namespace:costmap_2d
LINE_ITERATOR_H	base_local_planner/include/base_local_planner/line_iterator.h	30;"	d
Last	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^enum CostAggregationType { Last, Sum, Product};$/;"	e	enum:base_local_planner::CostAggregationType
LatchedStopRotateController	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^class LatchedStopRotateController {$/;"	c	namespace:base_local_planner
LatchedStopRotateController	base_local_planner/src/latched_stop_rotate_controller.cpp	/^LatchedStopRotateController::LatchedStopRotateController(const std::string& name) {$/;"	f	class:base_local_planner::LatchedStopRotateController
Layer	costmap_2d/include/costmap_2d/layer.h	/^class Layer$/;"	c	namespace:costmap_2d
Layer	costmap_2d/src/layer.cpp	/^Layer::Layer()$/;"	f	class:costmap_2d::Layer
LayeredCostmap	costmap_2d/include/costmap_2d/layered_costmap.h	/^class LayeredCostmap$/;"	c	namespace:costmap_2d
LayeredCostmap	costmap_2d/src/layered_costmap.cpp	/^    LayeredCostmap::LayeredCostmap(std::string global_frame, bool rolling_window, bool track_unknown) :$/;"	f	class:costmap_2d::LayeredCostmap
LikelihoodFieldModel	amcl/src/amcl/sensors/amcl_laser.cpp	/^double AMCLLaser::LikelihoodFieldModel(AMCLLaserData *data, pf_sample_set_t* set)$/;"	f	class:AMCLLaser
LikelihoodFieldModelProb	amcl/src/amcl/sensors/amcl_laser.cpp	/^double AMCLLaser::LikelihoodFieldModelProb(AMCLLaserData *data, pf_sample_set_t* set)$/;"	f	class:AMCLLaser
LineIterator	base_local_planner/include/base_local_planner/line_iterator.h	/^  LineIterator( int x0, int y0, int x1, int y1 )$/;"	f	class:base_local_planner::LineIterator
LineIterator	base_local_planner/include/base_local_planner/line_iterator.h	/^class LineIterator$/;"	c	namespace:base_local_planner
LocalPlannerLimits	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  LocalPlannerLimits($/;"	f	class:base_local_planner::LocalPlannerLimits
LocalPlannerLimits	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  LocalPlannerLimits() {}$/;"	f	class:base_local_planner::LocalPlannerLimits
LocalPlannerLimits	base_local_planner/include/base_local_planner/local_planner_limits.h	/^class LocalPlannerLimits$/;"	c	namespace:base_local_planner
LocalPlannerUtil	base_local_planner/include/base_local_planner/local_planner_util.h	/^  LocalPlannerUtil() : initialized_(false) {}$/;"	f	class:base_local_planner::LocalPlannerUtil
LocalPlannerUtil	base_local_planner/include/base_local_planner/local_planner_util.h	/^class LocalPlannerUtil {$/;"	c	namespace:base_local_planner
MAP_10_BY_10	costmap_2d/test/module_tests.cpp	/^std::vector<unsigned char> MAP_10_BY_10;$/;"	v
MAP_10_BY_10_CHAR	costmap_2d/test/module_tests.cpp	/^const unsigned char MAP_10_BY_10_CHAR[] = {$/;"	v
MAP_5_BY_5	costmap_2d/test/module_tests.cpp	/^std::vector<unsigned char> MAP_5_BY_5;$/;"	v
MAP_5_BY_5_CHAR	costmap_2d/test/module_tests.cpp	/^const unsigned char MAP_5_BY_5_CHAR[] = {$/;"	v
MAP_GRID_COST_FUNCTION_H_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	39;"	d
MAP_GRID_VISUALIZER_H_	base_local_planner/include/base_local_planner/map_grid_visualizer.h	35;"	d
MAP_GXWX	amcl/include/amcl/map/map.h	137;"	d
MAP_GYWY	amcl/include/amcl/map/map.h	138;"	d
MAP_H	amcl/include/amcl/map/map.h	29;"	d
MAP_IDX	map_server/src/image_loader.cpp	51;"	d	file:
MAP_INDEX	amcl/include/amcl/map/map.h	144;"	d
MAP_SERVER_MAP_SERVER_H	map_server/include/map_server/image_loader.h	30;"	d
MAP_SERVER_TEST_CONSTANTS_H	map_server/test/test_constants.h	30;"	d
MAP_VALID	amcl/include/amcl/map/map.h	141;"	d
MAP_WIFI_MAX_LEVELS	amcl/include/amcl/map/map.h	42;"	d
MAP_WXGX	amcl/include/amcl/map/map.h	133;"	d
MAP_WYGY	amcl/include/amcl/map/map.h	134;"	d
MARKED	voxel_grid/include/voxel_grid/voxel_grid.h	/^  MARKED = 2,$/;"	e	enum:voxel_grid::VoxelStatus
MAX	amcl/src/amcl/pf/eig3.c	8;"	d	file:
MOVE_SLOW_AND_CLEAR_MOVE_SLOW_AND_CLEAR_H_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	38;"	d
MapCell	base_local_planner/include/base_local_planner/map_cell.h	/^  class MapCell{$/;"	c	namespace:base_local_planner
MapCell	base_local_planner/src/map_cell.cpp	/^  MapCell::MapCell()$/;"	f	class:base_local_planner::MapCell
MapCell	base_local_planner/src/map_cell.cpp	/^  MapCell::MapCell(const MapCell& mc)$/;"	f	class:base_local_planner::MapCell
MapClientTest	map_server/test/rtest.cpp	/^    MapClientTest()$/;"	f	class:MapClientTest
MapClientTest	map_server/test/rtest.cpp	/^class MapClientTest : public testing::Test$/;"	c	file:
MapGenerator	map_server/src/map_saver.cpp	/^    MapGenerator(const std::string& mapname, int threshold_occupied, int threshold_free)$/;"	f	class:MapGenerator
MapGenerator	map_server/src/map_saver.cpp	/^class MapGenerator$/;"	c	file:
MapGrid	base_local_planner/include/base_local_planner/map_grid.h	/^  class MapGrid{$/;"	c	namespace:base_local_planner
MapGrid	base_local_planner/src/map_grid.cpp	/^  MapGrid::MapGrid()$/;"	f	class:base_local_planner::MapGrid
MapGrid	base_local_planner/src/map_grid.cpp	/^  MapGrid::MapGrid(const MapGrid& mg){$/;"	f	class:base_local_planner::MapGrid
MapGrid	base_local_planner/src/map_grid.cpp	/^  MapGrid::MapGrid(unsigned int size_x, unsigned int size_y) $/;"	f	class:base_local_planner::MapGrid
MapGridCostFunction	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^class MapGridCostFunction: public base_local_planner::TrajectoryCostFunction {$/;"	c	namespace:base_local_planner
MapGridCostFunction	base_local_planner/src/map_grid_cost_function.cpp	/^    MapGridCostFunction::MapGridCostFunction(costmap_2d::Costmap2D* costmap,$/;"	f	class:base_local_planner::MapGridCostFunction
MapGridVisualizer	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^    class MapGridVisualizer {$/;"	c	namespace:base_local_planner
MapGridVisualizer	base_local_planner/src/map_grid_visualizer.cpp	/^  MapGridVisualizer::MapGridVisualizer() {}$/;"	f	class:base_local_planner::MapGridVisualizer
MapLocation	costmap_2d/include/costmap_2d/costmap_2d.h	/^struct MapLocation$/;"	s	namespace:costmap_2d
MapMode	map_server/include/map_server/image_loader.h	/^enum MapMode {TRINARY, SCALE, RAW};$/;"	g
MapServer	map_server/src/main.cpp	/^    MapServer(const std::string& fname, double res)$/;"	f	class:MapServer
MapServer	map_server/src/main.cpp	/^class MapServer$/;"	c	file:
MarkCell	costmap_2d/include/costmap_2d/costmap_2d.h	/^    MarkCell(unsigned char* costmap, unsigned char value) :$/;"	f	class:costmap_2d::Costmap2D::MarkCell
MarkCell	costmap_2d/include/costmap_2d/costmap_2d.h	/^  class MarkCell$/;"	c	class:costmap_2d::Costmap2D
MarkVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^    MarkVoxel(uint32_t* data): data_(data){}$/;"	f	class:voxel_grid::VoxelGrid::MarkVoxel
MarkVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^  class MarkVoxel$/;"	c	class:voxel_grid::VoxelGrid
MoveBase	move_base/include/move_base/move_base.h	/^  class MoveBase {$/;"	c	namespace:move_base
MoveBase	move_base/src/move_base.cpp	/^    MoveBase::MoveBase(tf2_ros::Buffer& tf) :$/;"	f	class:move_base::MoveBase
MoveBaseActionServer	move_base/include/move_base/move_base.h	/^  typedef actionlib::SimpleActionServer<move_base_msgs::MoveBaseAction> MoveBaseActionServer;$/;"	t	namespace:move_base
MoveBaseState	move_base/include/move_base/move_base.h	/^  enum MoveBaseState {$/;"	g	namespace:move_base
MoveSlowAndClear	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^  class MoveSlowAndClear : public nav_core::RecoveryBehavior$/;"	c	namespace:move_slow_and_clear
MoveSlowAndClear	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    MoveSlowAndClear::MoveSlowAndClear():global_costmap_(NULL), local_costmap_(NULL), $/;"	f	class:move_slow_and_clear::MoveSlowAndClear
NAME	map_server/test/consumer.py	/^NAME = 'consumer'$/;"	v
NAVFN_NAVFN_ROS_H_	navfn/include/navfn/navfn_ros.h	38;"	d
NAV_CORE_BASE_GLOBAL_PLANNER_H	nav_core/include/nav_core/base_global_planner.h	38;"	d
NAV_CORE_BASE_LOCAL_PLANNER_H	nav_core/include/nav_core/base_local_planner.h	38;"	d
NAV_CORE_PARAMETER_MAGIC_H	nav_core/include/nav_core/parameter_magic.h	39;"	d
NAV_CORE_RECOVERY_BEHAVIOR_H	nav_core/include/nav_core/recovery_behavior.h	38;"	d
NAV_MOVE_BASE_ACTION_H_	move_base/include/move_base/move_base.h	38;"	d
NEW_UNIFORM_SAMPLING	amcl/src/amcl_node.cpp	79;"	d	file:
NONE	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
NO_INFORMATION	costmap_2d/include/costmap_2d/cost_values.h	/^static const unsigned char NO_INFORMATION = 255;$/;"	m	namespace:costmap_2d
NavFn	navfn/include/navfn/navfn.h	/^  class NavFn$/;"	c	namespace:navfn
NavFn	navfn/src/navfn.cpp	/^  NavFn::NavFn(int xs, int ys)$/;"	f	class:navfn::NavFn
NavWin	navfn/include/navfn/navwin.h	/^  class NavWin $/;"	c	namespace:navfn
NavWin	navfn/src/navwin.cpp	/^NavWin::NavWin(int w, int h, const char *name)$/;"	f	class:navfn::NavWin
NavfnROS	navfn/include/navfn/navfn_ros.h	/^  class NavfnROS : public nav_core::BaseGlobalPlanner {$/;"	c	namespace:navfn
NavfnROS	navfn/src/navfn_ros.cpp	/^  NavfnROS::NavfnROS() $/;"	f	class:navfn::NavfnROS
NavfnROS	navfn/src/navfn_ros.cpp	/^  NavfnROS::NavfnROS(std::string name, costmap_2d::Costmap2D* costmap, std::string global_frame)$/;"	f	class:navfn::NavfnROS
NavfnROS	navfn/src/navfn_ros.cpp	/^  NavfnROS::NavfnROS(std::string name, costmap_2d::Costmap2DROS* costmap_ros)$/;"	f	class:navfn::NavfnROS
NavfnWithCostmap	navfn/src/navfn_node.cpp	/^NavfnWithCostmap::NavfnWithCostmap(string name, Costmap2DROS* cmap) : $/;"	f	class:navfn::NavfnWithCostmap
NavfnWithCostmap	navfn/src/navfn_node.cpp	/^class NavfnWithCostmap : public NavfnROS$/;"	c	namespace:navfn	file:
OBSTACLE_COST_FUNCTION_H_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	39;"	d
ODOMETRY_HELPER_ROS2_H_	base_local_planner/include/base_local_planner/odometry_helper_ros.h	39;"	d
ODOM_MODEL_DIFF	amcl/include/amcl/sensors/amcl_odom.h	/^  ODOM_MODEL_DIFF,$/;"	e	enum:amcl::__anon9
ODOM_MODEL_DIFF_CORRECTED	amcl/include/amcl/sensors/amcl_odom.h	/^  ODOM_MODEL_DIFF_CORRECTED,$/;"	e	enum:amcl::__anon9
ODOM_MODEL_OMNI	amcl/include/amcl/sensors/amcl_odom.h	/^  ODOM_MODEL_OMNI,$/;"	e	enum:amcl::__anon9
ODOM_MODEL_OMNI_CORRECTED	amcl/include/amcl/sensors/amcl_odom.h	/^  ODOM_MODEL_OMNI_CORRECTED$/;"	e	enum:amcl::__anon9
OSCILLATION_COST_FUNCTION_H_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	39;"	d
OSCILLATION_R	move_base/include/move_base/move_base.h	/^    OSCILLATION_R$/;"	e	enum:move_base::RecoveryTrigger
Observation	costmap_2d/include/costmap_2d/observation.h	/^  Observation() :$/;"	f	class:costmap_2d::Observation
Observation	costmap_2d/include/costmap_2d/observation.h	/^  Observation(const Observation& obs) :$/;"	f	class:costmap_2d::Observation
Observation	costmap_2d/include/costmap_2d/observation.h	/^  Observation(const sensor_msgs::PointCloud2 &cloud, double obstacle_range) :$/;"	f	class:costmap_2d::Observation
Observation	costmap_2d/include/costmap_2d/observation.h	/^  Observation(geometry_msgs::Point& origin, const sensor_msgs::PointCloud2 &cloud,$/;"	f	class:costmap_2d::Observation
Observation	costmap_2d/include/costmap_2d/observation.h	/^class Observation$/;"	c	namespace:costmap_2d
ObservationBuffer	costmap_2d/include/costmap_2d/observation_buffer.h	/^class ObservationBuffer$/;"	c	namespace:costmap_2d
ObservationBuffer	costmap_2d/src/observation_buffer.cpp	/^ObservationBuffer::ObservationBuffer(string topic_name, double observation_keep_time, double expected_update_rate,$/;"	f	class:costmap_2d::ObservationBuffer
ObstacleCostFunction	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^class ObstacleCostFunction : public TrajectoryCostFunction {$/;"	c	namespace:base_local_planner
ObstacleCostFunction	base_local_planner/src/obstacle_cost_function.cpp	/^    ObstacleCostFunction::ObstacleCostFunction(costmap_2d::Costmap2D* costmap) $/;"	f	class:base_local_planner::ObstacleCostFunction
ObstacleLayer	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  ObstacleLayer()$/;"	f	class:costmap_2d::ObstacleLayer
ObstacleLayer	costmap_2d/include/costmap_2d/obstacle_layer.h	/^class ObstacleLayer : public CostmapLayer$/;"	c	namespace:costmap_2d
OdometryHelperRos	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^class OdometryHelperRos {$/;"	c	namespace:base_local_planner
OdometryHelperRos	base_local_planner/src/odometry_helper_ros.cpp	/^OdometryHelperRos::OdometryHelperRos(std::string odom_topic) {$/;"	f	class:base_local_planner::OdometryHelperRos
OrientationFilter	global_planner/include/global_planner/orientation_filter.h	/^        OrientationFilter() : omode_(NONE) {}$/;"	f	class:global_planner::OrientationFilter
OrientationFilter	global_planner/include/global_planner/orientation_filter.h	/^class OrientationFilter {$/;"	c	namespace:global_planner
OrientationMode	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	g	namespace:global_planner
OscillationCostFunction	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^class OscillationCostFunction: public base_local_planner::TrajectoryCostFunction {$/;"	c	namespace:base_local_planner
OscillationCostFunction	base_local_planner/src/oscillation_cost_function.cpp	/^    OscillationCostFunction::OscillationCostFunction() {$/;"	f	class:base_local_planner::OscillationCostFunction
PACKAGE	amcl/cfg/AMCL.cfg	/^PACKAGE = 'amcl'$/;"	v
PACKAGE	base_local_planner/cfg/BaseLocalPlanner.cfg	/^PACKAGE = 'base_local_planner'$/;"	v
PACKAGE	costmap_2d/cfg/RangeSensorLayer.cfg	/^PACKAGE = "range_sensor_layer"$/;"	v
PACKAGE	global_planner/cfg/GlobalPlanner.cfg	/^PACKAGE = "global_planner"$/;"	v
PACKAGE	move_base/cfg/MoveBase.cfg	/^PACKAGE = 'move_base'$/;"	v
PF_H	amcl/include/amcl/pf/pf.h	29;"	d
PF_KDTREE_H	amcl/include/amcl/pf/pf_kdtree.h	29;"	d
PF_PDF_H	amcl/include/amcl/pf/pf_pdf.h	29;"	d
PF_VECTOR_H	amcl/include/amcl/pf/pf_vector.h	29;"	d
PKG	map_server/test/consumer.py	/^PKG = 'static_map_server'$/;"	v
PLANNING	move_base/include/move_base/move_base.h	/^    PLANNING,$/;"	e	enum:move_base::MoveBaseState
PLANNING_R	move_base/include/move_base/move_base.h	/^    PLANNING_R,$/;"	e	enum:move_base::RecoveryTrigger
POINT_GRID_H_	base_local_planner/include/base_local_planner/point_grid.h	38;"	d
PORTABLE_UTILS_H	amcl/src/include/portable_utils.hpp	2;"	d
POTARR_POINT_H_	navfn/include/navfn/potarr_point.h	38;"	d
POT_HIGH	global_planner/include/global_planner/planner_core.h	40;"	d
POT_HIGH	navfn/include/navfn/navfn.h	75;"	d
PREFER_FORWARD_COST_FUNCTION_H_	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	39;"	d
PRIORITYBUFSIZE	global_planner/include/global_planner/dijkstra.h	41;"	d
PRIORITYBUFSIZE	navfn/include/navfn/navfn.h	78;"	d
PlanarLaserScan	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^      PlanarLaserScan() {}$/;"	f	class:base_local_planner::PlanarLaserScan
PlanarLaserScan	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^  class PlanarLaserScan {$/;"	c	namespace:base_local_planner
PlannerWithCostmap	global_planner/src/plan_node.cpp	/^PlannerWithCostmap::PlannerWithCostmap(string name, Costmap2DROS* cmap) :$/;"	f	class:global_planner::PlannerWithCostmap
PlannerWithCostmap	global_planner/src/plan_node.cpp	/^class PlannerWithCostmap : public GlobalPlanner {$/;"	c	namespace:global_planner	file:
PointGrid	base_local_planner/include/base_local_planner/point_grid.h	/^  class PointGrid : public WorldModel {$/;"	c	namespace:base_local_planner
PointGrid	base_local_planner/src/point_grid.cpp	/^PointGrid::PointGrid(double size_x, double size_y, double resolution, geometry_msgs::Point origin, double max_z, double obstacle_range, double min_seperation) :$/;"	f	class:base_local_planner::PointGrid
PolygonOutlineCells	costmap_2d/include/costmap_2d/costmap_2d.h	/^    PolygonOutlineCells(const Costmap2D& costmap, const unsigned char* char_map, std::vector<MapLocation>& cells) :$/;"	f	class:costmap_2d::Costmap2D::PolygonOutlineCells
PolygonOutlineCells	costmap_2d/include/costmap_2d/costmap_2d.h	/^  class PolygonOutlineCells$/;"	c	class:costmap_2d::Costmap2D
PoseSetter	amcl/test/set_pose.py	/^class PoseSetter(rospy.SubscribeListener):$/;"	c
PotarrPoint	navfn/include/navfn/potarr_point.h	/^    struct PotarrPoint {$/;"	s	namespace:navfn
PotentialCalculator	global_planner/include/global_planner/potential_calculator.h	/^        PotentialCalculator(int nx, int ny) {$/;"	f	class:global_planner::PotentialCalculator
PotentialCalculator	global_planner/include/global_planner/potential_calculator.h	/^class PotentialCalculator {$/;"	c	namespace:global_planner
PreferForwardCostFunction	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^  PreferForwardCostFunction(double penalty) : penalty_(penalty) {}$/;"	f	class:base_local_planner::PreferForwardCostFunction
PreferForwardCostFunction	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^class PreferForwardCostFunction: public base_local_planner::TrajectoryCostFunction {$/;"	c	namespace:base_local_planner
Product	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^enum CostAggregationType { Last, Sum, Product};$/;"	e	enum:base_local_planner::CostAggregationType
QuadraticCalculator	global_planner/include/global_planner/quadratic_calculator.h	/^        QuadraticCalculator(int nx, int ny): PotentialCalculator(nx,ny) {}$/;"	f	class:global_planner::QuadraticCalculator
QuadraticCalculator	global_planner/include/global_planner/quadratic_calculator.h	/^class QuadraticCalculator : public PotentialCalculator {$/;"	c	namespace:global_planner
RANGE_SENSOR_LAYER_RANGE_SENSOR_LAYER_H_	costmap_2d/include/costmap_2d/range_sensor_layer.h	3;"	d
RAW	map_server/include/map_server/image_loader.h	/^enum MapMode {TRINARY, SCALE, RAW};$/;"	e	enum:MapMode
READ_PGM_COSTMAP_H	navfn/include/navfn/read_pgm_costmap.h	30;"	d
RIGHTWARD	global_planner/include/global_planner/orientation_filter.h	/^enum OrientationMode { NONE, FORWARD, INTERPOLATE, FORWARDTHENINTERPOLATE, BACKWARD, LEFTWARD, RIGHTWARD };$/;"	e	enum:global_planner::OrientationMode
ROTATE_RECOVERY_ROTATE_RECOVERY_H	rotate_recovery/include/rotate_recovery/rotate_recovery.h	38;"	d
RangeSensorLayer	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^class RangeSensorLayer : public costmap_2d::CostmapLayer$/;"	c	namespace:range_sensor_layer
RangeSensorLayer	costmap_2d/plugins/range_sensor_layer.cpp	/^    RangeSensorLayer::RangeSensorLayer() {}$/;"	f	class:range_sensor_layer::RangeSensorLayer
RecoveryBehavior	nav_core/include/nav_core/recovery_behavior.h	/^      RecoveryBehavior(){}$/;"	f	class:nav_core::RecoveryBehavior
RecoveryBehavior	nav_core/include/nav_core/recovery_behavior.h	/^  class RecoveryBehavior{$/;"	c	namespace:nav_core
RecoveryTrigger	move_base/include/move_base/move_base.h	/^  enum RecoveryTrigger$/;"	g	namespace:move_base
RotateRecovery	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^class RotateRecovery : public nav_core::RecoveryBehavior$/;"	c	namespace:rotate_recovery
RotateRecovery	rotate_recovery/src/rotate_recovery.cpp	/^    RotateRecovery::RotateRecovery(): local_costmap_(NULL), initialized_(false), world_model_(NULL)$/;"	f	class:rotate_recovery::RotateRecovery
SCALE	map_server/include/map_server/image_loader.h	/^enum MapMode {TRINARY, SCALE, RAW};$/;"	e	enum:MapMode
SIMPLE_SCORED_SAMPLING_PLANNER_H_	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	39;"	d
SIMPLE_TRAJECTORY_GENERATOR_H_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	39;"	d
SetLaserPose	amcl/include/amcl/sensors/amcl_laser.h	/^  public: void SetLaserPose(pf_vector_t& laser_pose) $/;"	f	class:amcl::AMCLLaser
SetModel	amcl/src/amcl/sensors/amcl_odom.cpp	/^AMCLOdom::SetModel( odom_model_t type,$/;"	f	class:AMCLOdom
SetModelBeam	amcl/src/amcl/sensors/amcl_laser.cpp	/^AMCLLaser::SetModelBeam(double z_hit,$/;"	f	class:AMCLLaser
SetModelDiff	amcl/src/amcl/sensors/amcl_odom.cpp	/^AMCLOdom::SetModelDiff(double alpha1, $/;"	f	class:AMCLOdom
SetModelLikelihoodField	amcl/src/amcl/sensors/amcl_laser.cpp	/^AMCLLaser::SetModelLikelihoodField(double z_hit,$/;"	f	class:AMCLLaser
SetModelLikelihoodFieldProb	amcl/src/amcl/sensors/amcl_laser.cpp	/^AMCLLaser::SetModelLikelihoodFieldProb(double z_hit,$/;"	f	class:AMCLLaser
SetModelOmni	amcl/src/amcl/sensors/amcl_odom.cpp	/^AMCLOdom::SetModelOmni(double alpha1, $/;"	f	class:AMCLOdom
SetupGUI	amcl/src/amcl/sensors/amcl_sensor.cpp	/^void AMCLSensor::SetupGUI(rtk_canvas_t *canvas, rtk_fig_t *robot_fig)$/;"	f	class:AMCLSensor
ShutdownGUI	amcl/src/amcl/sensors/amcl_sensor.cpp	/^void AMCLSensor::ShutdownGUI(rtk_canvas_t *canvas, rtk_fig_t *robot_fig)$/;"	f	class:AMCLSensor
SimpleScoredSamplingPlanner	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^  SimpleScoredSamplingPlanner() {}$/;"	f	class:base_local_planner::SimpleScoredSamplingPlanner
SimpleScoredSamplingPlanner	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^class SimpleScoredSamplingPlanner : public base_local_planner::TrajectorySearch {$/;"	c	namespace:base_local_planner
SimpleScoredSamplingPlanner	base_local_planner/src/simple_scored_sampling_planner.cpp	/^    SimpleScoredSamplingPlanner::SimpleScoredSamplingPlanner(std::vector<TrajectorySampleGenerator*> gen_list, std::vector<TrajectoryCostFunction*>& critics, int max_samples) {$/;"	f	class:base_local_planner::SimpleScoredSamplingPlanner
SimpleTrajectoryGenerator	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  SimpleTrajectoryGenerator() {$/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
SimpleTrajectoryGenerator	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^class SimpleTrajectoryGenerator: public base_local_planner::TrajectorySampleGenerator {$/;"	c	namespace:base_local_planner
StaticLayer	costmap_2d/include/costmap_2d/static_layer.h	/^class StaticLayer : public CostmapLayer$/;"	c	namespace:costmap_2d
StaticLayer	costmap_2d/plugins/static_layer.cpp	/^    StaticLayer::StaticLayer() : dsrv_(NULL) {}$/;"	f	class:costmap_2d::StaticLayer
Sum	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^enum CostAggregationType { Last, Sum, Product};$/;"	e	enum:base_local_planner::CostAggregationType
SuperValue	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^class SuperValue : public XmlRpc::XmlRpcValue$/;"	c
TEST	base_local_planner/test/footprint_helper_test.cpp	/^TEST(FootprintHelperTest, correctFootprint){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/footprint_helper_test.cpp	/^TEST(FootprintHelperTest, correctLineCells){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/line_iterator_test.cpp	/^TEST( LineIterator, north_north_west )$/;"	f
TEST	base_local_planner/test/line_iterator_test.cpp	/^TEST( LineIterator, south )$/;"	f
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, adjustPlan){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, adjustPlan2){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, adjustPlanEmpty){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, copyConstructor){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, distancePropagation){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, getIndex){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, initNull){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, operatorBrackets){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, properGridConstruction){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, reset){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/map_grid_test.cpp	/^TEST(MapGridTest, sizeCheck){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/utest.cpp	/^TEST(TrajectoryPlannerTest, checkGoalDistance){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/utest.cpp	/^TEST(TrajectoryPlannerTest, checkPathDistance){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/utest.cpp	/^TEST(TrajectoryPlannerTest, footprintObstacles){$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test1) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test1_neg) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test1_pos) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test3) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test4) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test_cranky) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, test_shifted) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, testsingle) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, testsingle_neg) {$/;"	f	namespace:base_local_planner
TEST	base_local_planner/test/velocity_iterator_test.cpp	/^TEST(VelocityIteratorTest, testsingle_pos) {$/;"	f	namespace:base_local_planner
TEST	clear_costmap_recovery/test/clear_tester.cpp	/^TEST(ClearTester, basicTest){$/;"	f
TEST	clear_costmap_recovery/test/clear_tester.cpp	/^TEST(ClearTester, bigRadiusTest){$/;"	f
TEST	clear_costmap_recovery/test/clear_tester.cpp	/^TEST(ClearTester, clearBothTest){$/;"	f
TEST	clear_costmap_recovery/test/clear_tester.cpp	/^TEST(ClearTester, clearBothTest2){$/;"	f
TEST	clear_costmap_recovery/test/clear_tester.cpp	/^TEST(ClearTester, clearNoLayersTest){$/;"	f
TEST	costmap_2d/test/array_parser_test.cpp	/^TEST(array_parser, basic_operation)$/;"	f
TEST	costmap_2d/test/array_parser_test.cpp	/^TEST(array_parser, missing_close)$/;"	f
TEST	costmap_2d/test/array_parser_test.cpp	/^TEST(array_parser, missing_open)$/;"	f
TEST	costmap_2d/test/array_parser_test.cpp	/^TEST(array_parser, wrong_depth)$/;"	f
TEST	costmap_2d/test/coordinates_test.cpp	/^TEST(CostmapCoordinates, easy_coordinates_test)$/;"	f
TEST	costmap_2d/test/coordinates_test.cpp	/^TEST(CostmapCoordinates, hard_coordinates_test)$/;"	f
TEST	costmap_2d/test/costmap_tester.cpp	/^TEST(CostmapTester, checkConsistentCosts){$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, footprint_empty )$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, footprint_from_same_level_param )$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, footprint_from_xmlrpc_param )$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, footprint_from_xmlrpc_param_failure )$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, padded_footprint_from_string_param )$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, radius_param )$/;"	f
TEST	costmap_2d/test/footprint_tests.cpp	/^TEST( Costmap2DROS, unpadded_footprint_from_string_param )$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testAdjacentToObstacleCanStillMove){$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testCostFunctionCorrectness){$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testInflation){$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testInflation2){$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testInflation3){$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testInflationOrderCorrectness){$/;"	f
TEST	costmap_2d/test/inflation_tests.cpp	/^TEST(costmap, testInflationShouldNotCreateUnknowns){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testAdjacentToObstacleCanStillMove){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testCostFunctionCorrectness){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testDynamicObstacles){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testFullyContainedStaticMapUpdate){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testInflation){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testInflation2){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testInflation3){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testInflationShouldNotCreateUnknowns){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testMultipleAdditions){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testOverlapStaticMapUpdate){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testRaytracing){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testRaytracing2){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testResetForStaticMap){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testStaticMap){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testTrickyPropagation){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testWaveInterference){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testWindowCopy){$/;"	f
TEST	costmap_2d/test/module_tests.cpp	/^TEST(costmap, testZThreshold){$/;"	f
TEST	costmap_2d/test/obstacle_tests.cpp	/^TEST(costmap, testDynamicObstacles){$/;"	f
TEST	costmap_2d/test/obstacle_tests.cpp	/^TEST(costmap, testMultipleAdditions){$/;"	f
TEST	costmap_2d/test/obstacle_tests.cpp	/^TEST(costmap, testRaytracing){$/;"	f
TEST	costmap_2d/test/obstacle_tests.cpp	/^TEST(costmap, testRaytracing2){$/;"	f
TEST	costmap_2d/test/obstacle_tests.cpp	/^TEST(costmap, testWaveInterference){$/;"	f
TEST	costmap_2d/test/obstacle_tests.cpp	/^TEST(costmap, testZThreshold){$/;"	f
TEST	map_server/test/utest.cpp	/^TEST(MapServer, loadInvalidFile)$/;"	f
TEST	map_server/test/utest.cpp	/^TEST(MapServer, loadValidBMP)$/;"	f
TEST	map_server/test/utest.cpp	/^TEST(MapServer, loadValidPNG)$/;"	f
TEST	map_server/test/utest.cpp	/^TEST(MapServer, testMapMode)$/;"	f
TEST	navfn/test/path_calc_test.cpp	/^TEST(PathCalc, easy_nav_should_always_work)$/;"	f
TEST	navfn/test/path_calc_test.cpp	/^TEST(PathCalc, oscillate_in_pinch_point)$/;"	f
TEST	voxel_grid/test/voxel_grid_tests.cpp	/^TEST(voxel_grid, basicMarkingAndClearing){$/;"	f
TEST_F	map_server/test/rtest.cpp	/^TEST_F(MapClientTest, call_service)$/;"	f
TEST_F	map_server/test/rtest.cpp	/^TEST_F(MapClientTest, subscribe_topic)$/;"	f
TEST_F	map_server/test/rtest.cpp	/^TEST_F(MapClientTest, subscribe_topic_metadata)$/;"	f
TRAJECTORYCOSTFUNCTION_H_	base_local_planner/include/base_local_planner/trajectory_cost_function.h	39;"	d
TRAJECTORY_INC_H_	base_local_planner/include/base_local_planner/trajectory_inc.h	35;"	d
TRAJECTORY_ROLLOUT_COSTMAP_MODEL_	base_local_planner/include/base_local_planner/costmap_model.h	38;"	d
TRAJECTORY_ROLLOUT_MAP_CELL_H_	base_local_planner/include/base_local_planner/map_cell.h	35;"	d
TRAJECTORY_ROLLOUT_MAP_GRID_H_	base_local_planner/include/base_local_planner/map_grid.h	35;"	d
TRAJECTORY_ROLLOUT_PLANAR_LASER_SCAN_H_	base_local_planner/include/base_local_planner/planar_laser_scan.h	38;"	d
TRAJECTORY_ROLLOUT_TRAJECTORY_H_	base_local_planner/include/base_local_planner/trajectory.h	35;"	d
TRAJECTORY_ROLLOUT_TRAJECTORY_PLANNER_H_	base_local_planner/include/base_local_planner/trajectory_planner.h	38;"	d
TRAJECTORY_ROLLOUT_TRAJECTORY_PLANNER_ROS_H_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	38;"	d
TRAJECTORY_ROLLOUT_VOXEL_WORLD_MODEL_H_	base_local_planner/include/base_local_planner/voxel_grid_model.h	38;"	d
TRAJECTORY_ROLLOUT_WORLD_MODEL_H_	base_local_planner/include/base_local_planner/world_model.h	38;"	d
TRAJECTORY_SAMPLE_GENERATOR_H_	base_local_planner/include/base_local_planner/trajectory_sample_generator.h	39;"	d
TRAJECTORY_SEARCH_H_	base_local_planner/include/base_local_planner/trajectory_search.h	39;"	d
TRINARY	map_server/include/map_server/image_loader.h	/^enum MapMode {TRINARY, SCALE, RAW};$/;"	e	enum:MapMode
TWIRLING_COST_FUNCTION_H	base_local_planner/include/base_local_planner/twirling_cost_function.h	39;"	d
TestBasicLocalization	amcl/test/basic_localization.py	/^class TestBasicLocalization(unittest.TestCase):$/;"	c
TestBody	base_local_planner/test/footprint_helper_test.cpp	/^  virtual void TestBody(){}$/;"	f	class:base_local_planner::FootprintHelperTest
TestBody	base_local_planner/test/trajectory_generator_test.cpp	/^  virtual void TestBody(){}$/;"	f	class:base_local_planner::TrajectoryGeneratorTest
TestBody	base_local_planner/test/utest.cpp	/^    virtual void TestBody(){}$/;"	f	class:base_local_planner::TrajectoryPlannerTest
TestBody	costmap_2d/test/costmap_tester.cpp	/^    virtual void TestBody(){}$/;"	f	class:costmap_2d::CostmapTester
TestConsumer	map_server/test/consumer.py	/^class TestConsumer(unittest.TestCase):$/;"	c
Traceback	global_planner/include/global_planner/traceback.h	/^        Traceback(PotentialCalculator* p_calc) : p_calc_(p_calc) {}$/;"	f	class:global_planner::Traceback
Traceback	global_planner/include/global_planner/traceback.h	/^class Traceback {$/;"	c	namespace:global_planner
Trajectory	base_local_planner/include/base_local_planner/trajectory.h	/^  class Trajectory {$/;"	c	namespace:base_local_planner
Trajectory	base_local_planner/src/trajectory.cpp	/^  Trajectory::Trajectory()$/;"	f	class:base_local_planner::Trajectory
Trajectory	base_local_planner/src/trajectory.cpp	/^  Trajectory::Trajectory(double xv, double yv, double thetav, double time_delta, unsigned int num_pts)$/;"	f	class:base_local_planner::Trajectory
TrajectoryCostFunction	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^  TrajectoryCostFunction(double scale = 1.0): scale_(scale) {}$/;"	f	class:base_local_planner::TrajectoryCostFunction
TrajectoryCostFunction	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^class TrajectoryCostFunction {$/;"	c	namespace:base_local_planner
TrajectoryGeneratorTest	base_local_planner/test/trajectory_generator_test.cpp	/^  TrajectoryGeneratorTest() {$/;"	f	class:base_local_planner::TrajectoryGeneratorTest
TrajectoryGeneratorTest	base_local_planner/test/trajectory_generator_test.cpp	/^class TrajectoryGeneratorTest : public testing::Test {$/;"	c	namespace:base_local_planner	file:
TrajectoryPlanner	base_local_planner/include/base_local_planner/trajectory_planner.h	/^  class TrajectoryPlanner{$/;"	c	namespace:base_local_planner
TrajectoryPlanner	base_local_planner/src/trajectory_planner.cpp	/^  TrajectoryPlanner::TrajectoryPlanner(WorldModel& world_model,$/;"	f	class:base_local_planner::TrajectoryPlanner
TrajectoryPlannerROS	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^  class TrajectoryPlannerROS : public nav_core::BaseLocalPlanner {$/;"	c	namespace:base_local_planner
TrajectoryPlannerROS	base_local_planner/src/trajectory_planner_ros.cpp	/^  TrajectoryPlannerROS::TrajectoryPlannerROS() :$/;"	f	class:base_local_planner::TrajectoryPlannerROS
TrajectoryPlannerROS	base_local_planner/src/trajectory_planner_ros.cpp	/^  TrajectoryPlannerROS::TrajectoryPlannerROS(std::string name, tf2_ros::Buffer* tf, costmap_2d::Costmap2DROS* costmap_ros) :$/;"	f	class:base_local_planner::TrajectoryPlannerROS
TrajectoryPlannerTest	base_local_planner/test/utest.cpp	/^TrajectoryPlannerTest::TrajectoryPlannerTest(MapGrid* g, WavefrontMapAccessor* wave, const costmap_2d::Costmap2D& map, std::vector<geometry_msgs::Point> footprint_spec)$/;"	f	class:base_local_planner::TrajectoryPlannerTest
TrajectoryPlannerTest	base_local_planner/test/utest.cpp	/^class TrajectoryPlannerTest : public testing::Test {$/;"	c	namespace:base_local_planner	file:
TrajectorySampleGenerator	base_local_planner/include/base_local_planner/trajectory_sample_generator.h	/^  TrajectorySampleGenerator() {}$/;"	f	class:base_local_planner::TrajectorySampleGenerator
TrajectorySampleGenerator	base_local_planner/include/base_local_planner/trajectory_sample_generator.h	/^class TrajectorySampleGenerator {$/;"	c	namespace:base_local_planner
TrajectorySearch	base_local_planner/include/base_local_planner/trajectory_search.h	/^  TrajectorySearch() {}$/;"	f	class:base_local_planner::TrajectorySearch
TrajectorySearch	base_local_planner/include/base_local_planner/trajectory_search.h	/^class TrajectorySearch {$/;"	c	namespace:base_local_planner
TwirlingCostFunction	base_local_planner/include/base_local_planner/twirling_cost_function.h	/^  TwirlingCostFunction() {}$/;"	f	class:base_local_planner::TwirlingCostFunction
TwirlingCostFunction	base_local_planner/include/base_local_planner/twirling_cost_function.h	/^class TwirlingCostFunction: public base_local_planner::TrajectoryCostFunction {$/;"	c	namespace:base_local_planner
UNKNOWN	voxel_grid/include/voxel_grid/voxel_grid.h	/^  UNKNOWN = 1,$/;"	e	enum:voxel_grid::VoxelStatus
USAGE	amcl/src/amcl_node.cpp	298;"	d	file:
USAGE	map_server/src/main.cpp	32;"	d	file:
USAGE	map_server/src/map_saver.cpp	132;"	d	file:
UpdateAction	amcl/src/amcl/sensors/amcl_odom.cpp	/^bool AMCLOdom::UpdateAction(pf_t *pf, AMCLSensorData *data)$/;"	f	class:AMCLOdom
UpdateAction	amcl/src/amcl/sensors/amcl_sensor.cpp	/^bool AMCLSensor::UpdateAction(pf_t *pf, AMCLSensorData *data)$/;"	f	class:AMCLSensor
UpdateGUI	amcl/src/amcl/sensors/amcl_sensor.cpp	/^void AMCLSensor::UpdateGUI(rtk_canvas_t *canvas, rtk_fig_t *robot_fig, AMCLSensorData *data)$/;"	f	class:AMCLSensor
UpdateSensor	amcl/src/amcl/sensors/amcl_laser.cpp	/^bool AMCLLaser::UpdateSensor(pf_t *pf, AMCLSensorData *data)$/;"	f	class:AMCLLaser
UpdateSensor	amcl/src/amcl/sensors/amcl_sensor.cpp	/^bool AMCLSensor::UpdateSensor(pf_t *pf, AMCLSensorData *data)$/;"	f	class:AMCLSensor
VARIABLE	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^    VARIABLE,$/;"	e	enum:range_sensor_layer::RangeSensorLayer::InputSensorType
VOXEL_BITS	costmap_2d/plugins/voxel_layer.cpp	42;"	d	file:
VOXEL_GRID_VOXEL_GRID_H	voxel_grid/include/voxel_grid/voxel_grid.h	38;"	d
V_Cell	costmap_2d/src/costmap_2d_cloud.cpp	/^typedef std::vector<Cell> V_Cell;$/;"	t	file:
V_Cell	costmap_2d/src/costmap_2d_markers.cpp	/^typedef std::vector<Cell> V_Cell;$/;"	t	file:
VelocityIterator	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      VelocityIterator(double min, double max, int num_samples):$/;"	f	class:base_local_planner::VelocityIterator
VelocityIterator	base_local_planner/include/base_local_planner/velocity_iterator.h	/^  class VelocityIterator {$/;"	c	namespace:base_local_planner
VoxelGrid	voxel_grid/include/voxel_grid/voxel_grid.h	/^class VoxelGrid$/;"	c	namespace:voxel_grid
VoxelGrid	voxel_grid/src/voxel_grid.cpp	/^  VoxelGrid::VoxelGrid(unsigned int size_x, unsigned int size_y, unsigned int size_z)$/;"	f	class:voxel_grid::VoxelGrid
VoxelGridModel	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^  class VoxelGridModel : public WorldModel {$/;"	c	namespace:base_local_planner
VoxelGridModel	base_local_planner/src/voxel_grid_model.cpp	/^  VoxelGridModel::VoxelGridModel(double size_x, double size_y, double size_z, double xy_resolution, double z_resolution,$/;"	f	class:base_local_planner::VoxelGridModel
VoxelLayer	costmap_2d/include/costmap_2d/voxel_layer.h	/^  VoxelLayer() :$/;"	f	class:costmap_2d::VoxelLayer
VoxelLayer	costmap_2d/include/costmap_2d/voxel_layer.h	/^class VoxelLayer : public ObstacleLayer$/;"	c	namespace:costmap_2d
VoxelStatus	voxel_grid/include/voxel_grid/voxel_grid.h	/^enum VoxelStatus {$/;"	g	namespace:voxel_grid
WAVEFRONT_MAP_ACCESSOR_H_	base_local_planner/test/wavefront_map_accessor.h	9;"	d
WavefrontMapAccessor	base_local_planner/test/wavefront_map_accessor.h	/^    WavefrontMapAccessor(MapGrid* map, double outer_radius)$/;"	f	class:base_local_planner::WavefrontMapAccessor
WavefrontMapAccessor	base_local_planner/test/wavefront_map_accessor.h	/^class WavefrontMapAccessor : public costmap_2d::Costmap2D {$/;"	c	namespace:base_local_planner
WorldModel	base_local_planner/include/base_local_planner/world_model.h	/^            WorldModel(){}$/;"	f	class:base_local_planner::WorldModel
WorldModel	base_local_planner/include/base_local_planner/world_model.h	/^    class WorldModel{$/;"	c	namespace:base_local_planner
ZOffset	voxel_grid/include/voxel_grid/voxel_grid.h	/^    ZOffset(unsigned int &z_mask) : z_mask_(z_mask) {}$/;"	f	class:voxel_grid::VoxelGrid::ZOffset
ZOffset	voxel_grid/include/voxel_grid/voxel_grid.h	/^  class ZOffset$/;"	c	class:voxel_grid::VoxelGrid
_ASTAR_H	global_planner/include/global_planner/astar.h	39;"	d
_DIJKSTRA_H	global_planner/include/global_planner/dijkstra.h	39;"	d
_EXPANDER_H	global_planner/include/global_planner/expander.h	39;"	d
_GRADIENT_PATH_H	global_planner/include/global_planner/gradient_path.h	39;"	d
_GRID_PATH_H	global_planner/include/global_planner/grid_path.h	39;"	d
_NAVFN_H	navfn/include/navfn/navfn.h	42;"	d
_PLANNERCORE_H	global_planner/include/global_planner/planner_core.h	2;"	d
_POTENTIAL_CALCULATOR_H	global_planner/include/global_planner/potential_calculator.h	39;"	d
_QUADRATIC_CALCULATOR_H	global_planner/include/global_planner/quadratic_calculator.h	39;"	d
_TRACEBACK_H	global_planner/include/global_planner/traceback.h	39;"	d
__base_local_planner__LOCALPLANNERLIMITS_H__	base_local_planner/include/base_local_planner/local_planner_limits.h	37;"	d
__init__	amcl/test/set_pose.py	/^    def __init__(self, pose, stamp, publish_time):$/;"	m	class:PoseSetter
__init__	map_server/test/consumer.py	/^    def __init__(self, *args):$/;"	m	class:TestConsumer
_pf_sample_set_t	amcl/include/amcl/pf/pf.h	/^typedef struct _pf_sample_set_t$/;"	s
_pf_t	amcl/include/amcl/pf/pf.h	/^typedef struct _pf_t$/;"	s
a_thresh_	amcl/src/amcl_node.cpp	/^    double d_thresh_, a_thresh_;$/;"	m	class:AmclNode	file:
acc_lim_th_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  double sim_granularity_, min_rotational_vel_, max_rotational_vel_, acc_lim_th_, tolerance_, frequency_;$/;"	m	class:rotate_recovery::RotateRecovery
acc_lim_theta	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double acc_lim_theta;$/;"	m	class:base_local_planner::LocalPlannerLimits
acc_lim_theta_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double acc_lim_x_, acc_lim_y_, acc_lim_theta_; \/\/\/< @brief The acceleration limits of the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
acc_lim_theta_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double acc_lim_x_, acc_lim_y_, acc_lim_theta_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
acc_lim_trans	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double acc_lim_trans;$/;"	m	class:base_local_planner::LocalPlannerLimits
acc_lim_x	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double acc_lim_x;$/;"	m	class:base_local_planner::LocalPlannerLimits
acc_lim_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double acc_lim_x_, acc_lim_y_, acc_lim_theta_; \/\/\/< @brief The acceleration limits of the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
acc_lim_x_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double acc_lim_x_, acc_lim_y_, acc_lim_theta_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
acc_lim_y	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double acc_lim_y;$/;"	m	class:base_local_planner::LocalPlannerLimits
acc_lim_y_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double acc_lim_x_, acc_lim_y_, acc_lim_theta_; \/\/\/< @brief The acceleration limits of the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
acc_lim_y_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double acc_lim_x_, acc_lim_y_, acc_lim_theta_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
access_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  mutex_t* access_;$/;"	m	class:costmap_2d::Costmap2D
action_goal_pub_	move_base/include/move_base/move_base.h	/^      ros::Publisher current_goal_pub_, vel_pub_, action_goal_pub_;$/;"	m	class:move_base::MoveBase
activate	costmap_2d/include/costmap_2d/layer.h	/^  virtual void activate() {}$/;"	f	class:costmap_2d::Layer
activate	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::activate()$/;"	f	class:costmap_2d::ObstacleLayer
activate	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::activate()$/;"	f	class:range_sensor_layer::RangeSensorLayer
activate	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::activate()$/;"	f	class:costmap_2d::StaticLayer
active	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  bool active()$/;"	f	class:costmap_2d::Costmap2DPublisher
active_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  bool active_;$/;"	m	class:costmap_2d::Costmap2DPublisher
add	global_planner/src/astar.cpp	/^void AStarExpansion::add(unsigned char* costs, float* potential, float prev_potential, int next_i, int end_x,$/;"	f	class:global_planner::AStarExpansion
addExtraBounds	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::addExtraBounds(double mx0, double my0, double mx1, double my1)$/;"	f	class:costmap_2d::CostmapLayer
addInflationLayer	costmap_2d/include/costmap_2d/testing_helper.h	/^costmap_2d::InflationLayer* addInflationLayer(costmap_2d::LayeredCostmap& layers, tf2_ros::Buffer& tf)$/;"	f
addObservation	costmap_2d/include/costmap_2d/testing_helper.h	/^void addObservation(costmap_2d::ObstacleLayer* olayer, double x, double y, double z = 0.0,$/;"	f
addObstacleLayer	costmap_2d/include/costmap_2d/testing_helper.h	/^costmap_2d::ObstacleLayer* addObstacleLayer(costmap_2d::LayeredCostmap& layers, tf2_ros::Buffer& tf)$/;"	f
addPlugin	costmap_2d/include/costmap_2d/layered_costmap.h	/^  void addPlugin(boost::shared_ptr<Layer> plugin)$/;"	f	class:costmap_2d::LayeredCostmap
addPoint	base_local_planner/src/trajectory.cpp	/^  void Trajectory::addPoint(double x, double y, double th){$/;"	f	class:base_local_planner::Trajectory
addStaticLayer	costmap_2d/include/costmap_2d/testing_helper.h	/^void addStaticLayer(costmap_2d::LayeredCostmap& layers, tf2_ros::Buffer& tf)$/;"	f
addStaticObservation	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::addStaticObservation(costmap_2d::Observation& obs, bool marking, bool clearing)$/;"	f	class:costmap_2d::ObstacleLayer
add_generic_localplanner_params	base_local_planner/src/local_planner_limits/__init__.py	/^def add_generic_localplanner_params(gen):$/;"	f
adjustPlanResolution	base_local_planner/src/map_grid.cpp	/^  void MapGrid::adjustPlanResolution(const std::vector<geometry_msgs::PoseStamped>& global_plan_in,$/;"	f	class:base_local_planner::MapGrid
advance	base_local_planner/include/base_local_planner/line_iterator.h	/^  void advance()$/;"	f	class:base_local_planner::LineIterator
affected_maps_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      std::string affected_maps_; \/\/\/< clear only local, global or both costmaps$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
aggregationType_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  CostAggregationType aggregationType_;$/;"	m	class:base_local_planner::MapGridCostFunction
alignment_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::MapGridCostFunction alignment_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
allow_unknown_	global_planner/include/global_planner/planner_core.h	/^        bool initialized_, allow_unknown_;$/;"	m	class:global_planner::GlobalPlanner
allow_unknown_	navfn/include/navfn/navfn_ros.h	/^      bool initialized_, allow_unknown_, visualize_potential_;$/;"	m	class:navfn::NavfnROS
alpha1	amcl/include/amcl/sensors/amcl_odom.h	/^  private: double alpha1, alpha2, alpha3, alpha4, alpha5;$/;"	m	class:amcl::AMCLOdom
alpha1_	amcl/src/amcl_node.cpp	/^    double alpha1_, alpha2_, alpha3_, alpha4_, alpha5_;$/;"	m	class:AmclNode	file:
alpha2	amcl/include/amcl/sensors/amcl_odom.h	/^  private: double alpha1, alpha2, alpha3, alpha4, alpha5;$/;"	m	class:amcl::AMCLOdom
alpha2_	amcl/src/amcl_node.cpp	/^    double alpha1_, alpha2_, alpha3_, alpha4_, alpha5_;$/;"	m	class:AmclNode	file:
alpha3	amcl/include/amcl/sensors/amcl_odom.h	/^  private: double alpha1, alpha2, alpha3, alpha4, alpha5;$/;"	m	class:amcl::AMCLOdom
alpha3_	amcl/src/amcl_node.cpp	/^    double alpha1_, alpha2_, alpha3_, alpha4_, alpha5_;$/;"	m	class:AmclNode	file:
alpha4	amcl/include/amcl/sensors/amcl_odom.h	/^  private: double alpha1, alpha2, alpha3, alpha4, alpha5;$/;"	m	class:amcl::AMCLOdom
alpha4_	amcl/src/amcl_node.cpp	/^    double alpha1_, alpha2_, alpha3_, alpha4_, alpha5_;$/;"	m	class:AmclNode	file:
alpha5	amcl/include/amcl/sensors/amcl_odom.h	/^  private: double alpha1, alpha2, alpha3, alpha4, alpha5;$/;"	m	class:amcl::AMCLOdom
alpha5_	amcl/src/amcl_node.cpp	/^    double alpha1_, alpha2_, alpha3_, alpha4_, alpha5_;$/;"	m	class:AmclNode	file:
alpha_fast	amcl/include/amcl/pf/pf.h	/^  double alpha_slow, alpha_fast;$/;"	m	struct:_pf_t
alpha_fast_	amcl/src/amcl_node.cpp	/^    double alpha_slow_, alpha_fast_;$/;"	m	class:AmclNode	file:
alpha_slow	amcl/include/amcl/pf/pf.h	/^  double alpha_slow, alpha_fast;$/;"	m	struct:_pf_t
alpha_slow_	amcl/src/amcl_node.cpp	/^    double alpha_slow_, alpha_fast_;$/;"	m	class:AmclNode	file:
always_send_full_costmap_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  bool always_send_full_costmap_;$/;"	m	class:costmap_2d::Costmap2DPublisher
amcl	amcl/include/amcl/sensors/amcl_laser.h	/^namespace amcl$/;"	n
amcl	amcl/include/amcl/sensors/amcl_odom.h	/^namespace amcl$/;"	n
amcl	amcl/include/amcl/sensors/amcl_sensor.h	/^namespace amcl$/;"	n
amcl_hyp_t	amcl/src/amcl_node.cpp	/^} amcl_hyp_t;$/;"	t	typeref:struct:__anon11	file:
amcl_node_ptr	amcl/src/amcl_node.cpp	/^boost::shared_ptr<AmclNode> amcl_node_ptr;$/;"	v
angle_diff	amcl/src/amcl/sensors/amcl_odom.cpp	/^angle_diff(double a, double b)$/;"	f	file:
angle_diff	amcl/src/amcl_node.cpp	/^angle_diff(double a, double b)$/;"	f	file:
angle_increment	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^      double angle_min, angle_max, angle_increment;$/;"	m	class:base_local_planner::PlanarLaserScan
angle_max	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^      double angle_min, angle_max, angle_increment;$/;"	m	class:base_local_planner::PlanarLaserScan
angle_min	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^      double angle_min, angle_max, angle_increment;$/;"	m	class:base_local_planner::PlanarLaserScan
angular_sim_granularity_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  double sim_time_, sim_granularity_, angular_sim_granularity_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
angular_sim_granularity_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double angular_sim_granularity_; \/\/\/< @brief The distance between angular simulation points$/;"	m	class:base_local_planner::TrajectoryPlanner
applyInitialPose	amcl/src/amcl_node.cpp	/^AmclNode::applyInitialPose()$/;"	f	class:AmclNode
area	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  float area(int x1, int y1, int x2, int y2, int x3, int y3)$/;"	f	class:range_sensor_layer::RangeSensorLayer
as_	move_base/include/move_base/move_base.h	/^      MoveBaseActionServer* as_;$/;"	m	class:move_base::MoveBase
backup_vel_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double backup_vel_; \/\/\/< @brief The velocity to use while backing up$/;"	m	class:base_local_planner::TrajectoryPlanner
bag_scan_period_	amcl/src/amcl_node.cpp	/^    ros::WallDuration bag_scan_period_;$/;"	m	class:AmclNode	file:
base_frame_id_	amcl/src/amcl_node.cpp	/^    std::string base_frame_id_;$/;"	m	class:AmclNode	file:
base_frame_id_	fake_localization/fake_localization.cpp	/^    std::string base_frame_id_;$/;"	m	class:FakeOdomNode	file:
base_local_planner	base_local_planner/include/base_local_planner/costmap_model.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/footprint_helper.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/goal_functions.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/line_iterator.h	/^namespace base_local_planner$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/local_planner_limits.h	/^namespace base_local_planner$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/local_planner_util.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/map_cell.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/map_grid.h	/^namespace base_local_planner{$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/point_grid.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/trajectory.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/trajectory_planner.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/trajectory_sample_generator.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/trajectory_search.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/twirling_cost_function.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/velocity_iterator.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/include/base_local_planner/world_model.h	/^namespace base_local_planner {$/;"	n
base_local_planner	base_local_planner/src/costmap_model.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/footprint_helper.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/goal_functions.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/latched_stop_rotate_controller.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/local_planner_util.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/map_cell.cpp	/^namespace base_local_planner{$/;"	n	file:
base_local_planner	base_local_planner/src/map_grid.cpp	/^namespace base_local_planner{$/;"	n	file:
base_local_planner	base_local_planner/src/map_grid_cost_function.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/map_grid_visualizer.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/obstacle_cost_function.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/odometry_helper_ros.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/oscillation_cost_function.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/point_grid.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/prefer_forward_cost_function.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/simple_scored_sampling_planner.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/simple_trajectory_generator.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/trajectory.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/trajectory_planner.cpp	/^namespace base_local_planner{$/;"	n	file:
base_local_planner	base_local_planner/src/trajectory_planner_ros.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/twirling_cost_function.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/src/voxel_grid_model.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/test/footprint_helper_test.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/test/map_grid_test.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/test/trajectory_generator_test.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/test/utest.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/test/velocity_iterator_test.cpp	/^namespace base_local_planner {$/;"	n	file:
base_local_planner	base_local_planner/test/wavefront_map_accessor.h	/^namespace base_local_planner {$/;"	n
base_odom_	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  nav_msgs::Odometry base_odom_;$/;"	m	class:base_local_planner::OdometryHelperRos
base_odom_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      nav_msgs::Odometry base_odom_; \/\/\/< @brief Used to get the velocity of the robot$/;"	m	class:base_local_planner::TrajectoryPlannerROS
beam_skip_distance	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double beam_skip_distance; $/;"	m	class:amcl::AMCLLaser
beam_skip_distance_	amcl/src/amcl_node.cpp	/^    double beam_skip_distance_, beam_skip_threshold_, beam_skip_error_threshold_;$/;"	m	class:AmclNode	file:
beam_skip_error_threshold	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double beam_skip_error_threshold;$/;"	m	class:amcl::AMCLLaser
beam_skip_error_threshold_	amcl/src/amcl_node.cpp	/^    double beam_skip_distance_, beam_skip_threshold_, beam_skip_error_threshold_;$/;"	m	class:AmclNode	file:
beam_skip_threshold	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double beam_skip_threshold; $/;"	m	class:amcl::AMCLLaser
beam_skip_threshold_	amcl/src/amcl_node.cpp	/^    double beam_skip_distance_, beam_skip_threshold_, beam_skip_error_threshold_;$/;"	m	class:AmclNode	file:
bgp_loader_	move_base/include/move_base/move_base.h	/^      pluginlib::ClassLoader<nav_core::BaseGlobalPlanner> bgp_loader_;$/;"	m	class:move_base::MoveBase
bitsBelowThreshold	voxel_grid/include/voxel_grid/voxel_grid.h	/^    inline bool bitsBelowThreshold(unsigned int n, unsigned int bit_threshold)$/;"	f	class:voxel_grid::VoxelGrid::ClearVoxelInMap
bitsBelowThreshold	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline bool bitsBelowThreshold(unsigned int n, unsigned int bit_threshold)$/;"	f	class:voxel_grid::VoxelGrid
blp_loader_	move_base/include/move_base/move_base.h	/^      pluginlib::ClassLoader<nav_core::BaseLocalPlanner> blp_loader_;$/;"	m	class:move_base::MoveBase
bounds	map_server/scripts/crop_map	/^    bounds = find_bounds(map_image)$/;"	v
bresenham2D	costmap_2d/include/costmap_2d/costmap_2d.h	/^    inline void bresenham2D(ActionType at, unsigned int abs_da, unsigned int abs_db, int error_b, int offset_a,$/;"	f	class:costmap_2d::Costmap2D
bresenham3D	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline void bresenham3D($/;"	f	class:voxel_grid::VoxelGrid
buffer1_	global_planner/include/global_planner/dijkstra.h	/^        int *buffer1_, *buffer2_, *buffer3_; \/**< storage buffers for priority blocks *\/$/;"	m	class:global_planner::DijkstraExpansion
buffer2_	global_planner/include/global_planner/dijkstra.h	/^        int *buffer1_, *buffer2_, *buffer3_; \/**< storage buffers for priority blocks *\/$/;"	m	class:global_planner::DijkstraExpansion
buffer3_	global_planner/include/global_planner/dijkstra.h	/^        int *buffer1_, *buffer2_, *buffer3_; \/**< storage buffers for priority blocks *\/$/;"	m	class:global_planner::DijkstraExpansion
bufferCloud	costmap_2d/src/observation_buffer.cpp	/^void ObservationBuffer::bufferCloud(const sensor_msgs::PointCloud2& cloud)$/;"	f	class:costmap_2d::ObservationBuffer
bufferIncomingRangeMsg	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::bufferIncomingRangeMsg(const sensor_msgs::RangeConstPtr& range_message)$/;"	f	class:range_sensor_layer::RangeSensorLayer
buffered_readings_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  unsigned int buffered_readings_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
bx0_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  unsigned int bx0_, bxn_, by0_, byn_;$/;"	m	class:costmap_2d::LayeredCostmap
bxn_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  unsigned int bx0_, bxn_, by0_, byn_;$/;"	m	class:costmap_2d::LayeredCostmap
by0_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  unsigned int bx0_, bxn_, by0_, byn_;$/;"	m	class:costmap_2d::LayeredCostmap
byn_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  unsigned int bx0_, bxn_, by0_, byn_;$/;"	m	class:costmap_2d::LayeredCostmap
c	amcl/include/amcl/pf/pf.h	/^  double m[4], c[2][2];$/;"	m	struct:__anon4
c_freq_change_	move_base/include/move_base/move_base.h	/^      bool setup_, p_freq_change_, c_freq_change_;$/;"	m	class:move_base::MoveBase
cached_cell_inflation_radius_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int cached_cell_inflation_radius_;$/;"	m	class:costmap_2d::InflationLayer
cached_costs_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned char** cached_costs_;$/;"	m	class:costmap_2d::InflationLayer
cached_distances_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double** cached_distances_;$/;"	m	class:costmap_2d::InflationLayer
calcNavFnAstar	navfn/src/navfn.cpp	/^    NavFn::calcNavFnAstar()$/;"	f	class:navfn::NavFn
calcNavFnDijkstra	navfn/src/navfn.cpp	/^    NavFn::calcNavFnDijkstra(bool atStart)$/;"	f	class:navfn::NavFn
calcPath	navfn/src/navfn.cpp	/^    NavFn::calcPath(int n, int *st)$/;"	f	class:navfn::NavFn
calculateMinAndMaxDistances	costmap_2d/src/footprint.cpp	/^void calculateMinAndMaxDistances(const std::vector<geometry_msgs::Point>& footprint, double& min_dist, double& max_dist)$/;"	f	namespace:costmap_2d
calculatePotential	global_planner/include/global_planner/potential_calculator.h	/^        virtual float calculatePotential(float* potential, unsigned char cost, int n, float prev_potential=-1){$/;"	f	class:global_planner::PotentialCalculator
calculatePotential	global_planner/src/quadratic_calculator.cpp	/^float QuadraticCalculator::calculatePotential(float* potential, unsigned char cost, int n, float prev_potential) {$/;"	f	class:global_planner::QuadraticCalculator
calculatePotentials	global_planner/src/astar.cpp	/^bool AStarExpansion::calculatePotentials(unsigned char* costs, double start_x, double start_y, double end_x, double end_y,$/;"	f	class:global_planner::AStarExpansion
calculatePotentials	global_planner/src/dijkstra.cpp	/^bool DijkstraExpansion::calculatePotentials(unsigned char* costs, double start_x, double start_y, double end_x, double end_y,$/;"	f	class:global_planner::DijkstraExpansion
callback	map_server/test/consumer.py	/^    def callback(self, data):$/;"	m	class:TestConsumer
carrot_planner	carrot_planner/include/carrot_planner/carrot_planner.h	/^namespace carrot_planner{$/;"	n
carrot_planner	carrot_planner/src/carrot_planner.cpp	/^namespace carrot_planner {$/;"	n	file:
cd	amcl/include/amcl/pf/pf_pdf.h	/^  pf_vector_t cd;$/;"	m	struct:__anon7
cellDistance	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int cellDistance(double world_dist)$/;"	f	class:costmap_2d::InflationLayer
cellDistance	costmap_2d/src/costmap_2d.cpp	/^    unsigned int Costmap2D::cellDistance(double world_dist)$/;"	f	class:costmap_2d::Costmap2D
cell_inflation_radius_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int cell_inflation_radius_;$/;"	m	class:costmap_2d::InflationLayer
cell_radius_	amcl/src/amcl/map/map_cspace.cpp	/^    int cell_radius_;$/;"	m	class:CachedDistanceMap	file:
cells	amcl/include/amcl/map/map.h	/^  map_cell_t *cells;$/;"	m	struct:__anon2
cells_	base_local_planner/include/base_local_planner/point_grid.h	/^      std::vector< std::list<geometry_msgs::Point32> > cells_; \/\/\/< @brief Storage for the cells in the grid$/;"	m	class:base_local_planner::PointGrid
cells_	costmap_2d/include/costmap_2d/costmap_2d.h	/^    std::vector<MapLocation>& cells_;$/;"	m	class:costmap_2d::Costmap2D::PolygonOutlineCells
cells_visited_	global_planner/include/global_planner/expander.h	/^        int cells_visited_;$/;"	m	class:global_planner::Expander
char_map_	costmap_2d/include/costmap_2d/costmap_2d.h	/^    const unsigned char* char_map_;$/;"	m	class:costmap_2d::Costmap2D::PolygonOutlineCells
cheat_factor_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double cheat_factor_;$/;"	m	class:dwa_local_planner::DWAPlanner
checkConsistentCosts	costmap_2d/test/costmap_tester.cpp	/^void CostmapTester::checkConsistentCosts(){$/;"	f	class:costmap_2d::CostmapTester
checkGoalDistance	base_local_planner/test/utest.cpp	/^void TrajectoryPlannerTest::checkGoalDistance(){$/;"	f	class:base_local_planner::TrajectoryPlannerTest
checkLaserReceived	amcl/src/amcl_node.cpp	/^AmclNode::checkLaserReceived(const ros::TimerEvent& event)$/;"	f	class:AmclNode
checkOldParam	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::checkOldParam(ros::NodeHandle& nh, const std::string &param_name){$/;"	f	class:costmap_2d::Costmap2DROS
checkPathDistance	base_local_planner/test/utest.cpp	/^void TrajectoryPlannerTest::checkPathDistance(){$/;"	f	class:base_local_planner::TrajectoryPlannerTest
checkTrajectory	base_local_planner/src/trajectory_planner.cpp	/^  bool TrajectoryPlanner::checkTrajectory(double x, double y, double theta, double vx, double vy,$/;"	f	class:base_local_planner::TrajectoryPlanner
checkTrajectory	base_local_planner/src/trajectory_planner_ros.cpp	/^  bool TrajectoryPlannerROS::checkTrajectory(double vx_samp, double vy_samp, double vtheta_samp, bool update_map){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
checkTrajectory	dwa_local_planner/src/dwa_planner.cpp	/^  bool DWAPlanner::checkTrajectory($/;"	f	class:dwa_local_planner::DWAPlanner
check_laser_timer_	amcl/src/amcl_node.cpp	/^    ros::Timer check_laser_timer_;$/;"	m	class:AmclNode	file:
chi_outlier	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double chi_outlier;$/;"	m	class:amcl::AMCLLaser
children	amcl/include/amcl/pf/pf_kdtree.h	/^  struct pf_kdtree_node *children[2];$/;"	m	struct:pf_kdtree_node	typeref:struct:pf_kdtree_node::pf_kdtree_node
circumscribed_radius_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double inscribed_radius_, circumscribed_radius_;$/;"	m	class:base_local_planner::TrajectoryPlanner
circumscribed_radius_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double circumscribed_radius_, inscribed_radius_;$/;"	m	class:costmap_2d::LayeredCostmap
circumscribed_radius_	move_base/include/move_base/move_base.h	/^      double planner_frequency_, controller_frequency_, inscribed_radius_, circumscribed_radius_;$/;"	m	class:move_base::MoveBase
clear	clear_costmap_recovery/src/clear_costmap_recovery.cpp	/^            void ClearCostmapRecovery::clear(costmap_2d::Costmap2DROS* costmap){$/;"	f	class:clear_costmap_recovery::ClearCostmapRecovery
clearArea	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::clearArea(int start_x, int start_y, int end_x, int end_y, bool invert_area)$/;"	f	class:costmap_2d::CostmapLayer
clearCostmapWindows	move_base/src/move_base.cpp	/^    void MoveBase::clearCostmapWindows(double size_x, double size_y){$/;"	f	class:move_base::MoveBase
clearCostmapsService	move_base/src/move_base.cpp	/^    bool MoveBase::clearCostmapsService(std_srvs::Empty::Request &req, std_srvs::Empty::Response &resp){$/;"	f	class:move_base::MoveBase
clearEndpoint	global_planner/include/global_planner/expander.h	/^        void clearEndpoint(unsigned char* costs, float* potential, int gx, int gy, int s){$/;"	f	class:global_planner::Expander
clearMap	clear_costmap_recovery/src/clear_costmap_recovery.cpp	/^            void ClearCostmapRecovery::clearMap(boost::shared_ptr<costmap_2d::CostmapLayer> costmap,$/;"	f	class:clear_costmap_recovery::ClearCostmapRecovery
clearNonLethal	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::clearNonLethal(double wx, double wy, double w_size_x, double w_size_y, bool clear_no_info)$/;"	f	class:costmap_2d::VoxelLayer
clearRobotCell	global_planner/src/planner_core.cpp	/^void GlobalPlanner::clearRobotCell(const geometry_msgs::PoseStamped& global_pose, unsigned int mx, unsigned int my) {$/;"	f	class:global_planner::GlobalPlanner
clearRobotCell	navfn/src/navfn_ros.cpp	/^  void NavfnROS::clearRobotCell(const geometry_msgs::PoseStamped& global_pose, unsigned int mx, unsigned int my){$/;"	f	class:navfn::NavfnROS
clearStaticObservations	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::clearStaticObservations(bool marking, bool clearing)$/;"	f	class:costmap_2d::ObstacleLayer
clearVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline void clearVoxel(unsigned int x, unsigned int y, unsigned int z)$/;"	f	class:voxel_grid::VoxelGrid
clearVoxelColumn	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline void clearVoxelColumn(unsigned int index)$/;"	f	class:voxel_grid::VoxelGrid
clearVoxelInMap	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline void clearVoxelInMap(unsigned int x, unsigned int y, unsigned int z)$/;"	f	class:voxel_grid::VoxelGrid
clearVoxelLine	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::clearVoxelLine(double x0, double y0, double z0, double x1, double y1, double z1, unsigned int max_length){$/;"	f	class:voxel_grid::VoxelGrid
clearVoxelLineInMap	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::clearVoxelLineInMap(double x0, double y0, double z0, double x1, double y1, double z1, unsigned char *map_2d, $/;"	f	class:voxel_grid::VoxelGrid
clear_costmap_recovery	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^namespace clear_costmap_recovery{$/;"	n
clear_costmap_recovery	clear_costmap_recovery/src/clear_costmap_recovery.cpp	/^        namespace clear_costmap_recovery {$/;"	n	file:
clear_costmaps_srv_	move_base/include/move_base/move_base.h	/^      ros::ServiceServer make_plan_srv_, clear_costmaps_srv_;$/;"	m	class:move_base::MoveBase
clear_on_max_reading_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  bool clear_on_max_reading_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
clear_threshold_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double clear_threshold_, mark_threshold_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
clearable_layers_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      std::set<std::string> clearable_layers_; \/\/\/< Layer names which will be cleared.$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
clearing_buffers_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<boost::shared_ptr<costmap_2d::ObservationBuffer> > clearing_buffers_;  \/\/\/< @brief Used to store observation buffers used for clearing obstacles$/;"	m	class:costmap_2d::ObstacleLayer
clearing_distance_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      double clearing_distance_, limited_distance_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
clearing_endpoints_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  sensor_msgs::PointCloud clearing_endpoints_;$/;"	m	class:costmap_2d::VoxelLayer
clearing_endpoints_pub_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  ros::Publisher clearing_endpoints_pub_;$/;"	m	class:costmap_2d::VoxelLayer
clearing_radius_	move_base/include/move_base/move_base.h	/^      double conservative_reset_dist_, clearing_radius_;$/;"	m	class:move_base::MoveBase
clearing_rotation_allowed_	move_base/include/move_base/move_base.h	/^      bool shutdown_costmaps_, clearing_rotation_allowed_, recovery_behavior_enabled_;$/;"	m	class:move_base::MoveBase
cloud	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^      sensor_msgs::PointCloud cloud;$/;"	m	class:base_local_planner::PlanarLaserScan
cloud_	costmap_2d/include/costmap_2d/observation.h	/^  sensor_msgs::PointCloud2* cloud_;$/;"	m	class:costmap_2d::Observation
cloud_pub_interval	amcl/src/amcl_node.cpp	/^    ros::Duration cloud_pub_interval;$/;"	m	class:AmclNode	file:
cluster	amcl/include/amcl/pf/pf_kdtree.h	/^  int cluster;$/;"	m	struct:pf_kdtree_node
cluster_count	amcl/include/amcl/pf/pf.h	/^  int cluster_count, cluster_max_count;$/;"	m	struct:_pf_sample_set_t
cluster_max_count	amcl/include/amcl/pf/pf.h	/^  int cluster_count, cluster_max_count;$/;"	m	struct:_pf_sample_set_t
clusters	amcl/include/amcl/pf/pf.h	/^  pf_cluster_t *clusters;$/;"	m	struct:_pf_sample_set_t
cm	base_local_planner/test/utest.cpp	/^    CostmapModel cm;$/;"	m	class:base_local_planner::TrajectoryPlannerTest	file:
cmap_	global_planner/src/plan_node.cpp	/^        Costmap2DROS* cmap_;$/;"	m	class:global_planner::PlannerWithCostmap	file:
cmap_	navfn/src/navfn_node.cpp	/^  Costmap2DROS* cmap_;$/;"	m	class:navfn::NavfnWithCostmap	file:
combination_method_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  int combination_method_;$/;"	m	class:costmap_2d::ObstacleLayer
combo_enum	costmap_2d/cfg/ObstaclePlugin.cfg	/^combo_enum = gen.enum([gen.const("Overwrite", int_t,  0, "Overwrite values"),$/;"	v
combo_enum	costmap_2d/cfg/VoxelPlugin.cfg	/^combo_enum = gen.enum([gen.const("Overwrite", int_t,  0, "Overwrite values"),$/;"	v
commonInit	base_local_planner/src/map_grid.cpp	/^  void MapGrid::commonInit(){$/;"	f	class:base_local_planner::MapGrid
compareCellToNeighbors	costmap_2d/test/costmap_tester.cpp	/^void CostmapTester::compareCellToNeighbors(costmap_2d::Costmap2D& costmap, unsigned int x, unsigned int y){$/;"	f	class:costmap_2d::CostmapTester
compareCells	costmap_2d/test/costmap_tester.cpp	/^void CostmapTester::compareCells(costmap_2d::Costmap2D& costmap, unsigned int x, unsigned int y, unsigned int nx, unsigned int ny){$/;"	f	class:costmap_2d::CostmapTester
computeCaches	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::computeCaches()$/;"	f	class:costmap_2d::InflationLayer
computeCost	costmap_2d/include/costmap_2d/inflation_layer.h	/^  virtual inline unsigned char computeCost(double distance) const$/;"	f	class:costmap_2d::InflationLayer
computeNewPositions	base_local_planner/src/simple_trajectory_generator.cpp	/^Eigen::Vector3f SimpleTrajectoryGenerator::computeNewPositions(const Eigen::Vector3f& pos,$/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
computeNewThetaPosition	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      inline double computeNewThetaPosition(double thetai, double vth, double dt){$/;"	f	class:base_local_planner::TrajectoryPlanner
computeNewVelocities	base_local_planner/src/simple_trajectory_generator.cpp	/^Eigen::Vector3f SimpleTrajectoryGenerator::computeNewVelocities(const Eigen::Vector3f& sample_target_vel,$/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
computeNewVelocity	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      inline double computeNewVelocity(double vg, double vi, double a_max, double dt){$/;"	f	class:base_local_planner::TrajectoryPlanner
computeNewXPosition	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      inline double computeNewXPosition(double xi, double vx, double vy, double theta, double dt){$/;"	f	class:base_local_planner::TrajectoryPlanner
computeNewYPosition	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      inline double computeNewYPosition(double yi, double vx, double vy, double theta, double dt){$/;"	f	class:base_local_planner::TrajectoryPlanner
computePotential	navfn/src/navfn_ros.cpp	/^  bool NavfnROS::computePotential(const geometry_msgs::Point& world_point){$/;"	f	class:navfn::NavfnROS
computeTargetDistance	base_local_planner/src/map_grid.cpp	/^  void MapGrid::computeTargetDistance(queue<MapCell*>& dist_queue, const costmap_2d::Costmap2D& costmap){$/;"	f	class:base_local_planner::MapGrid
computeVelocityCommands	base_local_planner/src/trajectory_planner_ros.cpp	/^  bool TrajectoryPlannerROS::computeVelocityCommands(geometry_msgs::Twist& cmd_vel){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
computeVelocityCommands	dwa_local_planner/src/dwa_planner_ros.cpp	/^            bool DWAPlannerROS::computeVelocityCommands(geometry_msgs::Twist& cmd_vel) {$/;"	f	class:dwa_local_planner::DWAPlannerROS
computeVelocityCommandsStopRotate	base_local_planner/src/latched_stop_rotate_controller.cpp	/^bool LatchedStopRotateController::computeVelocityCommandsStopRotate(geometry_msgs::Twist& cmd_vel,$/;"	f	class:base_local_planner::LatchedStopRotateController
compute_angle_diff	amcl/test/basic_localization.py	/^    def compute_angle_diff(self):$/;"	m	class:TestBasicLocalization
computed_cropped_origin	map_server/scripts/crop_map	/^def computed_cropped_origin(map_image, bounds, resolution, origin):$/;"	f
configuration_mutex_	amcl/src/amcl_node.cpp	/^    boost::recursive_mutex configuration_mutex_;$/;"	m	class:AmclNode	file:
configuration_mutex_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      boost::mutex configuration_mutex_;$/;"	m	class:base_local_planner::TrajectoryPlanner
configuration_mutex_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  boost::recursive_mutex configuration_mutex_;$/;"	m	class:costmap_2d::Costmap2DROS
configuration_mutex_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      boost::mutex configuration_mutex_;$/;"	m	class:dwa_local_planner::DWAPlanner
configuration_mutex_	move_base/include/move_base/move_base.h	/^      boost::recursive_mutex configuration_mutex_;$/;"	m	class:move_base::MoveBase
conservative_reset_dist_	move_base/include/move_base/move_base.h	/^      double conservative_reset_dist_, clearing_radius_;$/;"	m	class:move_base::MoveBase
continued_acceleration_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  bool continued_acceleration_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
controller_costmap_ros_	move_base/include/move_base/move_base.h	/^      costmap_2d::Costmap2DROS* planner_costmap_ros_, *controller_costmap_ros_;$/;"	m	class:move_base::MoveBase
controller_frequency_	move_base/include/move_base/move_base.h	/^      double planner_frequency_, controller_frequency_, inscribed_radius_, circumscribed_radius_;$/;"	m	class:move_base::MoveBase
controller_patience_	move_base/include/move_base/move_base.h	/^      double planner_patience_, controller_patience_;$/;"	m	class:move_base::MoveBase
controller_plan_	move_base/include/move_base/move_base.h	/^      std::vector<geometry_msgs::PoseStamped>* controller_plan_;$/;"	m	class:move_base::MoveBase
converged	amcl/include/amcl/pf/pf.h	/^  int converged; $/;"	m	struct:_pf_sample_set_t
converged	amcl/include/amcl/pf/pf.h	/^  int converged; $/;"	m	struct:_pf_t
convertMap	amcl/src/amcl_node.cpp	/^AmclNode::convertMap( const nav_msgs::OccupancyGrid& map_msg )$/;"	f	class:AmclNode
convert_offset_	global_planner/include/global_planner/planner_core.h	/^        float convert_offset_;$/;"	m	class:global_planner::GlobalPlanner
convexFillCells	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::convexFillCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)$/;"	f	class:costmap_2d::Costmap2D
copyCostmapWindow	costmap_2d/src/costmap_2d.cpp	/^    bool Costmap2D::copyCostmapWindow(const Costmap2D& map, double win_origin_x, double win_origin_y, double win_size_x,$/;"	f	class:costmap_2d::Costmap2D
copyMapRegion	costmap_2d/include/costmap_2d/costmap_2d.h	/^    void copyMapRegion(data_type* source_map, unsigned int sm_lower_left_x, unsigned int sm_lower_left_y,$/;"	f	class:costmap_2d::Costmap2D
copyParentParameters	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::copyParentParameters(const std::string& plugin_name, const std::string& plugin_type, ros::NodeHandle& nh)$/;"	f	class:costmap_2d::Costmap2DROS
copy_set	amcl/src/amcl/pf/pf.c	/^void copy_set(pf_sample_set_t* set_a, pf_sample_set_t* set_b)$/;"	f
correctFootprint	base_local_planner/test/footprint_helper_test.cpp	/^  void correctFootprint(){$/;"	f	class:base_local_planner::FootprintHelperTest
correctLineCells	base_local_planner/test/footprint_helper_test.cpp	/^  void correctLineCells() {$/;"	f	class:base_local_planner::FootprintHelperTest
cost	global_planner/include/global_planner/astar.h	/^        float cost;$/;"	m	class:global_planner::Index
costLookup	costmap_2d/include/costmap_2d/inflation_layer.h	/^  inline unsigned char costLookup(int mx, int my, int src_x, int src_y)$/;"	f	class:costmap_2d::InflationLayer
cost_	base_local_planner/include/base_local_planner/trajectory.h	/^      double cost_; \/\/\/< @brief The cost\/score of the trajectory$/;"	m	class:base_local_planner::Trajectory
cost_function_	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^            boost::function<bool (int cx, int cy, float &path_cost, float &goal_cost, float &occ_cost, float &total_cost)> cost_function_; \/\/\/< @brief The function to be used to generate the cost components for the output PointCloud$/;"	m	class:base_local_planner::MapGridVisualizer
cost_translation_table_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  static char* cost_translation_table_;  \/\/\/< Translate from 0-255 values in costmap to -1 to 100 values in message.$/;"	m	class:costmap_2d::Costmap2DPublisher
cost_translation_table_	costmap_2d/src/costmap_2d_publisher.cpp	/^    char* Costmap2DPublisher::cost_translation_table_ = NULL;$/;"	m	class:costmap_2d::Costmap2DPublisher	file:
costarr	navfn/include/navfn/navfn.h	/^      COSTTYPE *costarr;		\/**< cost array in 2D configuration space *\/$/;"	m	class:navfn::NavFn
costmap	voxel_grid/include/voxel_grid/voxel_grid.h	/^  unsigned char *costmap;$/;"	m	class:voxel_grid::VoxelGrid
costmap_	base_local_planner/include/base_local_planner/costmap_model.h	/^      const costmap_2d::Costmap2D& costmap_; \/\/\/< @brief Allows access of costmap obstacle information$/;"	m	class:base_local_planner::CostmapModel
costmap_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  costmap_2d::Costmap2D* costmap_;$/;"	m	class:base_local_planner::LocalPlannerUtil
costmap_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  costmap_2d::Costmap2D* costmap_;$/;"	m	class:base_local_planner::MapGridCostFunction
costmap_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  costmap_2d::Costmap2D* costmap_;$/;"	m	class:base_local_planner::ObstacleCostFunction
costmap_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      const costmap_2d::Costmap2D& costmap_; \/\/\/< @brief Provides access to cost map information$/;"	m	class:base_local_planner::TrajectoryPlanner
costmap_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      costmap_2d::Costmap2D* costmap_; \/\/\/< @brief The costmap the controller will use$/;"	m	class:base_local_planner::TrajectoryPlannerROS
costmap_	carrot_planner/include/carrot_planner/carrot_planner.h	/^      costmap_2d::Costmap2D* costmap_;$/;"	m	class:carrot_planner::CarrotPlanner
costmap_	costmap_2d/include/costmap_2d/costmap_2d.h	/^    const Costmap2D& costmap_;$/;"	m	class:costmap_2d::Costmap2D::PolygonOutlineCells
costmap_	costmap_2d/include/costmap_2d/costmap_2d.h	/^    unsigned char* costmap_;$/;"	m	class:costmap_2d::Costmap2D::MarkCell
costmap_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned char* costmap_;$/;"	m	class:costmap_2d::Costmap2D
costmap_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  Costmap2D* costmap_;$/;"	m	class:costmap_2d::Costmap2DPublisher
costmap_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  Costmap2D costmap_;$/;"	m	class:costmap_2d::LayeredCostmap
costmap_	global_planner/include/global_planner/planner_core.h	/^        costmap_2d::Costmap2D* costmap_;$/;"	m	class:global_planner::GlobalPlanner
costmap_	navfn/include/navfn/navfn_ros.h	/^      costmap_2d::Costmap2D* costmap_;$/;"	m	class:navfn::NavfnROS
costmap_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned char *costmap_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxelInMap
costmap_2d	costmap_2d/include/costmap_2d/array_parser.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/cost_values.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/costmap_2d.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/costmap_layer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/footprint.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/inflation_layer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/layer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/layered_costmap.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/observation.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/observation_buffer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/obstacle_layer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/static_layer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/include/costmap_2d/voxel_layer.h	/^namespace costmap_2d$/;"	n
costmap_2d	costmap_2d/plugins/inflation_layer.cpp	/^        namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/plugins/obstacle_layer.cpp	/^        namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/plugins/static_layer.cpp	/^        namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/plugins/voxel_layer.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/array_parser.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/costmap_2d.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/costmap_2d_publisher.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/costmap_2d_ros.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/costmap_layer.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/footprint.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/layer.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/layered_costmap.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/src/observation_buffer.cpp	/^namespace costmap_2d$/;"	n	file:
costmap_2d	costmap_2d/test/costmap_tester.cpp	/^namespace costmap_2d {$/;"	n	file:
costmap_pub_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  ros::Publisher costmap_pub_;$/;"	m	class:costmap_2d::Costmap2DPublisher
costmap_ros_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      costmap_2d::Costmap2DROS* costmap_ros_; \/\/\/< @brief The ROS wrapper for the costmap the controller will use$/;"	m	class:base_local_planner::TrajectoryPlannerROS
costmap_ros_	carrot_planner/include/carrot_planner/carrot_planner.h	/^      costmap_2d::Costmap2DROS* costmap_ros_;$/;"	m	class:carrot_planner::CarrotPlanner
costmap_ros_	costmap_2d/test/costmap_tester.cpp	/^    costmap_2d::Costmap2DROS costmap_ros_;$/;"	m	class:costmap_2d::CostmapTester	file:
costmap_ros_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      costmap_2d::Costmap2DROS* costmap_ros_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
costmap_update_pub_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  ros::Publisher costmap_update_pub_;$/;"	m	class:costmap_2d::Costmap2DPublisher
count	amcl/include/amcl/pf/pf.h	/^  int count;$/;"	m	struct:__anon4
countValues	costmap_2d/include/costmap_2d/testing_helper.h	/^unsigned int countValues(costmap_2d::Costmap2D& costmap, unsigned char value, bool equal = true)$/;"	f
countValues	map_server/test/utest.cpp	/^std::vector<unsigned int> countValues(const nav_msgs::GetMap::Response& map_resp)$/;"	f
cov	amcl/include/amcl/pf/pf.h	/^  pf_matrix_t cov;$/;"	m	struct:__anon4
cov	amcl/include/amcl/pf/pf.h	/^  pf_matrix_t cov;$/;"	m	struct:_pf_sample_set_t
cr	amcl/include/amcl/pf/pf_pdf.h	/^  pf_matrix_t cr;$/;"	m	struct:__anon7
createTrajectories	base_local_planner/src/trajectory_planner.cpp	/^  Trajectory TrajectoryPlanner::createTrajectories(double x, double y, double theta,$/;"	f	class:base_local_planner::TrajectoryPlanner
create_nav_plan_astar	navfn/src/navfn.cpp	/^    create_nav_plan_astar(COSTTYPE *costmap, int nx, int ny,$/;"	f	namespace:navfn
critics_	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^  std::vector<TrajectoryCostFunction*> critics_;$/;"	m	class:base_local_planner::SimpleScoredSamplingPlanner
crop_image	map_server/scripts/crop_map	/^        crop_image = "cropped.pgm"$/;"	v
crop_image	map_server/scripts/crop_map	/^        crop_image = crop_name + ".pgm"$/;"	v
crop_name	map_server/scripts/crop_map	/^            crop_name = crop_name[:-5]$/;"	v
crop_name	map_server/scripts/crop_map	/^        crop_name = sys.argv[2]$/;"	v
crop_yaml	map_server/scripts/crop_map	/^        crop_yaml = "cropped.yaml"$/;"	v
crop_yaml	map_server/scripts/crop_map	/^        crop_yaml = crop_name + ".yaml"$/;"	v
cropped_image	map_server/scripts/crop_map	/^    cropped_image = map_image.crop((bounds[0], bounds[2], bounds[1] + 1, bounds[3] + 1))$/;"	v
curP	navfn/include/navfn/navfn.h	/^      int *curP, *nextP, *overP;	\/**< priority buffer block ptrs *\/$/;"	m	class:navfn::NavFn
curPe	navfn/include/navfn/navfn.h	/^      int curPe, nextPe, overPe; \/**< end points of arrays *\/$/;"	m	class:navfn::NavFn
curT	navfn/include/navfn/navfn.h	/^      float curT;			\/**< current threshold *\/$/;"	m	class:navfn::NavFn
curpixel_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int curpixel_; \/\/\/< index of current point in line loop.$/;"	m	class:base_local_planner::LineIterator
currentBuffer_	global_planner/include/global_planner/dijkstra.h	/^        int *currentBuffer_, *nextBuffer_, *overBuffer_; \/**< priority buffer block ptrs *\/$/;"	m	class:global_planner::DijkstraExpansion
currentEnd_	global_planner/include/global_planner/dijkstra.h	/^        int currentEnd_, nextEnd_, overEnd_; \/**< end points of arrays *\/$/;"	m	class:global_planner::DijkstraExpansion
current_	costmap_2d/include/costmap_2d/layer.h	/^  bool current_;$/;"	m	class:costmap_2d::Layer
current_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool current_;$/;"	m	class:costmap_2d::LayeredCostmap
current_goal_pub_	move_base/include/move_base/move_base.h	/^      ros::Publisher current_goal_pub_, vel_pub_, action_goal_pub_;$/;"	m	class:move_base::MoveBase
current_index	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      unsigned int current_index;$/;"	m	class:base_local_planner::VelocityIterator
current_pose_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      geometry_msgs::PoseStamped current_pose_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
current_set	amcl/include/amcl/pf/pf.h	/^  int current_set;$/;"	m	struct:_pf_t
cx	amcl/include/amcl/pf/pf_pdf.h	/^  pf_matrix_t cx;$/;"	m	struct:__anon7
cx	base_local_planner/include/base_local_planner/map_cell.h	/^      unsigned int cx, cy; \/\/\/< @brief Cell index in the grid map$/;"	m	class:base_local_planner::MapCell
cxdet	amcl/include/amcl/pf/pf_pdf.h	/^  double cxdet;$/;"	m	struct:__anon7
cy	base_local_planner/include/base_local_planner/map_cell.h	/^      unsigned int cx, cy; \/\/\/< @brief Cell index in the grid map$/;"	m	class:base_local_planner::MapCell
d	base_local_planner/setup.py	/^d = generate_distutils_setup($/;"	v
d_thresh_	amcl/src/amcl_node.cpp	/^    double d_thresh_, a_thresh_;$/;"	m	class:AmclNode	file:
data_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    uint32_t* data_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxel
data_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    uint32_t* data_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxelInMap
data_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    uint32_t* data_;$/;"	m	class:voxel_grid::VoxelGrid::MarkVoxel
data_	voxel_grid/include/voxel_grid/voxel_grid.h	/^  uint32_t *data_;$/;"	m	class:voxel_grid::VoxelGrid
deactivate	costmap_2d/include/costmap_2d/layer.h	/^  virtual void deactivate() {}$/;"	f	class:costmap_2d::Layer
deactivate	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::deactivate()$/;"	f	class:costmap_2d::ObstacleLayer
deactivate	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::deactivate()$/;"	f	class:range_sensor_layer::RangeSensorLayer
deactivate	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::deactivate()$/;"	f	class:costmap_2d::StaticLayer
dec	navfn/include/navfn/navwin.h	/^      int dec, inc;			\/\/ decimation or expansion for display$/;"	m	class:navfn::NavWin
default_config_	amcl/src/amcl_node.cpp	/^    amcl::AMCLConfig default_config_;$/;"	m	class:AmclNode	file:
default_config_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      base_local_planner::BaseLocalPlannerConfig default_config_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
default_config_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      dwa_local_planner::DWAPlannerConfig default_config_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
default_config_	move_base/include/move_base/move_base.h	/^      move_base::MoveBaseConfig default_config_;$/;"	m	class:move_base::MoveBase
default_limits_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  LocalPlannerLimits default_limits_;$/;"	m	class:base_local_planner::LocalPlannerUtil
default_tolerance_	global_planner/include/global_planner/planner_core.h	/^        double planner_window_x_, planner_window_y_, default_tolerance_;$/;"	m	class:global_planner::GlobalPlanner
default_tolerance_	navfn/include/navfn/navfn_ros.h	/^      double planner_window_x_, planner_window_y_, default_tolerance_;$/;"	m	class:navfn::NavfnROS
default_value_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned char default_value_;$/;"	m	class:costmap_2d::Costmap2D
deleteKernels	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::deleteKernels()$/;"	f	class:costmap_2d::InflationLayer
deleteMaps	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::deleteMaps()$/;"	f	class:costmap_2d::Costmap2D
delta	amcl/include/amcl/sensors/amcl_odom.h	/^  public: pf_vector_t delta;$/;"	m	class:amcl::AMCLOdomData
delta	costmap_2d/plugins/range_sensor_layer.cpp	/^    double RangeSensorLayer::delta(double phi)$/;"	f	class:range_sensor_layer::RangeSensorLayer
delta_x_	fake_localization/fake_localization.cpp	/^    double                         delta_x_, delta_y_, delta_yaw_;$/;"	m	class:FakeOdomNode	file:
delta_y_	fake_localization/fake_localization.cpp	/^    double                         delta_x_, delta_y_, delta_yaw_;$/;"	m	class:FakeOdomNode	file:
delta_yaw_	fake_localization/fake_localization.cpp	/^    double                         delta_x_, delta_y_, delta_yaw_;$/;"	m	class:FakeOdomNode	file:
deltax_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int deltax_; \/\/\/< Difference between Xs of endpoints.$/;"	m	class:base_local_planner::LineIterator
deltay_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int deltay_; \/\/\/< Difference between Ys of endpoints.$/;"	m	class:base_local_planner::LineIterator
den_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int den_, num_, numadd_, numpixels_;$/;"	m	class:base_local_planner::LineIterator
deprecated	map_server/src/main.cpp	/^    bool deprecated;$/;"	m	class:MapServer	file:
depth	amcl/include/amcl/pf/pf_kdtree.h	/^  int leaf, depth;$/;"	m	struct:pf_kdtree_node
diagnosic_updater_	amcl/src/amcl_node.cpp	/^    diagnostic_updater::Updater diagnosic_updater_;$/;"	m	class:AmclNode	file:
discretize_by_time_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  bool discretize_by_time_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
dispPot	navfn/src/navtest.cpp	/^dispPot(NavFn *nav)$/;"	f
display	navfn/src/navfn.cpp	/^    NavFn::display(void fn(NavFn *nav), int n)$/;"	f	class:navfn::NavFn
displayFn	navfn/include/navfn/navfn.h	/^      void (*displayFn)(NavFn *nav); \/**< display function itself *\/$/;"	m	class:navfn::NavFn
displayInt	navfn/include/navfn/navfn.h	/^      int displayInt;		\/**< save second argument of display() above *\/$/;"	m	class:navfn::NavFn
dist	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      inline double dist(double x0, double y0, double z0, double x1, double y1, double z1){$/;"	f	class:base_local_planner::VoxelGridModel
dist	costmap_2d/include/costmap_2d/voxel_layer.h	/^  inline double dist(double x0, double y0, double z0, double x1, double y1, double z1)$/;"	f	class:costmap_2d::VoxelLayer
dist_threshold	amcl/include/amcl/pf/pf.h	/^  double dist_threshold; \/\/distance threshold in each axis over which the pf is considered to not be converged$/;"	m	struct:_pf_t
distance	costmap_2d/include/costmap_2d/costmap_math.h	/^inline double distance(double x0, double y0, double x1, double y1)$/;"	f
distance	move_base/src/move_base.cpp	/^    double MoveBase::distance(const geometry_msgs::PoseStamped& p1, const geometry_msgs::PoseStamped& p2)$/;"	f	class:move_base::MoveBase
distanceCheck	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    void MoveSlowAndClear::distanceCheck(const ros::TimerEvent& e)$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
distanceLookup	costmap_2d/include/costmap_2d/inflation_layer.h	/^  inline double distanceLookup(int mx, int my, int src_x, int src_y)$/;"	f	class:costmap_2d::InflationLayer
distanceToLine	costmap_2d/src/costmap_math.cpp	/^double distanceToLine(double pX, double pY, double x0, double y0, double x1, double y1)$/;"	f
distance_check_timer_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      ros::Timer distance_check_timer_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
distances_	amcl/src/amcl/map/map_cspace.cpp	/^    double** distances_;$/;"	m	class:CachedDistanceMap	file:
do_beamskip	amcl/include/amcl/sensors/amcl_laser.h	/^  private: bool do_beamskip; $/;"	m	class:amcl::AMCLLaser
do_beamskip_	amcl/src/amcl_node.cpp	/^    bool do_beamskip_;$/;"	m	class:AmclNode	file:
dp_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      boost::shared_ptr<DWAPlanner> dp_; \/\/\/< @brief The trajectory controller$/;"	m	class:dwa_local_planner::DWAPlannerROS
drand48	amcl/src/include/portable_utils.hpp	/^static double drand48(void)$/;"	f
draw	navfn/src/navwin.cpp	/^void NavWin::draw()$/;"	f	class:navfn::NavWin
drawOverlay	navfn/src/navwin.cpp	/^NavWin::drawOverlay()$/;"	f	class:navfn::NavWin
drawPot	navfn/src/navwin.cpp	/^NavWin::drawPot(NavFn *nav)$/;"	f	class:navfn::NavWin
dsrv_	amcl/src/amcl_node.cpp	/^    dynamic_reconfigure::Server<amcl::AMCLConfig> *dsrv_;$/;"	m	class:AmclNode	file:
dsrv_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      dynamic_reconfigure::Server<BaseLocalPlannerConfig> *dsrv_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
dsrv_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  dynamic_reconfigure::Server<costmap_2d::Costmap2DConfig> *dsrv_;$/;"	m	class:costmap_2d::Costmap2DROS
dsrv_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  dynamic_reconfigure::Server<costmap_2d::InflationPluginConfig> *dsrv_;$/;"	m	class:costmap_2d::InflationLayer
dsrv_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  dynamic_reconfigure::Server<costmap_2d::ObstaclePluginConfig> *dsrv_;$/;"	m	class:costmap_2d::ObstacleLayer
dsrv_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  dynamic_reconfigure::Server<range_sensor_layer::RangeSensorLayerConfig> *dsrv_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
dsrv_	costmap_2d/include/costmap_2d/static_layer.h	/^  dynamic_reconfigure::Server<costmap_2d::GenericPluginConfig> *dsrv_;$/;"	m	class:costmap_2d::StaticLayer
dsrv_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      dynamic_reconfigure::Server<DWAPlannerConfig> *dsrv_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
dsrv_	global_planner/include/global_planner/planner_core.h	/^        dynamic_reconfigure::Server<global_planner::GlobalPlannerConfig> *dsrv_;$/;"	m	class:global_planner::GlobalPlanner
dsrv_	move_base/include/move_base/move_base.h	/^      dynamic_reconfigure::Server<move_base::MoveBaseConfig> *dsrv_;$/;"	m	class:move_base::MoveBase
dwaComputeVelocityCommands	dwa_local_planner/src/dwa_planner_ros.cpp	/^            bool DWAPlannerROS::dwaComputeVelocityCommands(geometry_msgs::PoseStamped &global_pose, geometry_msgs::Twist& cmd_vel) {$/;"	f	class:dwa_local_planner::DWAPlannerROS
dwa_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool dwa_;  \/\/\/< @brief Should we use the dynamic window approach?$/;"	m	class:base_local_planner::TrajectoryPlanner
dwa_local_planner	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^namespace dwa_local_planner {$/;"	n
dwa_local_planner	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^namespace dwa_local_planner {$/;"	n
dwa_local_planner	dwa_local_planner/src/dwa_planner.cpp	/^namespace dwa_local_planner {$/;"	n	file:
dwa_local_planner	dwa_local_planner/src/dwa_planner_ros.cpp	/^        namespace dwa_local_planner {$/;"	n	file:
edit_method	global_planner/cfg/GlobalPlanner.cfg	/^        edit_method=orientation_enum)$/;"	v
eigen_decomposition	amcl/src/amcl/pf/eig3.c	/^void eigen_decomposition(double A[n][n], double V[n][n], double d[n]) {$/;"	f
enabled_	costmap_2d/include/costmap_2d/layer.h	/^  bool enabled_;  \/\/\/< Currently this var is managed by subclasses. TODO: make this managed by this class and\/or container class.$/;"	m	class:costmap_2d::Layer
end_x_	global_planner/include/global_planner/planner_core.h	/^        unsigned int start_x_, start_y_, end_x_, end_y_;$/;"	m	class:global_planner::GlobalPlanner
end_y_	global_planner/include/global_planner/planner_core.h	/^        unsigned int start_x_, start_y_, end_x_, end_y_;$/;"	m	class:global_planner::GlobalPlanner
enqueue	amcl/src/amcl/map/map_cspace.cpp	/^void enqueue(map_t* map, int i, int j,$/;"	f
enqueue	costmap_2d/plugins/inflation_layer.cpp	/^    inline void InflationLayer::enqueue(unsigned int index, unsigned int mx, unsigned int my,$/;"	f	class:costmap_2d::InflationLayer
escape_reset_dist_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double escape_reset_dist_, escape_reset_theta_; \/\/\/< @brief The distance the robot must travel before it can leave escape mode$/;"	m	class:base_local_planner::TrajectoryPlanner
escape_reset_theta_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double escape_reset_dist_, escape_reset_theta_; \/\/\/< @brief The distance the robot must travel before it can leave escape mode$/;"	m	class:base_local_planner::TrajectoryPlanner
escape_theta_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double escape_x_, escape_y_, escape_theta_; \/\/\/< @brief Used to calculate the distance the robot has traveled before reseting escape booleans$/;"	m	class:base_local_planner::TrajectoryPlanner
escape_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double escape_x_, escape_y_, escape_theta_; \/\/\/< @brief Used to calculate the distance the robot has traveled before reseting escape booleans$/;"	m	class:base_local_planner::TrajectoryPlanner
escape_y_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double escape_x_, escape_y_, escape_theta_; \/\/\/< @brief Used to calculate the distance the robot has traveled before reseting escape booleans$/;"	m	class:base_local_planner::TrajectoryPlanner
escaping_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool escaping_; \/\/\/< @brief Boolean to keep track of whether we're in escape mode$/;"	m	class:base_local_planner::TrajectoryPlanner
executeCb	move_base/src/move_base.cpp	/^    void MoveBase::executeCb(const move_base_msgs::MoveBaseGoalConstPtr& move_base_goal)$/;"	f	class:move_base::MoveBase
executeCycle	move_base/src/move_base.cpp	/^    bool MoveBase::executeCycle(geometry_msgs::PoseStamped& goal){$/;"	f	class:move_base::MoveBase
expected_update_rate_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  const ros::Duration expected_update_rate_;$/;"	m	class:costmap_2d::ObservationBuffer
extra_max_x_	costmap_2d/include/costmap_2d/costmap_layer.h	/^  double extra_min_x_, extra_max_x_, extra_min_y_, extra_max_y_;$/;"	m	class:costmap_2d::CostmapLayer
extra_max_y_	costmap_2d/include/costmap_2d/costmap_layer.h	/^  double extra_min_x_, extra_max_x_, extra_min_y_, extra_max_y_;$/;"	m	class:costmap_2d::CostmapLayer
extra_min_x_	costmap_2d/include/costmap_2d/costmap_layer.h	/^  double extra_min_x_, extra_max_x_, extra_min_y_, extra_max_y_;$/;"	m	class:costmap_2d::CostmapLayer
extra_min_y_	costmap_2d/include/costmap_2d/costmap_layer.h	/^  double extra_min_x_, extra_max_x_, extra_min_y_, extra_max_y_;$/;"	m	class:costmap_2d::CostmapLayer
factor_	global_planner/include/global_planner/expander.h	/^        float factor_;$/;"	m	class:global_planner::Expander
fh	base_local_planner/test/footprint_helper_test.cpp	/^  FootprintHelper fh;$/;"	m	class:base_local_planner::FootprintHelperTest	file:
filter_	fake_localization/fake_localization.cpp	/^    tf2_ros::MessageFilter<nav_msgs::Odometry>* filter_;$/;"	m	class:FakeOdomNode	file:
filter_sub_	fake_localization/fake_localization.cpp	/^    message_filters::Subscriber<nav_msgs::Odometry>* filter_sub_;$/;"	m	class:FakeOdomNode	file:
final_goal_position_valid_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool final_goal_position_valid_; \/\/\/< @brief True if final_goal_x_ and final_goal_y_ have valid data.  Only false if an empty path is sent.$/;"	m	class:base_local_planner::TrajectoryPlanner
final_goal_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double final_goal_x_, final_goal_y_; \/\/\/< @brief The end position of the plan.$/;"	m	class:base_local_planner::TrajectoryPlanner
final_goal_y_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double final_goal_x_, final_goal_y_; \/\/\/< @brief The end position of the plan.$/;"	m	class:base_local_planner::TrajectoryPlanner
find	costmap_2d/test/module_tests.cpp	/^bool find(const std::vector<unsigned int>& l, unsigned int n){$/;"	f
findBestPath	base_local_planner/src/trajectory_planner.cpp	/^  Trajectory TrajectoryPlanner::findBestPath(const geometry_msgs::PoseStamped& global_pose,$/;"	f	class:base_local_planner::TrajectoryPlanner
findBestPath	dwa_local_planner/src/dwa_planner.cpp	/^  base_local_planner::Trajectory DWAPlanner::findBestPath($/;"	f	class:dwa_local_planner::DWAPlanner
findBestTrajectory	base_local_planner/src/simple_scored_sampling_planner.cpp	/^    bool SimpleScoredSamplingPlanner::findBestTrajectory(Trajectory& traj, std::vector<Trajectory>* all_explored) {$/;"	f	class:base_local_planner::SimpleScoredSamplingPlanner
find_bounds	map_server/scripts/crop_map	/^def find_bounds(map_image):$/;"	f
first_map_only_	amcl/src/amcl_node.cpp	/^    bool first_map_only_;$/;"	m	class:AmclNode	file:
first_map_only_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool first_map_only_;      \/\/\/< @brief Store the first static map and reuse it on reinitializing$/;"	m	class:costmap_2d::StaticLayer
first_map_received_	amcl/src/amcl_node.cpp	/^    bool first_map_received_;$/;"	m	class:AmclNode	file:
first_reconfigure_call_	amcl/src/amcl_node.cpp	/^    bool first_reconfigure_call_;$/;"	m	class:AmclNode	file:
footprintCost	base_local_planner/include/base_local_planner/world_model.h	/^            double footprintCost(const geometry_msgs::Point& position, const std::vector<geometry_msgs::Point>& footprint,$/;"	f	class:base_local_planner::WorldModel
footprintCost	base_local_planner/include/base_local_planner/world_model.h	/^            double footprintCost(double x, double y, double theta, const std::vector<geometry_msgs::Point>& footprint_spec, double inscribed_radius = 0.0, double circumscribed_radius=0.0){$/;"	f	class:base_local_planner::WorldModel
footprintCost	base_local_planner/src/costmap_model.cpp	/^    double CostmapModel::footprintCost(const geometry_msgs::Point& position, const std::vector<geometry_msgs::Point>& footprint,$/;"	f	class:base_local_planner::CostmapModel
footprintCost	base_local_planner/src/obstacle_cost_function.cpp	/^    double ObstacleCostFunction::footprintCost ($/;"	f	class:base_local_planner::ObstacleCostFunction
footprintCost	base_local_planner/src/point_grid.cpp	/^  double PointGrid::footprintCost(const geometry_msgs::Point& position, const std::vector<geometry_msgs::Point>& footprint,$/;"	f	class:base_local_planner::PointGrid
footprintCost	base_local_planner/src/trajectory_planner.cpp	/^  double TrajectoryPlanner::footprintCost(double x_i, double y_i, double theta_i){$/;"	f	class:base_local_planner::TrajectoryPlanner
footprintCost	base_local_planner/src/voxel_grid_model.cpp	/^  double VoxelGridModel::footprintCost(const geometry_msgs::Point& position, const std::vector<geometry_msgs::Point>& footprint, $/;"	f	class:base_local_planner::VoxelGridModel
footprintCost	carrot_planner/src/carrot_planner.cpp	/^  double CarrotPlanner::footprintCost(double x_i, double y_i, double theta_i){$/;"	f	class:carrot_planner::CarrotPlanner
footprintObstacles	base_local_planner/test/utest.cpp	/^void TrajectoryPlannerTest::footprintObstacles(){$/;"	f	class:base_local_planner::TrajectoryPlannerTest
footprint_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  std::vector<geometry_msgs::Point> footprint_;$/;"	m	class:costmap_2d::LayeredCostmap
footprint_clearing_enabled_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  bool footprint_clearing_enabled_;$/;"	m	class:costmap_2d::ObstacleLayer
footprint_helper_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      base_local_planner::FootprintHelper footprint_helper_;$/;"	m	class:base_local_planner::TrajectoryPlanner
footprint_padding_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  float footprint_padding_;$/;"	m	class:costmap_2d::Costmap2DROS
footprint_pub_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  ros::Publisher footprint_pub_;$/;"	m	class:costmap_2d::Costmap2DROS
footprint_spec_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  std::vector<geometry_msgs::Point> footprint_spec_;$/;"	m	class:base_local_planner::ObstacleCostFunction
footprint_spec_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      std::vector<geometry_msgs::Point> footprint_spec_; \/\/\/< @brief The footprint specification of the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
footprint_spec_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      std::vector<geometry_msgs::Point> footprint_spec_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
footprint_spec_	costmap_2d/include/costmap_2d/layer.h	/^  std::vector<geometry_msgs::Point> footprint_spec_;$/;"	m	class:costmap_2d::Layer
footprint_sub_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  ros::Subscriber footprint_sub_;$/;"	m	class:costmap_2d::Costmap2DROS
force_updating_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      bool force_updating_; \/\/\/< force costmap update after clearing, so we don't need to wait for update thread$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
forward_neg_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool forward_pos_only_, forward_neg_only_, forward_pos_, forward_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
forward_neg_only_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool forward_pos_only_, forward_neg_only_, forward_pos_, forward_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
forward_point_distance_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double forward_point_distance_;$/;"	m	class:dwa_local_planner::DWAPlanner
forward_pos_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool forward_pos_only_, forward_neg_only_, forward_pos_, forward_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
forward_pos_only_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool forward_pos_only_, forward_neg_only_, forward_pos_, forward_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
frame_id_	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^            std::string frame_id_;$/;"	m	class:base_local_planner::MapGridVisualizer
frame_id_	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  std::string frame_id_; \/\/\/< The frame_id associated this data$/;"	m	class:base_local_planner::OdometryHelperRos
frame_id_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      std::string frame_id_;$/;"	m	class:dwa_local_planner::DWAPlanner
frame_id_	global_planner/include/global_planner/planner_core.h	/^        std::string frame_id_;$/;"	m	class:global_planner::GlobalPlanner
frame_to_laser_	amcl/src/amcl_node.cpp	/^    std::map< std::string, int > frame_to_laser_;$/;"	m	class:AmclNode	file:
freeMapDependentMemory	amcl/src/amcl_node.cpp	/^AmclNode::freeMapDependentMemory()$/;"	f	class:AmclNode
free_cost_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned char free_cost_, unknown_cost_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxelInMap
free_space_indices	amcl/src/amcl_node.cpp	/^    static std::vector<std::pair<int,int> > free_space_indices;$/;"	m	class:AmclNode	file:
free_space_indices	amcl/src/amcl_node.cpp	/^std::vector<std::pair<int,int> > AmclNode::free_space_indices;$/;"	m	class:AmclNode	file:
frequency_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  double sim_granularity_, min_rotational_vel_, max_rotational_vel_, acc_lim_th_, tolerance_, frequency_;$/;"	m	class:rotate_recovery::RotateRecovery
g_argc	map_server/test/rtest.cpp	/^int g_argc;$/;"	v
g_argv	map_server/test/rtest.cpp	/^char** g_argv;$/;"	v
g_cells	costmap_2d/src/costmap_2d_markers.cpp	/^V_Cell g_cells;$/;"	v
g_colors_a	costmap_2d/src/costmap_2d_cloud.cpp	/^float g_colors_a[] = {0.0f, 0.5f, 1.0f};$/;"	v
g_colors_a	costmap_2d/src/costmap_2d_markers.cpp	/^float g_colors_a[] = {0.0f, 0.5f, 1.0f};$/;"	v
g_colors_b	costmap_2d/src/costmap_2d_cloud.cpp	/^float g_colors_b[] = {0.0f, 1.0f, 0.0f};$/;"	v
g_colors_b	costmap_2d/src/costmap_2d_markers.cpp	/^float g_colors_b[] = {0.0f, 1.0f, 0.0f};$/;"	v
g_colors_g	costmap_2d/src/costmap_2d_cloud.cpp	/^float g_colors_g[] = {0.0f, 0.0f, 0.0f};$/;"	v
g_colors_g	costmap_2d/src/costmap_2d_markers.cpp	/^float g_colors_g[] = {0.0f, 0.0f, 0.0f};$/;"	v
g_colors_r	costmap_2d/src/costmap_2d_cloud.cpp	/^float g_colors_r[] = {0.0f, 0.0f, 1.0f};$/;"	v
g_colors_r	costmap_2d/src/costmap_2d_markers.cpp	/^float g_colors_r[] = {0.0f, 0.0f, 1.0f};$/;"	v
g_marked	costmap_2d/src/costmap_2d_cloud.cpp	/^V_Cell g_marked;$/;"	v
g_marker_ns	costmap_2d/src/costmap_2d_markers.cpp	/^std::string g_marker_ns;$/;"	v
g_plan_pub_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      ros::Publisher g_plan_pub_, l_plan_pub_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
g_plan_pub_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      ros::Publisher g_plan_pub_, l_plan_pub_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
g_spectrum_png_file	map_server/test/test_constants.cpp	/^const char* g_spectrum_png_file = "test\/spectrum.png";$/;"	v
g_unknown	costmap_2d/src/costmap_2d_cloud.cpp	/^V_Cell g_unknown;$/;"	v
g_valid_bmp_file	map_server/test/test_constants.cpp	/^const char* g_valid_bmp_file = "test\/testmap.bmp";$/;"	v
g_valid_image_content	map_server/test/test_constants.cpp	/^const char g_valid_image_content[] = {$/;"	v
g_valid_image_height	map_server/test/test_constants.cpp	/^const unsigned int g_valid_image_height = 10;$/;"	v
g_valid_image_res	map_server/test/test_constants.cpp	/^const float g_valid_image_res = 0.1;$/;"	v
g_valid_image_width	map_server/test/test_constants.cpp	/^const unsigned int g_valid_image_width = 10;$/;"	v
g_valid_png_file	map_server/test/test_constants.cpp	/^const char* g_valid_png_file = "test\/testmap.png";$/;"	v
gamma	costmap_2d/plugins/range_sensor_layer.cpp	/^    double RangeSensorLayer::gamma(double theta)$/;"	f	class:range_sensor_layer::RangeSensorLayer
gen	amcl/cfg/AMCL.cfg	/^gen = ParameterGenerator()$/;"	v
gen	base_local_planner/cfg/BaseLocalPlanner.cfg	/^gen = ParameterGenerator()$/;"	v
gen	costmap_2d/cfg/Costmap2D.cfg	/^gen = ParameterGenerator()$/;"	v
gen	costmap_2d/cfg/GenericPlugin.cfg	/^gen = ParameterGenerator()$/;"	v
gen	costmap_2d/cfg/InflationPlugin.cfg	/^gen = ParameterGenerator()$/;"	v
gen	costmap_2d/cfg/ObstaclePlugin.cfg	/^gen = ParameterGenerator()$/;"	v
gen	costmap_2d/cfg/RangeSensorLayer.cfg	/^gen = ParameterGenerator()$/;"	v
gen	costmap_2d/cfg/VoxelPlugin.cfg	/^gen = ParameterGenerator()$/;"	v
gen	dwa_local_planner/cfg/DWAPlanner.cfg	/^gen = ParameterGenerator()$/;"	v
gen	global_planner/cfg/GlobalPlanner.cfg	/^gen = ParameterGenerator()$/;"	v
gen	move_base/cfg/MoveBase.cfg	/^gen = ParameterGenerator()$/;"	v
gen_list_	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^  std::vector<TrajectorySampleGenerator*> gen_list_;$/;"	m	class:base_local_planner::SimpleScoredSamplingPlanner
generateTrajectory	base_local_planner/src/simple_trajectory_generator.cpp	/^bool SimpleTrajectoryGenerator::generateTrajectory($/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
generateTrajectory	base_local_planner/src/trajectory_planner.cpp	/^  void TrajectoryPlanner::generateTrajectory($/;"	f	class:base_local_planner::TrajectoryPlanner
generator_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::SimpleTrajectoryGenerator generator_;$/;"	m	class:dwa_local_planner::DWAPlanner
getAccLimits	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  Eigen::Vector3f getAccLimits() {$/;"	f	class:base_local_planner::LocalPlannerLimits
getBaseFrameID	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::string getBaseFrameID() const$/;"	f	class:costmap_2d::Costmap2DROS
getBounds	costmap_2d/include/costmap_2d/layered_costmap.h	/^  void getBounds(unsigned int* x0, unsigned int* xn, unsigned int* y0, unsigned int* yn)$/;"	f	class:costmap_2d::LayeredCostmap
getCell	base_local_planner/include/base_local_planner/map_grid.h	/^      inline MapCell& getCell(unsigned int x, unsigned int y){$/;"	f	class:base_local_planner::MapGrid
getCellBounds	base_local_planner/include/base_local_planner/point_grid.h	/^      inline void getCellBounds(unsigned int gx, unsigned int gy, geometry_msgs::Point& lower_left, geometry_msgs::Point& upper_right) const {$/;"	f	class:base_local_planner::PointGrid
getCellCosts	base_local_planner/src/map_grid_cost_function.cpp	/^    double MapGridCostFunction::getCellCosts(unsigned int px, unsigned int py) {$/;"	f	class:base_local_planner::MapGridCostFunction
getCellCosts	base_local_planner/src/trajectory_planner.cpp	/^  bool TrajectoryPlanner::getCellCosts(int cx, int cy, float &path_cost, float &goal_cost, float &occ_cost, float &total_cost) {$/;"	f	class:base_local_planner::TrajectoryPlanner
getCellCosts	dwa_local_planner/src/dwa_planner.cpp	/^  bool DWAPlanner::getCellCosts(int cx, int cy, float &path_cost, float &goal_cost, float &occ_cost, float &total_cost) {$/;"	f	class:dwa_local_planner::DWAPlanner
getCharMap	costmap_2d/src/costmap_2d.cpp	/^    unsigned char* Costmap2D::getCharMap() const$/;"	f	class:costmap_2d::Costmap2D
getCharTmpMap	costmap_2d/src/costmap_2d.cpp	/^    unsigned char* Costmap2D::getCharTmpMap() const$/;"	f	class:costmap_2d::Costmap2D
getCircumscribedRadius	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double getCircumscribedRadius() { return circumscribed_radius_; }$/;"	f	class:costmap_2d::LayeredCostmap
getClearingObservations	costmap_2d/plugins/obstacle_layer.cpp	/^    bool ObstacleLayer::getClearingObservations(std::vector<Observation>& clearing_observations) const$/;"	f	class:costmap_2d::ObstacleLayer
getCost	costmap_2d/src/costmap_2d.cpp	/^    unsigned char Costmap2D::getCost(unsigned int mx, unsigned int my) const$/;"	f	class:costmap_2d::Costmap2D
getCost	global_planner/include/global_planner/dijkstra.h	/^        float getCost(unsigned char* costs, int n) {$/;"	f	class:global_planner::DijkstraExpansion
getCostmap	base_local_planner/src/local_planner_util.cpp	/^costmap_2d::Costmap2D* LocalPlannerUtil::getCostmap() {$/;"	f	class:base_local_planner::LocalPlannerUtil
getCostmap	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  Costmap2D* getCostmap() const$/;"	f	class:costmap_2d::Costmap2DROS
getCostmap	costmap_2d/include/costmap_2d/layered_costmap.h	/^  Costmap2D* getCostmap()$/;"	f	class:costmap_2d::LayeredCostmap
getCurrentLimits	base_local_planner/src/local_planner_util.cpp	/^LocalPlannerLimits LocalPlannerUtil::getCurrentLimits() {$/;"	f	class:base_local_planner::LocalPlannerUtil
getData	voxel_grid/include/voxel_grid/voxel_grid.h	/^  uint32_t* getData() { return data_; }$/;"	f	class:voxel_grid::VoxelGrid
getDefaultValue	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned char getDefaultValue()$/;"	f	class:costmap_2d::Costmap2D
getEndpoint	base_local_planner/src/trajectory.cpp	/^  void Trajectory::getEndpoint(double& x, double& y, double& th) const {$/;"	f	class:base_local_planner::Trajectory
getFillCells	base_local_planner/src/footprint_helper.cpp	/^void FootprintHelper::getFillCells(std::vector<base_local_planner::Position2DInt>& footprint){$/;"	f	class:base_local_planner::FootprintHelper
getFootprint	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      std::vector<geometry_msgs::Point> getFootprint() const { return footprint_spec_; }$/;"	f	class:base_local_planner::TrajectoryPlanner
getFootprint	costmap_2d/include/costmap_2d/layered_costmap.h	/^  const std::vector<geometry_msgs::Point>& getFootprint() { return footprint_; }$/;"	f	class:costmap_2d::LayeredCostmap
getFootprint	costmap_2d/src/layer.cpp	/^const std::vector<geometry_msgs::Point>& Layer::getFootprint() const$/;"	f	class:costmap_2d::Layer
getFootprintCells	base_local_planner/src/footprint_helper.cpp	/^std::vector<base_local_planner::Position2DInt> FootprintHelper::getFootprintCells($/;"	f	class:base_local_planner::FootprintHelper
getFootprintPolygon	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      geometry_msgs::Polygon getFootprintPolygon() const { return costmap_2d::toPolygon(footprint_spec_); }$/;"	f	class:base_local_planner::TrajectoryPlanner
getGlobalFrame	base_local_planner/include/base_local_planner/local_planner_util.h	/^  std::string getGlobalFrame(){ return global_frame_; }$/;"	f	class:base_local_planner::LocalPlannerUtil
getGlobalFrameID	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::string getGlobalFrameID() const$/;"	f	class:costmap_2d::Costmap2DROS
getGlobalFrameID	costmap_2d/include/costmap_2d/layered_costmap.h	/^  std::string getGlobalFrameID() const$/;"	f	class:costmap_2d::LayeredCostmap
getGoal	base_local_planner/src/local_planner_util.cpp	/^bool LocalPlannerUtil::getGoal(geometry_msgs::PoseStamped& goal_pose) {$/;"	f	class:base_local_planner::LocalPlannerUtil
getGoalOrientationAngleDifference	base_local_planner/src/goal_functions.cpp	/^  double getGoalOrientationAngleDifference(const geometry_msgs::PoseStamped& global_pose, double goal_th) {$/;"	f	namespace:base_local_planner
getGoalPose	base_local_planner/src/goal_functions.cpp	/^  bool getGoalPose(const tf2_ros::Buffer& tf,$/;"	f	namespace:base_local_planner
getGoalPositionDistance	base_local_planner/src/goal_functions.cpp	/^  double getGoalPositionDistance(const geometry_msgs::PoseStamped& global_pose, double goal_x, double goal_y) {$/;"	f	namespace:base_local_planner
getIndex	base_local_planner/src/map_grid.cpp	/^  size_t MapGrid::getIndex(int x, int y){$/;"	f	class:base_local_planner::MapGrid
getIndex	costmap_2d/include/costmap_2d/costmap_2d.h	/^  inline unsigned int getIndex(unsigned int mx, unsigned int my) const$/;"	f	class:costmap_2d::Costmap2D
getIndex	global_planner/include/global_planner/traceback.h	/^        inline int getIndex(int x, int y) {$/;"	f	class:global_planner::Traceback
getInscribedRadius	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double getInscribedRadius() { return inscribed_radius_; }$/;"	f	class:costmap_2d::LayeredCostmap
getLastPathCost	navfn/src/navfn.cpp	/^  float NavFn::getLastPathCost()$/;"	f	class:navfn::NavFn
getLayeredCostmap	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  LayeredCostmap* getLayeredCostmap() const$/;"	f	class:costmap_2d::Costmap2DROS
getLineCells	base_local_planner/src/footprint_helper.cpp	/^void FootprintHelper::getLineCells(int x0, int x1, int y0, int y1, std::vector<base_local_planner::Position2DInt>& pts) {$/;"	f	class:base_local_planner::FootprintHelper
getLocalGoal	base_local_planner/src/trajectory_planner.cpp	/^  void TrajectoryPlanner::getLocalGoal(double& x, double& y){$/;"	f	class:base_local_planner::TrajectoryPlanner
getLocalPlan	base_local_planner/src/local_planner_util.cpp	/^bool LocalPlannerUtil::getLocalPlan(const geometry_msgs::PoseStamped& global_pose, std::vector<geometry_msgs::PoseStamped>& transformed_plan) {$/;"	f	class:base_local_planner::LocalPlannerUtil
getMapSize	costmap_2d/src/costmap_2d.cpp	/^    unsigned int Costmap2D::getMapSize() const$/;"	f	class:costmap_2d::Costmap2D
getMarkingObservations	costmap_2d/plugins/obstacle_layer.cpp	/^    bool ObstacleLayer::getMarkingObservations(std::vector<Observation>& marking_observations) const$/;"	f	class:costmap_2d::ObstacleLayer
getMaxSpeedToStopInTime	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      void getMaxSpeedToStopInTime(double time, double& vx, double& vy, double& vth){$/;"	f	class:base_local_planner::TrajectoryPlanner
getMutex	costmap_2d/include/costmap_2d/costmap_2d.h	/^  mutex_t* getMutex()$/;"	f	class:costmap_2d::Costmap2D
getName	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::string getName() const$/;"	f	class:costmap_2d::Costmap2DROS
getName	costmap_2d/include/costmap_2d/layer.h	/^  std::string getName() const$/;"	f	class:costmap_2d::Layer
getNearestInCell	base_local_planner/src/point_grid.cpp	/^  double PointGrid::getNearestInCell(const geometry_msgs::Point32& pt, unsigned int gx, unsigned int gy){$/;"	f	class:base_local_planner::PointGrid
getNearestPoint	global_planner/include/global_planner/gradient_path.h	/^        inline int getNearestPoint(int stc, float dx, float dy) {$/;"	f	class:global_planner::GradientPath
getNumberFromXMLRPC	costmap_2d/src/footprint.cpp	/^double getNumberFromXMLRPC(XmlRpc::XmlRpcValue& value, const std::string& full_param_name)$/;"	f	namespace:costmap_2d
getObservations	costmap_2d/src/observation_buffer.cpp	/^void ObservationBuffer::getObservations(vector<Observation>& observations)$/;"	f	class:costmap_2d::ObservationBuffer
getOdom	base_local_planner/src/odometry_helper_ros.cpp	/^void OdometryHelperRos::getOdom(nav_msgs::Odometry& base_odom) {$/;"	f	class:base_local_planner::OdometryHelperRos
getOdomPose	amcl/src/amcl_node.cpp	/^AmclNode::getOdomPose(geometry_msgs::PoseStamped& odom_pose,$/;"	f	class:AmclNode
getOdomTopic	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  std::string getOdomTopic() const { return odom_topic_; }$/;"	f	class:base_local_planner::OdometryHelperRos
getOrientedFootprint	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::getOrientedFootprint(std::vector<geometry_msgs::Point>& oriented_footprint) const$/;"	f	class:costmap_2d::Costmap2DROS
getOriginX	costmap_2d/src/costmap_2d.cpp	/^    double Costmap2D::getOriginX() const$/;"	f	class:costmap_2d::Costmap2D
getOriginY	costmap_2d/src/costmap_2d.cpp	/^    double Costmap2D::getOriginY() const$/;"	f	class:costmap_2d::Costmap2D
getPath	global_planner/src/gradient_path.cpp	/^bool GradientPath::getPath(float* potential, double start_x, double start_y, double goal_x, double goal_y, std::vector<std::pair<float, float> >& path) {$/;"	f	class:global_planner::GradientPath
getPath	global_planner/src/grid_path.cpp	/^bool GridPath::getPath(float* potential, double start_x, double start_y, double end_x, double end_y, std::vector<std::pair<float, float> >& path) {$/;"	f	class:global_planner::GridPath
getPathLen	navfn/src/navfn.cpp	/^  int    NavFn::getPathLen() { return npath; }$/;"	f	class:navfn::NavFn
getPathX	navfn/src/navfn.cpp	/^  float *NavFn::getPathX() { return pathx; }$/;"	f	class:navfn::NavFn
getPathY	navfn/src/navfn.cpp	/^  float *NavFn::getPathY() { return pathy; }$/;"	f	class:navfn::NavFn
getPlanFromPotential	global_planner/src/planner_core.cpp	/^bool GlobalPlanner::getPlanFromPotential(double start_x, double start_y, double goal_x, double goal_y,$/;"	f	class:global_planner::GlobalPlanner
getPlanFromPotential	navfn/src/navfn_ros.cpp	/^  bool NavfnROS::getPlanFromPotential(const geometry_msgs::PoseStamped& goal, std::vector<geometry_msgs::PoseStamped>& plan){$/;"	f	class:navfn::NavfnROS
getPlanner	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      TrajectoryPlanner* getPlanner() const { return tc_; }$/;"	f	class:base_local_planner::TrajectoryPlannerROS
getPlugins	costmap_2d/include/costmap_2d/layered_costmap.h	/^  std::vector<boost::shared_ptr<Layer> >* getPlugins()$/;"	f	class:costmap_2d::LayeredCostmap
getPoint	base_local_planner/src/trajectory.cpp	/^  void Trajectory::getPoint(unsigned int index, double& x, double& y, double& th) const {$/;"	f	class:base_local_planner::Trajectory
getPointPotential	navfn/src/navfn_ros.cpp	/^  double NavfnROS::getPointPotential(const geometry_msgs::Point& world_point){$/;"	f	class:navfn::NavfnROS
getPoints	base_local_planner/src/point_grid.cpp	/^  void PointGrid::getPoints(sensor_msgs::PointCloud2& cloud){$/;"	f	class:base_local_planner::PointGrid
getPoints	base_local_planner/src/voxel_grid_model.cpp	/^  void VoxelGridModel::getPoints(sensor_msgs::PointCloud2& cloud){$/;"	f	class:base_local_planner::VoxelGridModel
getPointsInRange	base_local_planner/src/point_grid.cpp	/^  void PointGrid::getPointsInRange(const geometry_msgs::Point& lower_left, const geometry_msgs::Point& upper_right,$/;"	f	class:base_local_planner::PointGrid
getPointsSize	base_local_planner/src/trajectory.cpp	/^  unsigned int Trajectory::getPointsSize() const {$/;"	f	class:base_local_planner::Trajectory
getResolution	costmap_2d/src/costmap_2d.cpp	/^    double Costmap2D::getResolution() const$/;"	f	class:costmap_2d::Costmap2D
getRobotFootprint	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::vector<geometry_msgs::Point> getRobotFootprint() const$/;"	f	class:costmap_2d::Costmap2DROS
getRobotFootprintPolygon	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  geometry_msgs::Polygon getRobotFootprintPolygon() const$/;"	f	class:costmap_2d::Costmap2DROS
getRobotPose	costmap_2d/src/costmap_2d_ros.cpp	/^    bool Costmap2DROS::getRobotPose(geometry_msgs::PoseStamped& global_pose) const$/;"	f	class:costmap_2d::Costmap2DROS
getRobotPose	move_base/src/move_base.cpp	/^    bool MoveBase::getRobotPose(geometry_msgs::PoseStamped& global_pose, costmap_2d::Costmap2DROS* costmap)$/;"	f	class:move_base::MoveBase
getRobotVel	base_local_planner/src/odometry_helper_ros.cpp	/^void OdometryHelperRos::getRobotVel(geometry_msgs::PoseStamped& robot_vel) {$/;"	f	class:base_local_planner::OdometryHelperRos
getScale	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^  double getScale() {$/;"	f	class:base_local_planner::TrajectoryCostFunction
getScalingFactor	base_local_planner/src/obstacle_cost_function.cpp	/^    double ObstacleCostFunction::getScalingFactor(Trajectory &traj, double scaling_speed, double max_trans_vel, double max_scaling_factor) {$/;"	f	class:base_local_planner::ObstacleCostFunction
getSimPeriod	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double getSimPeriod() { return sim_period_; }$/;"	f	class:dwa_local_planner::DWAPlanner
getSizeInCellsX	costmap_2d/src/costmap_2d.cpp	/^    unsigned int Costmap2D::getSizeInCellsX() const$/;"	f	class:costmap_2d::Costmap2D
getSizeInCellsY	costmap_2d/src/costmap_2d.cpp	/^    unsigned int Costmap2D::getSizeInCellsY() const$/;"	f	class:costmap_2d::Costmap2D
getSizeInMetersX	costmap_2d/src/costmap_2d.cpp	/^    double Costmap2D::getSizeInMetersX() const$/;"	f	class:costmap_2d::Costmap2D
getSizeInMetersY	costmap_2d/src/costmap_2d.cpp	/^    double Costmap2D::getSizeInMetersY() const$/;"	f	class:costmap_2d::Costmap2D
getSqDistance	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    double MoveSlowAndClear::getSqDistance()$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
getTmpCost	costmap_2d/src/costmap_2d.cpp	/^    unsigned char Costmap2D::getTmpCost(unsigned int mx, unsigned int my) const$/;"	f	class:costmap_2d::Costmap2D
getTransformTolerance	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  double getTransformTolerance() const$/;"	f	class:costmap_2d::Costmap2DROS
getUnpaddedRobotFootprint	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::vector<geometry_msgs::Point> getUnpaddedRobotFootprint() const$/;"	f	class:costmap_2d::Costmap2DROS
getUpdatedBounds	costmap_2d/include/costmap_2d/layered_costmap.h	/^  void getUpdatedBounds(double& minx, double& miny, double& maxx, double& maxy)$/;"	f	class:costmap_2d::LayeredCostmap
getVelocity	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      double getVelocity(){$/;"	f	class:base_local_planner::VelocityIterator
getVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^  static VoxelStatus getVoxel($/;"	f	class:voxel_grid::VoxelGrid
getVoxel	voxel_grid/src/voxel_grid.cpp	/^  VoxelStatus VoxelGrid::getVoxel(unsigned int x, unsigned int y, unsigned int z)$/;"	f	class:voxel_grid::VoxelGrid
getVoxelColumn	voxel_grid/src/voxel_grid.cpp	/^  VoxelStatus VoxelGrid::getVoxelColumn(unsigned int x, unsigned int y, unsigned int unknown_threshold, unsigned int marked_threshold)$/;"	f	class:voxel_grid::VoxelGrid
getX	base_local_planner/include/base_local_planner/line_iterator.h	/^  int getX() const { return x_; }$/;"	f	class:base_local_planner::LineIterator
getX0	base_local_planner/include/base_local_planner/line_iterator.h	/^  int getX0() const { return x0_; }$/;"	f	class:base_local_planner::LineIterator
getX1	base_local_planner/include/base_local_planner/line_iterator.h	/^  int getX1() const { return x1_; }$/;"	f	class:base_local_planner::LineIterator
getY	base_local_planner/include/base_local_planner/line_iterator.h	/^  int getY() const { return y_; }$/;"	f	class:base_local_planner::LineIterator
getY0	base_local_planner/include/base_local_planner/line_iterator.h	/^  int getY0() const { return y0_; }$/;"	f	class:base_local_planner::LineIterator
getY1	base_local_planner/include/base_local_planner/line_iterator.h	/^  int getY1() const { return y1_; }$/;"	f	class:base_local_planner::LineIterator
get_deltas	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::get_deltas(double angle, double *dx, double *dy)$/;"	f	class:range_sensor_layer::RangeSensorLayer
get_distance_map	amcl/src/amcl/map/map_cspace.cpp	/^get_distance_map(double scale, double max_dist)$/;"	f
get_ms	navfn/src/navtest.cpp	/^double get_ms()$/;"	f
globalLocalizationCallback	amcl/src/amcl_node.cpp	/^AmclNode::globalLocalizationCallback(std_srvs::Empty::Request& req,$/;"	f	class:AmclNode
global_costmap_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      costmap_2d::Costmap2DROS* global_costmap_, *local_costmap_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
global_costmap_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      costmap_2d::Costmap2DROS* global_costmap_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
global_frame_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  std::string global_frame_;$/;"	m	class:base_local_planner::LocalPlannerUtil
global_frame_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      std::string global_frame_; \/\/\/< @brief The frame in which the controller will run$/;"	m	class:base_local_planner::TrajectoryPlannerROS
global_frame_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  std::string global_frame_;$/;"	m	class:costmap_2d::Costmap2DPublisher
global_frame_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::string global_frame_;  \/\/\/< @brief The global frame for the costmap$/;"	m	class:costmap_2d::Costmap2DROS
global_frame_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  std::string global_frame_;$/;"	m	class:costmap_2d::LayeredCostmap
global_frame_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  std::string global_frame_;$/;"	m	class:costmap_2d::ObservationBuffer
global_frame_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::string global_frame_;  \/\/\/< @brief The global frame for the costmap$/;"	m	class:costmap_2d::ObstacleLayer
global_frame_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  std::string global_frame_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
global_frame_	costmap_2d/include/costmap_2d/static_layer.h	/^  std::string global_frame_;  \/\/\/< @brief The global frame for the costmap$/;"	m	class:costmap_2d::StaticLayer
global_frame_	move_base/include/move_base/move_base.h	/^      std::string robot_base_frame_, global_frame_;$/;"	m	class:move_base::MoveBase
global_frame_	navfn/include/navfn/navfn_ros.h	/^      std::string global_frame_;$/;"	m	class:navfn::NavfnROS
global_frame_id_	amcl/src/amcl_node.cpp	/^    std::string global_frame_id_;$/;"	m	class:AmclNode	file:
global_frame_id_	fake_localization/fake_localization.cpp	/^    std::string global_frame_id_;$/;"	m	class:FakeOdomNode	file:
global_loc_srv_	amcl/src/amcl_node.cpp	/^    ros::ServiceServer global_loc_srv_;$/;"	m	class:AmclNode	file:
global_plan_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  std::vector<geometry_msgs::PoseStamped> global_plan_;$/;"	m	class:base_local_planner::LocalPlannerUtil
global_plan_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      std::vector<geometry_msgs::PoseStamped> global_plan_; \/\/\/< @brief The global path for the robot to follow$/;"	m	class:base_local_planner::TrajectoryPlanner
global_plan_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      std::vector<geometry_msgs::PoseStamped> global_plan_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
global_plan_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      std::vector<geometry_msgs::PoseStamped> global_plan_;$/;"	m	class:dwa_local_planner::DWAPlanner
global_planner	global_planner/include/global_planner/astar.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/dijkstra.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/expander.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/gradient_path.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/grid_path.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/orientation_filter.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/planner_core.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/potential_calculator.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/quadratic_calculator.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/include/global_planner/traceback.h	/^namespace global_planner {$/;"	n
global_planner	global_planner/src/astar.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/dijkstra.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/gradient_path.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/grid_path.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/orientation_filter.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/plan_node.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/planner_core.cpp	/^namespace global_planner {$/;"	n	file:
global_planner	global_planner/src/quadratic_calculator.cpp	/^namespace global_planner {$/;"	n	file:
global_pose_	move_base/include/move_base/move_base.h	/^      geometry_msgs::PoseStamped global_pose_;$/;"	m	class:move_base::MoveBase
goal	navfn/include/navfn/navfn.h	/^      int goal[2];$/;"	m	class:navfn::NavFn
goal	navfn/include/navfn/navwin.h	/^      int goal[2];$/;"	m	class:navfn::NavWin
goal	navfn/src/navtest.cpp	/^int goal[2];$/;"	v
goalCB	move_base/src/move_base.cpp	/^    void MoveBase::goalCB(const geometry_msgs::PoseStamped::ConstPtr& goal){$/;"	f	class:move_base::MoveBase
goalToGlobalFrame	move_base/src/move_base.cpp	/^    geometry_msgs::PoseStamped MoveBase::goalToGlobalFrame(const geometry_msgs::PoseStamped& goal_pose_msg){$/;"	f	class:move_base::MoveBase
goal_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::MapGridCostFunction goal_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
goal_distance_bias_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double path_distance_bias_, goal_distance_bias_, occdist_scale_; \/\/\/< @brief Scaling factors for the controller's cost function$/;"	m	class:base_local_planner::TrajectoryPlanner
goal_distance_bias_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double path_distance_bias_, goal_distance_bias_, occdist_scale_;$/;"	m	class:dwa_local_planner::DWAPlanner
goal_front_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::MapGridCostFunction goal_front_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
goal_map_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      MapGrid goal_map_; \/\/\/< @brief The local map grid where we propagate goal distance$/;"	m	class:base_local_planner::TrajectoryPlanner
goal_sub_	move_base/include/move_base/move_base.h	/^      ros::Subscriber goal_sub_;$/;"	m	class:move_base::MoveBase
goal_x_	base_local_planner/include/base_local_planner/map_grid.h	/^      double goal_x_, goal_y_; \/**< @brief The goal distance was last computed from *\/$/;"	m	class:base_local_planner::MapGrid
goal_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double goal_x_,goal_y_; \/\/\/< @brief Storage for the local goal the robot is pursuing$/;"	m	class:base_local_planner::TrajectoryPlanner
goal_y_	base_local_planner/include/base_local_planner/map_grid.h	/^      double goal_x_, goal_y_; \/**< @brief The goal distance was last computed from *\/$/;"	m	class:base_local_planner::MapGrid
goal_y_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double goal_x_,goal_y_; \/\/\/< @brief Storage for the local goal the robot is pursuing$/;"	m	class:base_local_planner::TrajectoryPlanner
got_map_	map_server/test/rtest.cpp	/^    bool got_map_;$/;"	m	class:MapClientTest	file:
got_map_metadata_	map_server/test/rtest.cpp	/^    bool got_map_metadata_;$/;"	m	class:MapClientTest	file:
gradCell	global_planner/src/gradient_path.cpp	/^float GradientPath::gradCell(float* potential, int n) {$/;"	f	class:global_planner::GradientPath
gradCell	navfn/src/navfn.cpp	/^    NavFn::gradCell(int n)$/;"	f	class:navfn::NavFn
gradx	navfn/include/navfn/navfn.h	/^      float *gradx, *grady;		\/**< gradient arrays, size of potential array *\/$/;"	m	class:navfn::NavFn
gradx_	global_planner/include/global_planner/gradient_path.h	/^        float *gradx_, *grady_; \/**< gradient arrays, size of potential array *\/$/;"	m	class:global_planner::GradientPath
grady	navfn/include/navfn/navfn.h	/^      float *gradx, *grady;		\/**< gradient arrays, size of potential array *\/$/;"	m	class:navfn::NavFn
grady_	global_planner/include/global_planner/gradient_path.h	/^        float *gradx_, *grady_; \/**< gradient arrays, size of potential array *\/$/;"	m	class:global_planner::GradientPath
greater1	global_planner/include/global_planner/astar.h	/^struct greater1 {$/;"	s	namespace:global_planner
gridCoords	base_local_planner/include/base_local_planner/point_grid.h	/^      inline bool gridCoords(const geometry_msgs::Point32& pt, unsigned int& gx, unsigned int& gy) const {$/;"	f	class:base_local_planner::PointGrid
gridCoords	base_local_planner/include/base_local_planner/point_grid.h	/^      inline bool gridCoords(geometry_msgs::Point pt, unsigned int& gx, unsigned int& gy) const {$/;"	f	class:base_local_planner::PointGrid
gridIndex	base_local_planner/include/base_local_planner/point_grid.h	/^      inline unsigned int gridIndex(unsigned int gx, unsigned int gy) const {$/;"	f	class:base_local_planner::PointGrid
grid_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  nav_msgs::OccupancyGrid grid_;$/;"	m	class:costmap_2d::Costmap2DPublisher
gui_publish_period	amcl/src/amcl_node.cpp	/^    ros::Duration gui_publish_period;$/;"	m	class:AmclNode	file:
handleInitialPoseMessage	amcl/src/amcl_node.cpp	/^AmclNode::handleInitialPoseMessage(const geometry_msgs::PoseWithCovarianceStamped& msg)$/;"	f	class:AmclNode
handleMapMessage	amcl/src/amcl_node.cpp	/^AmclNode::handleMapMessage(const nav_msgs::OccupancyGrid& msg)$/;"	f	class:AmclNode
hasMoreTrajectories	base_local_planner/src/simple_trajectory_generator.cpp	/^bool SimpleTrajectoryGenerator::hasMoreTrajectories() {$/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
has_extra_bounds_	costmap_2d/include/costmap_2d/costmap_layer.h	/^  bool has_extra_bounds_;$/;"	m	class:costmap_2d::CostmapLayer
has_updated_data_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool has_updated_data_;$/;"	m	class:costmap_2d::StaticLayer
headingDiff	base_local_planner/src/trajectory_planner.cpp	/^  double TrajectoryPlanner::headingDiff(int cell_x, int cell_y, double x, double y, double heading){$/;"	f	class:base_local_planner::TrajectoryPlanner
heading_lookahead_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double heading_lookahead_; \/\/\/< @brief How far the robot should look ahead of itself when differentiating between different rotational velocities$/;"	m	class:base_local_planner::TrajectoryPlanner
heading_scoring_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool heading_scoring_; \/\/\/< @brief Should we score based on the rollout approach or the heading approach$/;"	m	class:base_local_planner::TrajectoryPlanner
heading_scoring_timestep_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double heading_scoring_timestep_; \/\/\/< @brief How far to look ahead in time when we score a heading$/;"	m	class:base_local_planner::TrajectoryPlanner
height_	base_local_planner/include/base_local_planner/point_grid.h	/^      unsigned int height_; \/\/\/< @brief The height of the grid in cells$/;"	m	class:base_local_planner::PointGrid
height_	costmap_2d/include/costmap_2d/static_layer.h	/^  unsigned int x_, y_, width_, height_;$/;"	m	class:costmap_2d::StaticLayer
holonomic_robot_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool holonomic_robot_; \/\/\/< @brief Is the robot holonomic or not? $/;"	m	class:base_local_planner::TrajectoryPlanner
hypot2	amcl/src/amcl/pf/eig3.c	/^static double hypot2(double x, double y) {$/;"	f	file:
i	global_planner/include/global_planner/astar.h	/^        int i;$/;"	m	class:global_planner::Index
i_	amcl/src/amcl/map/map_cspace.cpp	/^    unsigned int i_, j_;$/;"	m	class:CellData	file:
im	navfn/include/navfn/navwin.h	/^      uchar *im;			\/\/ image for drawing$/;"	m	class:navfn::NavWin
inc	navfn/include/navfn/navwin.h	/^      int dec, inc;			\/\/ decimation or expansion for display$/;"	m	class:navfn::NavWin
incomingMap	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::incomingMap(const nav_msgs::OccupancyGridConstPtr& new_map)$/;"	f	class:costmap_2d::StaticLayer
incomingUpdate	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::incomingUpdate(const map_msgs::OccupancyGridUpdateConstPtr& update)$/;"	f	class:costmap_2d::StaticLayer
indexToCells	costmap_2d/include/costmap_2d/costmap_2d.h	/^  inline void indexToCells(unsigned int index, unsigned int& mx, unsigned int& my) const$/;"	f	class:costmap_2d::Costmap2D
indexToWorld	costmap_2d/test/module_tests.cpp	/^void indexToWorld(Costmap2D& map, unsigned int index, double& wx, double& wy){$/;"	f
index_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int index_;$/;"	m	class:costmap_2d::CellData
inflate_cone_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double inflate_cone_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
inflate_unknown_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  bool inflate_unknown_;$/;"	m	class:costmap_2d::InflationLayer
inflation_access_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  boost::recursive_mutex* inflation_access_;$/;"	m	class:costmap_2d::InflationLayer
inflation_cells_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  std::map<double, std::vector<CellData> > inflation_cells_;$/;"	m	class:costmap_2d::InflationLayer
inflation_radius_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double inflation_radius_;$/;"	m	class:costmap_2d::InflationLayer
initCost	navfn/src/navfn.cpp	/^    NavFn::initCost(int k, float v)$/;"	f	class:navfn::NavFn
initMaps	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::initMaps(unsigned int size_x, unsigned int size_y)$/;"	f	class:costmap_2d::Costmap2D
initPoseReceived	fake_localization/fake_localization.cpp	/^    void initPoseReceived(const geometry_msgs::PoseWithCovarianceStampedConstPtr& msg){$/;"	f	class:FakeOdomNode
init_cov_	amcl/src/amcl_node.cpp	/^    double init_cov_[3];$/;"	m	class:AmclNode	file:
init_pose_	amcl/src/amcl_node.cpp	/^    double init_pose_[3];$/;"	m	class:AmclNode	file:
initialPoseReceived	amcl/src/amcl_node.cpp	/^AmclNode::initialPoseReceived(const geometry_msgs::PoseWithCovarianceStampedConstPtr& msg)$/;"	f	class:AmclNode
initial_pose_hyp_	amcl/src/amcl_node.cpp	/^    amcl_hyp_t* initial_pose_hyp_;$/;"	m	class:AmclNode	file:
initial_pose_sub_	amcl/src/amcl_node.cpp	/^    ros::Subscriber initial_pose_sub_;$/;"	m	class:AmclNode	file:
initial_pose_sub_old_	amcl/src/amcl_node.cpp	/^    ros::Subscriber initial_pose_sub_old_;$/;"	m	class:AmclNode	file:
initialise	base_local_planner/src/simple_trajectory_generator.cpp	/^void SimpleTrajectoryGenerator::initialise($/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
initialize	base_local_planner/src/local_planner_util.cpp	/^void LocalPlannerUtil::initialize($/;"	f	class:base_local_planner::LocalPlannerUtil
initialize	base_local_planner/src/map_grid_visualizer.cpp	/^  void MapGridVisualizer::initialize(const std::string& name, std::string frame_id, boost::function<bool (int cx, int cy, float &path_cost, float &goal_cost, float &occ_cost, float &total_cost)> cost_function) {$/;"	f	class:base_local_planner::MapGridVisualizer
initialize	base_local_planner/src/trajectory_planner_ros.cpp	/^  void TrajectoryPlannerROS::initialize($/;"	f	class:base_local_planner::TrajectoryPlannerROS
initialize	carrot_planner/src/carrot_planner.cpp	/^  void CarrotPlanner::initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros){$/;"	f	class:carrot_planner::CarrotPlanner
initialize	clear_costmap_recovery/src/clear_costmap_recovery.cpp	/^            void ClearCostmapRecovery::initialize(std::string name, tf2_ros::Buffer* tf,$/;"	f	class:clear_costmap_recovery::ClearCostmapRecovery
initialize	costmap_2d/src/layer.cpp	/^void Layer::initialize(LayeredCostmap* parent, std::string name, tf2_ros::Buffer *tf)$/;"	f	class:costmap_2d::Layer
initialize	dwa_local_planner/src/dwa_planner_ros.cpp	/^            void DWAPlannerROS::initialize($/;"	f	class:dwa_local_planner::DWAPlannerROS
initialize	global_planner/src/planner_core.cpp	/^void GlobalPlanner::initialize(std::string name, costmap_2d::Costmap2D* costmap, std::string frame_id) {$/;"	f	class:global_planner::GlobalPlanner
initialize	global_planner/src/planner_core.cpp	/^void GlobalPlanner::initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros) {$/;"	f	class:global_planner::GlobalPlanner
initialize	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    void MoveSlowAndClear::initialize (std::string n, tf2_ros::Buffer* tf,$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
initialize	navfn/src/navfn_ros.cpp	/^  void NavfnROS::initialize(std::string name, costmap_2d::Costmap2D* costmap, std::string global_frame){$/;"	f	class:navfn::NavfnROS
initialize	navfn/src/navfn_ros.cpp	/^  void NavfnROS::initialize(std::string name, costmap_2d::Costmap2DROS* costmap_ros){$/;"	f	class:navfn::NavfnROS
initialize	rotate_recovery/src/rotate_recovery.cpp	/^    void RotateRecovery::initialize(std::string name, tf2_ros::Buffer*,$/;"	f	class:rotate_recovery::RotateRecovery
initialized_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  bool initialized_;$/;"	m	class:base_local_planner::LocalPlannerUtil
initialized_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool initialized_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
initialized_	carrot_planner/include/carrot_planner/carrot_planner.h	/^      bool initialized_;$/;"	m	class:carrot_planner::CarrotPlanner
initialized_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      bool initialized_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
initialized_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool stop_updates_, initialized_, stopped_, robot_stopped_;$/;"	m	class:costmap_2d::Costmap2DROS
initialized_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool initialized_;$/;"	m	class:costmap_2d::LayeredCostmap
initialized_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      bool initialized_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
initialized_	global_planner/include/global_planner/planner_core.h	/^        bool initialized_, allow_unknown_;$/;"	m	class:global_planner::GlobalPlanner
initialized_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      bool initialized_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
initialized_	navfn/include/navfn/navfn_ros.h	/^      bool initialized_, allow_unknown_, visualize_potential_;$/;"	m	class:navfn::NavfnROS
initialized_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  bool initialized_;$/;"	m	class:rotate_recovery::RotateRecovery
inscribed_radius_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double inscribed_radius_, circumscribed_radius_;$/;"	m	class:base_local_planner::TrajectoryPlanner
inscribed_radius_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double inscribed_radius_;$/;"	m	class:costmap_2d::InflationLayer
inscribed_radius_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double circumscribed_radius_, inscribed_radius_;$/;"	m	class:costmap_2d::LayeredCostmap
inscribed_radius_	move_base/include/move_base/move_base.h	/^      double planner_frequency_, controller_frequency_, inscribed_radius_, circumscribed_radius_;$/;"	m	class:move_base::MoveBase
insert	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      inline void insert(const geometry_msgs::Point32& pt){$/;"	f	class:base_local_planner::VoxelGridModel
insert	base_local_planner/src/point_grid.cpp	/^  void PointGrid::insert(const geometry_msgs::Point32& pt){$/;"	f	class:base_local_planner::PointGrid
interpolate	global_planner/src/orientation_filter.cpp	/^void OrientationFilter::interpolate(std::vector<geometry_msgs::PoseStamped>& path, $/;"	f	class:global_planner::OrientationFilter
interpretValue	costmap_2d/plugins/static_layer.cpp	/^    unsigned char StaticLayer::interpretValue(unsigned char value)$/;"	f	class:costmap_2d::StaticLayer
intersectionPoint	base_local_planner/src/point_grid.cpp	/^  void PointGrid::intersectionPoint(const geometry_msgs::Point& v1, const geometry_msgs::Point& v2,$/;"	f	class:base_local_planner::PointGrid
intersects	costmap_2d/src/costmap_math.cpp	/^bool intersects(std::vector<geometry_msgs::Point>& polygon, float testx, float testy)$/;"	f
intersects	costmap_2d/src/costmap_math.cpp	/^bool intersects(std::vector<geometry_msgs::Point>& polygon1, std::vector<geometry_msgs::Point>& polygon2)$/;"	f
intersects_helper	costmap_2d/src/costmap_math.cpp	/^bool intersects_helper(std::vector<geometry_msgs::Point>& polygon1, std::vector<geometry_msgs::Point>& polygon2)$/;"	f
invert_area_to_clear_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      bool invert_area_to_clear_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
isCurrent	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool isCurrent() const$/;"	f	class:costmap_2d::Costmap2DROS
isCurrent	costmap_2d/include/costmap_2d/layer.h	/^  bool isCurrent() const$/;"	f	class:costmap_2d::Layer
isCurrent	costmap_2d/src/layered_costmap.cpp	/^    bool LayeredCostmap::isCurrent()$/;"	f	class:costmap_2d::LayeredCostmap
isCurrent	costmap_2d/src/observation_buffer.cpp	/^bool ObservationBuffer::isCurrent() const$/;"	f	class:costmap_2d::ObservationBuffer
isDiscretized	costmap_2d/include/costmap_2d/costmap_layer.h	/^  bool isDiscretized()$/;"	f	class:costmap_2d::CostmapLayer
isDiscretized	costmap_2d/include/costmap_2d/inflation_layer.h	/^  virtual bool isDiscretized()$/;"	f	class:costmap_2d::InflationLayer
isDiscretized	costmap_2d/include/costmap_2d/voxel_layer.h	/^  bool isDiscretized()$/;"	f	class:costmap_2d::VoxelLayer
isFinished	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      bool isFinished(){$/;"	f	class:base_local_planner::VelocityIterator
isGoalReached	base_local_planner/src/goal_functions.cpp	/^  bool isGoalReached(const tf2_ros::Buffer& tf,$/;"	f	namespace:base_local_planner
isGoalReached	base_local_planner/src/latched_stop_rotate_controller.cpp	/^bool LatchedStopRotateController::isGoalReached(LocalPlannerUtil* planner_util,$/;"	f	class:base_local_planner::LatchedStopRotateController
isGoalReached	base_local_planner/src/trajectory_planner_ros.cpp	/^  bool TrajectoryPlannerROS::isGoalReached() {$/;"	f	class:base_local_planner::TrajectoryPlannerROS
isGoalReached	dwa_local_planner/src/dwa_planner_ros.cpp	/^            bool DWAPlannerROS::isGoalReached() {$/;"	f	class:dwa_local_planner::DWAPlannerROS
isInitialized	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool isInitialized() {$/;"	f	class:base_local_planner::TrajectoryPlannerROS
isInitialized	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool isInitialized()$/;"	f	class:costmap_2d::LayeredCostmap
isInitialized	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      bool isInitialized() {$/;"	f	class:dwa_local_planner::DWAPlannerROS
isPositionReached	base_local_planner/src/latched_stop_rotate_controller.cpp	/^bool LatchedStopRotateController::isPositionReached(LocalPlannerUtil* planner_util,$/;"	f	class:base_local_planner::LatchedStopRotateController
isQuaternionValid	move_base/src/move_base.cpp	/^    bool MoveBase::isQuaternionValid(const geometry_msgs::Quaternion& q){$/;"	f	class:move_base::MoveBase
isRolling	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool isRolling()$/;"	f	class:costmap_2d::LayeredCostmap
isSizeLocked	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool isSizeLocked()$/;"	f	class:costmap_2d::LayeredCostmap
isStopped	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool isStopped() const$/;"	f	class:costmap_2d::Costmap2DROS
isTrackingUnknown	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool isTrackingUnknown()$/;"	f	class:costmap_2d::LayeredCostmap
isValid	base_local_planner/include/base_local_planner/line_iterator.h	/^  bool isValid() const$/;"	f	class:base_local_planner::LineIterator
is_action	amcl/include/amcl/sensors/amcl_sensor.h	/^  public: bool is_action;$/;"	m	class:amcl::AMCLSensor
is_local_goal_function_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  bool is_local_goal_function_;$/;"	m	class:base_local_planner::MapGridCostFunction
j_	amcl/src/amcl/map/map_cspace.cpp	/^    unsigned int i_, j_;$/;"	m	class:CellData	file:
kdtree	amcl/include/amcl/pf/pf.h	/^  pf_kdtree_t *kdtree;$/;"	m	struct:_pf_sample_set_t
key	amcl/include/amcl/pf/pf_kdtree.h	/^  int key[3];$/;"	m	struct:pf_kdtree_node
l_plan_pub_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      ros::Publisher g_plan_pub_, l_plan_pub_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
l_plan_pub_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      ros::Publisher g_plan_pub_, l_plan_pub_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
lambda_short	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double lambda_short;$/;"	m	class:amcl::AMCLLaser
lambda_short_	amcl/src/amcl_node.cpp	/^    double z_hit_, z_short_, z_max_, z_rand_, sigma_hit_, lambda_short_;$/;"	m	class:AmclNode	file:
laserReceived	amcl/src/amcl_node.cpp	/^AmclNode::laserReceived(const sensor_msgs::LaserScanConstPtr& laser_scan)$/;"	f	class:AmclNode
laserScanCallback	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::laserScanCallback(const sensor_msgs::LaserScanConstPtr& message,$/;"	f	class:costmap_2d::ObstacleLayer
laserScanValidInfCallback	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::laserScanValidInfCallback(const sensor_msgs::LaserScanConstPtr& raw_message,$/;"	f	class:costmap_2d::ObstacleLayer
laser_	amcl/src/amcl_node.cpp	/^    AMCLLaser* laser_;$/;"	m	class:AmclNode	file:
laser_check_interval_	amcl/src/amcl_node.cpp	/^    ros::Duration laser_check_interval_;$/;"	m	class:AmclNode	file:
laser_likelihood_max_dist_	amcl/src/amcl_node.cpp	/^    double laser_likelihood_max_dist_;$/;"	m	class:AmclNode	file:
laser_max_range_	amcl/src/amcl_node.cpp	/^    double laser_max_range_;$/;"	m	class:AmclNode	file:
laser_min_range_	amcl/src/amcl_node.cpp	/^    double laser_min_range_;$/;"	m	class:AmclNode	file:
laser_model_t	amcl/include/amcl/sensors/amcl_laser.h	/^} laser_model_t;$/;"	t	namespace:amcl	typeref:enum:amcl::__anon10
laser_model_type_	amcl/src/amcl_node.cpp	/^    laser_model_t laser_model_type_;$/;"	m	class:AmclNode	file:
laser_pose	amcl/include/amcl/sensors/amcl_laser.h	/^  private: pf_vector_t laser_pose;$/;"	m	class:amcl::AMCLLaser
laser_scan_filter_	amcl/src/amcl_node.cpp	/^    tf2_ros::MessageFilter<sensor_msgs::LaserScan>* laser_scan_filter_;$/;"	m	class:AmclNode	file:
laser_scan_sub_	amcl/src/amcl_node.cpp	/^    message_filters::Subscriber<sensor_msgs::LaserScan>* laser_scan_sub_;$/;"	m	class:AmclNode	file:
lasers_	amcl/src/amcl_node.cpp	/^    std::vector< AMCLLaser* > lasers_;$/;"	m	class:AmclNode	file:
lasers_update_	amcl/src/amcl_node.cpp	/^    std::vector< bool > lasers_update_;$/;"	m	class:AmclNode	file:
last_cloud_pub_time	amcl/src/amcl_node.cpp	/^    ros::Time last_cloud_pub_time;$/;"	m	class:AmclNode	file:
last_config_	move_base/include/move_base/move_base.h	/^      move_base::MoveBaseConfig last_config_;$/;"	m	class:move_base::MoveBase
last_laser_received_ts_	amcl/src/amcl_node.cpp	/^    ros::Time last_laser_received_ts_;$/;"	m	class:AmclNode	file:
last_max_x_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double last_min_x_, last_min_y_, last_max_x_, last_max_y_;$/;"	m	class:costmap_2d::InflationLayer
last_max_y_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double last_min_x_, last_min_y_, last_max_x_, last_max_y_;$/;"	m	class:costmap_2d::InflationLayer
last_min_x_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double last_min_x_, last_min_y_, last_max_x_, last_max_y_;$/;"	m	class:costmap_2d::InflationLayer
last_min_y_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double last_min_x_, last_min_y_, last_max_x_, last_max_y_;$/;"	m	class:costmap_2d::InflationLayer
last_oscillation_reset_	move_base/include/move_base/move_base.h	/^      ros::Time last_valid_plan_, last_valid_control_, last_oscillation_reset_;$/;"	m	class:move_base::MoveBase
last_path_cost_	navfn/include/navfn/navfn.h	/^      float last_path_cost_; \/**< Holds the cost of the path found the last time A* was called *\/$/;"	m	class:navfn::NavFn
last_publish_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  ros::Time last_publish_;$/;"	m	class:costmap_2d::Costmap2DROS
last_published_pose	amcl/src/amcl_node.cpp	/^    geometry_msgs::PoseWithCovarianceStamped last_published_pose;$/;"	m	class:AmclNode	file:
last_reading_time_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  ros::Time last_reading_time_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
last_updated_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  ros::Time last_updated_;$/;"	m	class:costmap_2d::ObservationBuffer
last_valid_control_	move_base/include/move_base/move_base.h	/^      ros::Time last_valid_plan_, last_valid_control_, last_oscillation_reset_;$/;"	m	class:move_base::MoveBase
last_valid_plan_	move_base/include/move_base/move_base.h	/^      ros::Time last_valid_plan_, last_valid_control_, last_oscillation_reset_;$/;"	m	class:move_base::MoveBase
latch_xy_goal_tolerance_	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^  bool latch_xy_goal_tolerance_, xy_tolerance_latch_;$/;"	m	class:base_local_planner::LatchedStopRotateController
latch_xy_goal_tolerance_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool latch_xy_goal_tolerance_, xy_tolerance_latch_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
latchedStopRotateController_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      base_local_planner::LatchedStopRotateController latchedStopRotateController_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
latest_odom_pose_	amcl/src/amcl_node.cpp	/^    geometry_msgs::PoseStamped latest_odom_pose_;$/;"	m	class:AmclNode	file:
latest_plan_	move_base/include/move_base/move_base.h	/^      std::vector<geometry_msgs::PoseStamped>* latest_plan_;$/;"	m	class:move_base::MoveBase
latest_tf_	amcl/src/amcl_node.cpp	/^    tf2::Transform latest_tf_;$/;"	m	class:AmclNode	file:
latest_tf_valid_	amcl/src/amcl_node.cpp	/^    bool latest_tf_valid_;$/;"	m	class:AmclNode	file:
layered_costmap_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  LayeredCostmap* layered_costmap_;$/;"	m	class:costmap_2d::Costmap2DROS
layered_costmap_	costmap_2d/include/costmap_2d/layer.h	/^  LayeredCostmap* layered_costmap_;$/;"	m	class:costmap_2d::Layer
leaf	amcl/include/amcl/pf/pf_kdtree.h	/^  int leaf, depth;$/;"	m	struct:pf_kdtree_node
leaf_count	amcl/include/amcl/pf/pf_kdtree.h	/^  int leaf_count;$/;"	m	struct:__anon8
lethal_cost_	global_planner/include/global_planner/expander.h	/^        unsigned char lethal_cost_, neutral_cost_;$/;"	m	class:global_planner::Expander
lethal_cost_	global_planner/include/global_planner/traceback.h	/^        unsigned char lethal_cost_;$/;"	m	class:global_planner::Traceback
lethal_threshold_	costmap_2d/include/costmap_2d/static_layer.h	/^  unsigned char lethal_threshold_, unknown_cost_value_;$/;"	m	class:costmap_2d::StaticLayer
limit_cache	amcl/include/amcl/pf/pf.h	/^  int *limit_cache;$/;"	m	struct:_pf_t
limit_set_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      bool limit_set_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
limited_distance_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      double clearing_distance_, limited_distance_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
limited_rot_speed_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      double limited_trans_speed_, limited_rot_speed_, old_trans_speed_, old_rot_speed_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
limited_trans_speed_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      double limited_trans_speed_, limited_rot_speed_, old_trans_speed_, old_rot_speed_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
limits_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  LocalPlannerLimits limits_;$/;"	m	class:base_local_planner::LocalPlannerUtil
limits_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  base_local_planner::LocalPlannerLimits* limits_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
limits_configuration_mutex_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  boost::mutex limits_configuration_mutex_;$/;"	m	class:base_local_planner::LocalPlannerUtil
lineCost	base_local_planner/src/costmap_model.cpp	/^    double CostmapModel::lineCost(int x0, int x1, int y0, int y1) const {$/;"	f	class:base_local_planner::CostmapModel
lineCost	base_local_planner/src/trajectory_planner.cpp	/^  double TrajectoryPlanner::lineCost(int x0, int x1,$/;"	f	class:base_local_planner::TrajectoryPlanner
lineCost	base_local_planner/src/voxel_grid_model.cpp	/^  double VoxelGridModel::lineCost(int x0, int x1, $/;"	f	class:base_local_planner::VoxelGridModel
lineCostInflation	base_local_planner/src/costmap_model.cpp	/^    double CostmapModel::lineCostInflation(int x0, int x1, int y0, int y1) const {$/;"	f	class:base_local_planner::CostmapModel
lmt	amcl/cfg/AMCL.cfg	/^lmt = gen.enum([gen.const("beam_const", str_t, "beam", "Use beam laser model"), gen.const("likelihood_field_const", str_t, "likelihood_field", "Use likelihood_field laser model"), gen.const("likelihood_field_prob", str_t, "likelihood_field_prob", "Use likelihood_field_prob laser model")], "Laser Models")$/;"	v
loadDefaultRecoveryBehaviors	move_base/src/move_base.cpp	/^    void MoveBase::loadDefaultRecoveryBehaviors(){$/;"	f	class:move_base::MoveBase
loadMapFromFile	map_server/src/image_loader.cpp	/^loadMapFromFile(nav_msgs::GetMap::Response* resp,$/;"	f	namespace:map_server
loadOldParameters	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::loadOldParameters(ros::NodeHandle& nh)$/;"	f	class:costmap_2d::Costmap2DROS
loadParameterWithDeprecation	nav_core/include/nav_core/parameter_magic.h	/^param_t loadParameterWithDeprecation(const ros::NodeHandle& nh, const std::string current_name,$/;"	f	namespace:nav_core
loadRecoveryBehaviors	move_base/src/move_base.cpp	/^    bool MoveBase::loadRecoveryBehaviors(ros::NodeHandle node){$/;"	f	class:move_base::MoveBase
loadYVels	base_local_planner/src/trajectory_planner_ros.cpp	/^  std::vector<double> TrajectoryPlannerROS::loadYVels(ros::NodeHandle node){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
local_costmap_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      costmap_2d::Costmap2DROS* global_costmap_, *local_costmap_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
local_costmap_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      costmap_2d::Costmap2DROS* local_costmap_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
local_costmap_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  costmap_2d::Costmap2DROS* local_costmap_;$/;"	m	class:rotate_recovery::RotateRecovery
lock	costmap_2d/include/costmap_2d/observation_buffer.h	/^  inline void lock()$/;"	f	class:costmap_2d::ObservationBuffer
lock_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  boost::recursive_mutex lock_;  \/\/\/< @brief A lock for accessing data in callbacks safely$/;"	m	class:costmap_2d::ObservationBuffer
m	amcl/include/amcl/pf/pf.h	/^  double m[4], c[2][2];$/;"	m	struct:__anon4
m	amcl/include/amcl/pf/pf_vector.h	/^  double m[3][3];$/;"	m	struct:__anon6
m_basePosMsg	fake_localization/fake_localization.cpp	/^    nav_msgs::Odometry  m_basePosMsg;$/;"	m	class:FakeOdomNode	file:
m_base_pos_received	fake_localization/fake_localization.cpp	/^    bool                           m_base_pos_received;$/;"	m	class:FakeOdomNode	file:
m_currentPos	fake_localization/fake_localization.cpp	/^    geometry_msgs::PoseWithCovarianceStamped      m_currentPos;$/;"	m	class:FakeOdomNode	file:
m_force_update	amcl/src/amcl_node.cpp	/^    bool m_force_update;  \/\/ used to temporarily let amcl update samples even when no motion occurs...$/;"	m	class:AmclNode	file:
m_initPoseFilter	fake_localization/fake_localization.cpp	/^    tf2_ros::MessageFilter<geometry_msgs::PoseWithCovarianceStamped>* m_initPoseFilter;$/;"	m	class:FakeOdomNode	file:
m_initPoseSub	fake_localization/fake_localization.cpp	/^    message_filters::Subscriber<geometry_msgs::PoseWithCovarianceStamped>* m_initPoseSub;$/;"	m	class:FakeOdomNode	file:
m_nh	fake_localization/fake_localization.cpp	/^    ros::NodeHandle m_nh;$/;"	m	class:FakeOdomNode	file:
m_offsetTf	fake_localization/fake_localization.cpp	/^    tf2::Transform m_offsetTf;$/;"	m	class:FakeOdomNode	file:
m_particleCloud	fake_localization/fake_localization.cpp	/^    geometry_msgs::PoseArray      m_particleCloud;$/;"	m	class:FakeOdomNode	file:
m_particlecloudPub	fake_localization/fake_localization.cpp	/^    ros::Publisher m_particlecloudPub;$/;"	m	class:FakeOdomNode	file:
m_posePub	fake_localization/fake_localization.cpp	/^    ros::Publisher m_posePub;$/;"	m	class:FakeOdomNode	file:
m_tfBuffer	fake_localization/fake_localization.cpp	/^    tf2_ros::Buffer                     *m_tfBuffer;$/;"	m	class:FakeOdomNode	file:
m_tfListener	fake_localization/fake_localization.cpp	/^    tf2_ros::TransformListener          *m_tfListener;$/;"	m	class:FakeOdomNode	file:
m_tfServer	fake_localization/fake_localization.cpp	/^    tf2_ros::TransformBroadcaster       *m_tfServer;$/;"	m	class:FakeOdomNode	file:
main	amcl/src/amcl_node.cpp	/^main(int argc, char** argv)$/;"	f
main	base_local_planner/src/point_grid_node.cpp	/^int main(int argc, char** argv){$/;"	f
main	base_local_planner/test/gtest_main.cpp	/^int main(int argc, char **argv) {$/;"	f
main	base_local_planner/test/line_iterator_test.cpp	/^int main( int argc, char **argv ) {$/;"	f
main	clear_costmap_recovery/test/clear_tester.cpp	/^int main(int argc, char** argv){$/;"	f
main	costmap_2d/src/costmap_2d_cloud.cpp	/^int main(int argc, char** argv)$/;"	f
main	costmap_2d/src/costmap_2d_markers.cpp	/^int main(int argc, char** argv)$/;"	f
main	costmap_2d/src/costmap_2d_node.cpp	/^int main(int argc, char** argv)$/;"	f
main	costmap_2d/test/array_parser_test.cpp	/^int main(int argc, char** argv)$/;"	f
main	costmap_2d/test/coordinates_test.cpp	/^int main(int argc, char** argv)$/;"	f
main	costmap_2d/test/costmap_tester.cpp	/^int main(int argc, char** argv){$/;"	f
main	costmap_2d/test/footprint_tests.cpp	/^int main(int argc, char** argv)$/;"	f
main	costmap_2d/test/inflation_tests.cpp	/^int main(int argc, char** argv){$/;"	f
main	costmap_2d/test/module_tests.cpp	/^int main(int argc, char** argv){$/;"	f
main	costmap_2d/test/obstacle_tests.cpp	/^int main(int argc, char** argv){$/;"	f
main	costmap_2d/test/static_tests.cpp	/^int main(int argc, char** argv){$/;"	f
main	fake_localization/fake_localization.cpp	/^int main(int argc, char** argv)$/;"	f
main	global_planner/src/plan_node.cpp	/^int main(int argc, char** argv) {$/;"	f
main	map_server/src/main.cpp	/^int main(int argc, char **argv)$/;"	f
main	map_server/src/map_saver.cpp	/^int main(int argc, char** argv)$/;"	f
main	map_server/test/rtest.cpp	/^int main(int argc, char **argv)$/;"	f
main	map_server/test/utest.cpp	/^int main(int argc, char **argv)$/;"	f
main	move_base/src/move_base_node.cpp	/^int main(int argc, char** argv){$/;"	f
main	navfn/src/navfn_node.cpp	/^int main (int argc, char** argv)$/;"	f
main	navfn/src/navtest.cpp	/^int main(int argc, char **argv)$/;"	f
main	navfn/test/path_calc_test.cpp	/^int main(int argc, char **argv)$/;"	f
main	voxel_grid/test/voxel_grid_tests.cpp	/^int main(int argc, char** argv){$/;"	f
makeFootprintFromParams	costmap_2d/src/footprint.cpp	/^std::vector<geometry_msgs::Point> makeFootprintFromParams(ros::NodeHandle& nh)$/;"	f	namespace:costmap_2d
makeFootprintFromRadius	costmap_2d/src/footprint.cpp	/^std::vector<geometry_msgs::Point> makeFootprintFromRadius(double radius)$/;"	f	namespace:costmap_2d
makeFootprintFromString	costmap_2d/src/footprint.cpp	/^bool makeFootprintFromString(const std::string& footprint_string, std::vector<geometry_msgs::Point>& footprint)$/;"	f	namespace:costmap_2d
makeFootprintFromXMLRPC	costmap_2d/src/footprint.cpp	/^std::vector<geometry_msgs::Point> makeFootprintFromXMLRPC(XmlRpc::XmlRpcValue& footprint_xmlrpc,$/;"	f	namespace:costmap_2d
makePlan	carrot_planner/src/carrot_planner.cpp	/^  bool CarrotPlanner::makePlan(const geometry_msgs::PoseStamped& start, $/;"	f	class:carrot_planner::CarrotPlanner
makePlan	global_planner/src/planner_core.cpp	/^bool GlobalPlanner::makePlan(const geometry_msgs::PoseStamped& start, const geometry_msgs::PoseStamped& goal,$/;"	f	class:global_planner::GlobalPlanner
makePlan	move_base/src/move_base.cpp	/^    bool MoveBase::makePlan(const geometry_msgs::PoseStamped& goal, std::vector<geometry_msgs::PoseStamped>& plan){$/;"	f	class:move_base::MoveBase
makePlan	nav_core/include/nav_core/base_global_planner.h	/^      virtual bool makePlan(const geometry_msgs::PoseStamped& start, $/;"	f	class:nav_core::BaseGlobalPlanner
makePlan	navfn/src/navfn_ros.cpp	/^  bool NavfnROS::makePlan(const geometry_msgs::PoseStamped& start, $/;"	f	class:navfn::NavfnROS
makePlanService	global_planner/src/plan_node.cpp	/^bool PlannerWithCostmap::makePlanService(navfn::MakeNavPlan::Request& req, navfn::MakeNavPlan::Response& resp) {$/;"	f	class:global_planner::PlannerWithCostmap
makePlanService	global_planner/src/planner_core.cpp	/^bool GlobalPlanner::makePlanService(nav_msgs::GetPlan::Request& req, nav_msgs::GetPlan::Response& resp) {$/;"	f	class:global_planner::GlobalPlanner
makePlanService	navfn/src/navfn_node.cpp	/^bool NavfnWithCostmap::makePlanService(MakeNavPlan::Request& req, MakeNavPlan::Response& resp)$/;"	f	class:navfn::NavfnWithCostmap
makePlanService	navfn/src/navfn_ros.cpp	/^  bool NavfnROS::makePlanService(nav_msgs::GetPlan::Request& req, nav_msgs::GetPlan::Response& resp){$/;"	f	class:navfn::NavfnROS
make_plan_add_unreachable_goal_	move_base/include/move_base/move_base.h	/^      bool make_plan_clear_costmap_, make_plan_add_unreachable_goal_;$/;"	m	class:move_base::MoveBase
make_plan_clear_costmap_	move_base/include/move_base/move_base.h	/^      bool make_plan_clear_costmap_, make_plan_add_unreachable_goal_;$/;"	m	class:move_base::MoveBase
make_plan_service_	global_planner/src/plan_node.cpp	/^        ros::ServiceServer make_plan_service_;$/;"	m	class:global_planner::PlannerWithCostmap	file:
make_plan_service_	navfn/src/navfn_node.cpp	/^  ros::ServiceServer make_plan_service_;$/;"	m	class:navfn::NavfnWithCostmap	file:
make_plan_srv_	global_planner/include/global_planner/planner_core.h	/^        ros::ServiceServer make_plan_srv_;$/;"	m	class:global_planner::GlobalPlanner
make_plan_srv_	move_base/include/move_base/move_base.h	/^      ros::ServiceServer make_plan_srv_, clear_costmaps_srv_;$/;"	m	class:move_base::MoveBase
make_plan_srv_	navfn/include/navfn/navfn_ros.h	/^      ros::ServiceServer make_plan_srv_;$/;"	m	class:navfn::NavfnROS
make_willow_nav	navfn/test/path_calc_test.cpp	/^navfn::NavFn* make_willow_nav()$/;"	f
map	amcl/include/amcl/sensors/amcl_laser.h	/^  private: map_t *map;$/;"	m	class:amcl::AMCLLaser
mapCallback	map_server/src/main.cpp	/^    bool mapCallback(nav_msgs::GetMap::Request  &req,$/;"	f	class:MapServer	file:
mapCallback	map_server/src/map_saver.cpp	/^    void mapCallback(const nav_msgs::OccupancyGridConstPtr& map)$/;"	f	class:MapGenerator
mapCallback	map_server/test/rtest.cpp	/^    void mapCallback(const boost::shared_ptr<nav_msgs::OccupancyGrid const>& map)$/;"	f	class:MapClientTest
mapMetaDataCallback	map_server/test/rtest.cpp	/^    void mapMetaDataCallback(const boost::shared_ptr<nav_msgs::MapMetaData const>& map_metadata)$/;"	f	class:MapClientTest
mapReceived	amcl/src/amcl_node.cpp	/^AmclNode::mapReceived(const nav_msgs::OccupancyGridConstPtr& msg)$/;"	f	class:AmclNode
mapToWorld	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::mapToWorld(unsigned int mx, unsigned int my, double& wx, double& wy) const$/;"	f	class:costmap_2d::Costmap2D
mapToWorld	global_planner/src/planner_core.cpp	/^void GlobalPlanner::mapToWorld(double mx, double my, double& wx, double& wy) {$/;"	f	class:global_planner::GlobalPlanner
mapToWorld	navfn/src/navfn_ros.cpp	/^  void NavfnROS::mapToWorld(double mx, double my, double& wx, double& wy) {$/;"	f	class:navfn::NavfnROS
mapToWorld2D	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      inline void mapToWorld2D(unsigned int mx, unsigned int my, double& wx, double& wy){$/;"	f	class:base_local_planner::VoxelGridModel
mapToWorld3D	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      inline void mapToWorld3D(unsigned int mx, unsigned int my, unsigned int mz, double& wx, double& wy, double& wz){$/;"	f	class:base_local_planner::VoxelGridModel
mapToWorld3D	costmap_2d/include/costmap_2d/voxel_layer.h	/^  inline void mapToWorld3D(unsigned int mx, unsigned int my, unsigned int mz, double& wx, double& wy, double& wz)$/;"	f	class:costmap_2d::VoxelLayer
mapToWorld3D	costmap_2d/src/costmap_2d_cloud.cpp	/^static inline void mapToWorld3D(const unsigned int mx, const unsigned int my, const unsigned int mz,$/;"	f	file:
mapUpdateLoop	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::mapUpdateLoop(double frequency)$/;"	f	class:costmap_2d::Costmap2DROS
map_	amcl/src/amcl/map/map_cspace.cpp	/^    map_t* map_;$/;"	m	class:CellData	file:
map_	amcl/src/amcl_node.cpp	/^    map_t* map_;$/;"	m	class:AmclNode	file:
map_	base_local_planner/include/base_local_planner/map_grid.h	/^      std::vector<MapCell> map_; \/\/\/< @brief Storage for the MapCells$/;"	m	class:base_local_planner::MapGrid
map_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  base_local_planner::MapGrid map_;$/;"	m	class:base_local_planner::MapGridCostFunction
map_	base_local_planner/test/utest.cpp	/^    MapGrid* map_;$/;"	m	class:base_local_planner::TrajectoryPlannerTest	file:
map_	base_local_planner/test/wavefront_map_accessor.h	/^    MapGrid* map_;$/;"	m	class:base_local_planner::WavefrontMapAccessor
map_	map_server/test/rtest.cpp	/^    boost::shared_ptr<nav_msgs::OccupancyGrid const> map_;$/;"	m	class:MapClientTest	file:
map_alloc	amcl/src/amcl/map/map.c	/^map_t *map_alloc(void)$/;"	f
map_calc_range	amcl/src/amcl/map/map_range.c	/^double map_calc_range(map_t *map, double ox, double oy, double oa, double max_range)$/;"	f
map_cell_t	amcl/include/amcl/map/map.h	/^} map_cell_t;$/;"	t	typeref:struct:__anon1
map_data	map_server/scripts/crop_map	/^        map_data = yaml.safe_load(f)$/;"	v
map_draw_cspace	amcl/src/amcl/map/map_draw.c	/^void map_draw_cspace(map_t *map, rtk_fig_t *fig)$/;"	f
map_draw_occ	amcl/src/amcl/map/map_draw.c	/^void map_draw_occ(map_t *map, rtk_fig_t *fig)$/;"	f
map_draw_wifi	amcl/src/amcl/map/map_draw.c	/^void map_draw_wifi(map_t *map, rtk_fig_t *fig, int index)$/;"	f
map_frame_	costmap_2d/include/costmap_2d/static_layer.h	/^  std::string map_frame_;  \/\/\/ @brief frame that map is located in$/;"	m	class:costmap_2d::StaticLayer
map_free	amcl/src/amcl/map/map.c	/^void map_free(map_t *map)$/;"	f
map_get_cell	amcl/src/amcl/map/map.c	/^map_cell_t *map_get_cell(map_t *map, double ox, double oy, double oa)$/;"	f
map_image	map_server/scripts/crop_map	/^    map_image = Image.open(map_image_file)$/;"	v
map_image_file	map_server/scripts/crop_map	/^    map_image_file = map_data["image"]$/;"	v
map_load_occ	amcl/src/amcl/map/map_store.c	/^int map_load_occ(map_t *map, const char *filename, double scale, int negate)$/;"	f
map_metadata_	map_server/test/rtest.cpp	/^    boost::shared_ptr<nav_msgs::MapMetaData const> map_metadata_;$/;"	m	class:MapClientTest	file:
map_pub	map_server/src/main.cpp	/^    ros::Publisher map_pub;$/;"	m	class:MapServer	file:
map_received_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool map_received_;$/;"	m	class:costmap_2d::StaticLayer
map_resp_	map_server/src/main.cpp	/^    nav_msgs::GetMap::Response map_resp_;$/;"	m	class:MapServer	file:
map_server	map_server/include/map_server/image_loader.h	/^namespace map_server$/;"	n
map_server	map_server/src/image_loader.cpp	/^namespace map_server$/;"	n	file:
map_size_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned int  map_size_;$/;"	m	class:costmap_2d::Costmap2D
map_sub_	amcl/src/amcl_node.cpp	/^    ros::Subscriber map_sub_;$/;"	m	class:AmclNode	file:
map_sub_	costmap_2d/include/costmap_2d/static_layer.h	/^  ros::Subscriber map_sub_, map_update_sub_;$/;"	m	class:costmap_2d::StaticLayer
map_sub_	map_server/src/map_saver.cpp	/^    ros::Subscriber map_sub_;$/;"	m	class:MapGenerator	file:
map_t	amcl/include/amcl/map/map.h	/^} map_t;$/;"	t	typeref:struct:__anon2
map_tester	costmap_2d/test/costmap_tester.cpp	/^costmap_2d::CostmapTester* map_tester = NULL;$/;"	v
map_update_cspace	amcl/src/amcl/map/map_cspace.cpp	/^void map_update_cspace(map_t *map, double max_occ_dist)$/;"	f
map_update_sub_	costmap_2d/include/costmap_2d/static_layer.h	/^  ros::Subscriber map_sub_, map_update_sub_;$/;"	m	class:costmap_2d::StaticLayer
map_update_thread_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  boost::thread* map_update_thread_;  \/\/\/< @brief A thread for updating the map$/;"	m	class:costmap_2d::Costmap2DROS
map_update_thread_shutdown_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool map_update_thread_shutdown_;$/;"	m	class:costmap_2d::Costmap2DROS
map_viz_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      MapGridVisualizer map_viz_; \/\/\/< @brief The map grid visualizer for outputting the potential field generated by the cost function$/;"	m	class:base_local_planner::TrajectoryPlannerROS
map_viz_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::MapGridVisualizer map_viz_; \/\/\/< @brief The map grid visualizer for outputting the potential field generated by the cost function$/;"	m	class:dwa_local_planner::DWAPlanner
mapdata	amcl/src/amcl_node.cpp	/^    char* mapdata;$/;"	m	class:AmclNode	file:
mapname_	map_server/src/map_saver.cpp	/^    std::string mapname_;$/;"	m	class:MapGenerator	file:
markVoxel	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline void markVoxel(unsigned int x, unsigned int y, unsigned int z)$/;"	f	class:voxel_grid::VoxelGrid
markVoxelInMap	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline bool markVoxelInMap(unsigned int x, unsigned int y, unsigned int z, unsigned int marked_threshold)$/;"	f	class:voxel_grid::VoxelGrid
markVoxelLine	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::markVoxelLine(double x0, double y0, double z0, double x1, double y1, double z1, unsigned int max_length){$/;"	f	class:voxel_grid::VoxelGrid
mark_threshold_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double clear_threshold_, mark_threshold_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
mark_threshold_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  unsigned int unknown_threshold_, mark_threshold_, size_z_;$/;"	m	class:costmap_2d::VoxelLayer
marked_clear_threshold_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned int unknown_clear_threshold_, marked_clear_threshold_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxelInMap
marking_buffers_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<boost::shared_ptr<costmap_2d::ObservationBuffer> > marking_buffers_;  \/\/\/< @brief Used to store observation buffers used for marking obstacles$/;"	m	class:costmap_2d::ObstacleLayer
matchSize	costmap_2d/include/costmap_2d/layer.h	/^  virtual void matchSize() {}$/;"	f	class:costmap_2d::Layer
matchSize	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::matchSize()$/;"	f	class:costmap_2d::InflationLayer
matchSize	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::matchSize()$/;"	f	class:costmap_2d::StaticLayer
matchSize	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::matchSize()$/;"	f	class:costmap_2d::VoxelLayer
matchSize	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::matchSize()$/;"	f	class:costmap_2d::CostmapLayer
max	navfn/src/read_pgm_costmap.cpp	41;"	d	file:
max	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline unsigned int max(unsigned int x, unsigned int y)$/;"	f	class:voxel_grid::VoxelGrid
max_angle_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double max_angle_, phi_v_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
max_beams	amcl/include/amcl/sensors/amcl_laser.h	/^  private: int max_beams;$/;"	m	class:amcl::AMCLLaser
max_beams_	amcl/src/amcl_node.cpp	/^    int max_beams_, min_particles_, max_particles_;$/;"	m	class:AmclNode	file:
max_cell_cost_	base_local_planner/include/base_local_planner/trajectory.h	/^      double max_cell_cost_; \/\/\/< @brief The max cost\/score of the trajectory cell$/;"	m	class:base_local_planner::Trajectory
max_dist_	amcl/src/amcl/map/map_cspace.cpp	/^    double max_dist_;$/;"	m	class:CachedDistanceMap	file:
max_obs	amcl/include/amcl/sensors/amcl_laser.h	/^  private: int max_obs;$/;"	m	class:amcl::AMCLLaser
max_obstacle_height_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  double min_obstacle_height_, max_obstacle_height_;$/;"	m	class:costmap_2d::ObservationBuffer
max_obstacle_height_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  double max_obstacle_height_;  \/\/\/< @brief Max Obstacle Height$/;"	m	class:costmap_2d::ObstacleLayer
max_occ_dist	amcl/include/amcl/map/map.h	/^  double max_occ_dist;$/;"	m	struct:__anon2
max_particles_	amcl/src/amcl_node.cpp	/^    int max_beams_, min_particles_, max_particles_;$/;"	m	class:AmclNode	file:
max_planning_retries_	move_base/include/move_base/move_base.h	/^      int32_t max_planning_retries_;$/;"	m	class:move_base::MoveBase
max_rotational_vel_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  double sim_granularity_, min_rotational_vel_, max_rotational_vel_, acc_lim_th_, tolerance_, frequency_;$/;"	m	class:rotate_recovery::RotateRecovery
max_samples	amcl/include/amcl/pf/pf.h	/^  int min_samples, max_samples;$/;"	m	struct:_pf_t
max_samples	amcl/include/amcl/sensors/amcl_laser.h	/^  private: int max_samples;$/;"	m	class:amcl::AMCLLaser
max_samples_	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^  int max_samples_;$/;"	m	class:base_local_planner::SimpleScoredSamplingPlanner
max_scaling_factor_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  double max_scaling_factor_, scaling_speed_;$/;"	m	class:base_local_planner::ObstacleCostFunction
max_sensor_range_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double max_sensor_range_; \/\/\/< @brief Keep track of the effective maximum range of our sensors$/;"	m	class:base_local_planner::TrajectoryPlannerROS
max_trans_vel_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  double max_trans_vel_;$/;"	m	class:base_local_planner::ObstacleCostFunction
max_vel_th_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double max_vel_x_, min_vel_x_, max_vel_th_, min_vel_th_, min_in_place_vel_th_; \/\/\/< @brief Velocity limits for the controller$/;"	m	class:base_local_planner::TrajectoryPlanner
max_vel_th_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double max_vel_th_, min_vel_th_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
max_vel_theta	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double max_vel_theta;$/;"	m	class:base_local_planner::LocalPlannerLimits
max_vel_trans	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double max_vel_trans;$/;"	m	class:base_local_planner::LocalPlannerLimits
max_vel_x	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double max_vel_x;$/;"	m	class:base_local_planner::LocalPlannerLimits
max_vel_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double max_vel_x_, min_vel_x_, max_vel_th_, min_vel_th_, min_in_place_vel_th_; \/\/\/< @brief Velocity limits for the controller$/;"	m	class:base_local_planner::TrajectoryPlanner
max_vel_y	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double max_vel_y;$/;"	m	class:base_local_planner::LocalPlannerLimits
max_x_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double min_x_, min_y_, max_x_, max_y_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
max_y_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double min_x_, min_y_, max_x_, max_y_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
max_z_	base_local_planner/include/base_local_planner/point_grid.h	/^      double max_z_;  \/\/\/< @brief The height cutoff for adding points as obstacles$/;"	m	class:base_local_planner::PointGrid
max_z_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double max_z_;  \/\/\/< @brief The height cutoff for adding points as obstacles$/;"	m	class:base_local_planner::VoxelGridModel
maxval	navfn/include/navfn/navwin.h	/^      float maxval;			\/\/ max potential value$/;"	m	class:navfn::NavWin
maxx_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double minx_, miny_, maxx_, maxy_;$/;"	m	class:costmap_2d::LayeredCostmap
maxy_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double minx_, miny_, maxx_, maxy_;$/;"	m	class:costmap_2d::LayeredCostmap
mean	amcl/include/amcl/pf/pf.h	/^  pf_vector_t mean;$/;"	m	struct:__anon4
mean	amcl/include/amcl/pf/pf.h	/^  pf_vector_t mean;$/;"	m	struct:_pf_sample_set_t
meta_data_message_	map_server/src/main.cpp	/^    nav_msgs::MapMetaData meta_data_message_;$/;"	m	class:MapServer	file:
metadata_pub	map_server/src/main.cpp	/^    ros::Publisher metadata_pub;$/;"	m	class:MapServer	file:
meter_scoring_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool meter_scoring_;$/;"	m	class:base_local_planner::TrajectoryPlanner
min	navfn/src/read_pgm_costmap.cpp	42;"	d	file:
min_dist_from_robot_	carrot_planner/include/carrot_planner/carrot_planner.h	/^      double step_size_, min_dist_from_robot_;$/;"	m	class:carrot_planner::CarrotPlanner
min_in_place_vel_th_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double max_vel_x_, min_vel_x_, max_vel_th_, min_vel_th_, min_in_place_vel_th_; \/\/\/< @brief Velocity limits for the controller$/;"	m	class:base_local_planner::TrajectoryPlanner
min_in_place_vel_th_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double xy_goal_tolerance_, yaw_goal_tolerance_, min_in_place_vel_th_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
min_obstacle_height_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  double min_obstacle_height_, max_obstacle_height_;$/;"	m	class:costmap_2d::ObservationBuffer
min_particles_	amcl/src/amcl_node.cpp	/^    int max_beams_, min_particles_, max_particles_;$/;"	m	class:AmclNode	file:
min_rotational_vel_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  double sim_granularity_, min_rotational_vel_, max_rotational_vel_, acc_lim_th_, tolerance_, frequency_;$/;"	m	class:rotate_recovery::RotateRecovery
min_samples	amcl/include/amcl/pf/pf.h	/^  int min_samples, max_samples;$/;"	m	struct:_pf_t
min_vel_th_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double max_vel_x_, min_vel_x_, max_vel_th_, min_vel_th_, min_in_place_vel_th_; \/\/\/< @brief Velocity limits for the controller$/;"	m	class:base_local_planner::TrajectoryPlanner
min_vel_th_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double max_vel_th_, min_vel_th_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
min_vel_theta	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double min_vel_theta;$/;"	m	class:base_local_planner::LocalPlannerLimits
min_vel_trans	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double min_vel_trans;$/;"	m	class:base_local_planner::LocalPlannerLimits
min_vel_x	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double min_vel_x;$/;"	m	class:base_local_planner::LocalPlannerLimits
min_vel_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double max_vel_x_, min_vel_x_, max_vel_th_, min_vel_th_, min_in_place_vel_th_; \/\/\/< @brief Velocity limits for the controller$/;"	m	class:base_local_planner::TrajectoryPlanner
min_vel_y	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double min_vel_y;$/;"	m	class:base_local_planner::LocalPlannerLimits
min_x_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double min_x_, min_y_, max_x_, max_y_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
min_y_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double min_x_, min_y_, max_x_, max_y_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
minx_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double minx_, miny_, maxx_, maxy_;$/;"	m	class:costmap_2d::LayeredCostmap
miny_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  double minx_, miny_, maxx_, maxy_;$/;"	m	class:costmap_2d::LayeredCostmap
model_type	amcl/include/amcl/sensors/amcl_laser.h	/^  private: laser_model_t model_type;$/;"	m	class:amcl::AMCLLaser
model_type	amcl/include/amcl/sensors/amcl_odom.h	/^  private: odom_model_t model_type;$/;"	m	class:amcl::AMCLOdom
move_base	move_base/include/move_base/move_base.h	/^namespace move_base {$/;"	n
move_base	move_base/src/move_base.cpp	/^namespace move_base {$/;"	n	file:
move_parameter	costmap_2d/src/costmap_2d_ros.cpp	/^    void move_parameter(ros::NodeHandle& old_h, ros::NodeHandle& new_h, std::string name, bool should_delete = true)$/;"	f	namespace:costmap_2d
move_slow_and_clear	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^namespace move_slow_and_clear $/;"	n
move_slow_and_clear	move_slow_and_clear/src/move_slow_and_clear.cpp	/^        namespace move_slow_and_clear$/;"	n	file:
movementCB	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::movementCB(const ros::TimerEvent &event)$/;"	f	class:costmap_2d::Costmap2DROS
mutex_	global_planner/include/global_planner/planner_core.h	/^        boost::mutex mutex_;$/;"	m	class:global_planner::GlobalPlanner
mutex_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      boost::mutex mutex_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
mutex_	navfn/include/navfn/navfn_ros.h	/^      boost::mutex mutex_;$/;"	m	class:navfn::NavfnROS
mutex_t	costmap_2d/include/costmap_2d/costmap_2d.h	/^  typedef boost::recursive_mutex mutex_t;$/;"	t	class:costmap_2d::Costmap2D
n	amcl/src/amcl/pf/eig3.c	/^static int n = 3;$/;"	v	file:
n	amcl/src/amcl/pf/eig3.c	12;"	d	file:
n	map_server/src/main.cpp	/^    ros::NodeHandle n;$/;"	m	class:MapServer	file:
n_	map_server/test/rtest.cpp	/^    ros::NodeHandle* n_;$/;"	m	class:MapClientTest	file:
n_effective	amcl/include/amcl/pf/pf.h	/^  double n_effective;$/;"	m	struct:_pf_sample_set_t
name_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  std::string name_;$/;"	m	class:base_local_planner::LocalPlannerUtil
name_	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^            std::string name_; \/\/\/< @brief The name to get parameters relative to.$/;"	m	class:base_local_planner::MapGridVisualizer
name_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      std::string name_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
name_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::string name_;$/;"	m	class:costmap_2d::Costmap2DROS
name_	costmap_2d/include/costmap_2d/layer.h	/^  std::string name_;$/;"	m	class:costmap_2d::Layer
nav_core	nav_core/include/nav_core/base_global_planner.h	/^namespace nav_core {$/;"	n
nav_core	nav_core/include/nav_core/base_local_planner.h	/^namespace nav_core {$/;"	n
nav_core	nav_core/include/nav_core/parameter_magic.h	/^namespace nav_core$/;"	n
nav_core	nav_core/include/nav_core/recovery_behavior.h	/^namespace nav_core {$/;"	n
navfn	navfn/include/navfn/navfn.h	/^namespace navfn {$/;"	n
navfn	navfn/include/navfn/navfn_ros.h	/^namespace navfn {$/;"	n
navfn	navfn/include/navfn/navwin.h	/^namespace navfn {$/;"	n
navfn	navfn/include/navfn/potarr_point.h	/^namespace navfn {$/;"	n
navfn	navfn/src/navfn.cpp	/^namespace navfn {$/;"	n	file:
navfn	navfn/src/navfn_node.cpp	/^namespace navfn {$/;"	n	file:
navfn	navfn/src/navfn_ros.cpp	/^namespace navfn {$/;"	n	file:
navfn	navfn/src/navwin.cpp	/^namespace navfn {$/;"	n	file:
nearestNeighborDistance	base_local_planner/src/point_grid.cpp	/^  double PointGrid::nearestNeighborDistance(const geometry_msgs::Point32& pt){$/;"	f	class:base_local_planner::PointGrid
need_reinflation_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  bool need_reinflation_;  \/\/\/< Indicates that the entire costmap should be reinflated next time around.$/;"	m	class:costmap_2d::InflationLayer
neutral_cost_	global_planner/include/global_planner/expander.h	/^        unsigned char lethal_cost_, neutral_cost_;$/;"	m	class:global_planner::Expander
new_global_plan_	move_base/include/move_base/move_base.h	/^      bool new_global_plan_;$/;"	m	class:move_base::MoveBase
nextBuffer_	global_planner/include/global_planner/dijkstra.h	/^        int *currentBuffer_, *nextBuffer_, *overBuffer_; \/**< priority buffer block ptrs *\/$/;"	m	class:global_planner::DijkstraExpansion
nextEnd_	global_planner/include/global_planner/dijkstra.h	/^        int currentEnd_, nextEnd_, overEnd_; \/**< end points of arrays *\/$/;"	m	class:global_planner::DijkstraExpansion
nextP	navfn/include/navfn/navfn.h	/^      int *curP, *nextP, *overP;	\/**< priority buffer block ptrs *\/$/;"	m	class:navfn::NavFn
nextPe	navfn/include/navfn/navfn.h	/^      int curPe, nextPe, overPe; \/**< end points of arrays *\/$/;"	m	class:navfn::NavFn
nextTrajectory	base_local_planner/src/simple_trajectory_generator.cpp	/^bool SimpleTrajectoryGenerator::nextTrajectory(Trajectory &comp_traj) {$/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
next_sample_index_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  unsigned int next_sample_index_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
nh	navfn/include/navfn/navwin.h	/^      int nw,nh;			\/\/ width and height of image$/;"	m	class:navfn::NavWin
nh_	amcl/src/amcl_node.cpp	/^    ros::NodeHandle nh_;$/;"	m	class:AmclNode	file:
no_readings_timeout_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double no_readings_timeout_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
nobs	navfn/include/navfn/navfn.h	/^      int nobs;			\/**< number of obstacle cells *\/$/;"	m	class:navfn::NavFn
node	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  ros::NodeHandle* node;$/;"	m	class:costmap_2d::Costmap2DPublisher
node_count	amcl/include/amcl/pf/pf_kdtree.h	/^  int node_count, node_max_count;$/;"	m	struct:__anon8
node_max_count	amcl/include/amcl/pf/pf_kdtree.h	/^  int node_count, node_max_count;$/;"	m	struct:__anon8
nodes	amcl/include/amcl/pf/pf_kdtree.h	/^  pf_kdtree_node_t *nodes;$/;"	m	struct:__anon8
nomotionUpdateCallback	amcl/src/amcl_node.cpp	/^AmclNode::nomotionUpdateCallback(std_srvs::Empty::Request& req,$/;"	f	class:AmclNode
nomotion_update_srv_	amcl/src/amcl_node.cpp	/^    ros::ServiceServer nomotion_update_srv_; \/\/to let amcl update samples without requiring motion$/;"	m	class:AmclNode	file:
normalize	amcl/src/amcl/sensors/amcl_odom.cpp	/^normalize(double z)$/;"	f	file:
normalize	amcl/src/amcl_node.cpp	/^normalize(double z)$/;"	f	file:
npath	navfn/include/navfn/navfn.h	/^      int npath;			\/**< number of path points *\/$/;"	m	class:navfn::NavFn
npathbuf	navfn/include/navfn/navfn.h	/^      int npathbuf;			\/**< size of pathx, pathy buffers *\/$/;"	m	class:navfn::NavFn
ns	navfn/include/navfn/navfn.h	/^      int nx, ny, ns;		\/**< size of grid, in pixels *\/$/;"	m	class:navfn::NavFn
ns_	global_planner/include/global_planner/expander.h	/^        int nx_, ny_, ns_; \/**< size of grid, in pixels *\/$/;"	m	class:global_planner::Expander
ns_	global_planner/include/global_planner/potential_calculator.h	/^        int nx_, ny_, ns_; \/**< size of grid, in pixels *\/$/;"	m	class:global_planner::PotentialCalculator
ns_nh_	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^            ros::NodeHandle ns_nh_;$/;"	m	class:base_local_planner::MapGridVisualizer
numBits	voxel_grid/include/voxel_grid/voxel_grid.h	/^  static inline unsigned int numBits(unsigned int n)$/;"	f	class:voxel_grid::VoxelGrid
num_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int den_, num_, numadd_, numpixels_;$/;"	m	class:base_local_planner::LineIterator
numadd_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int den_, num_, numadd_, numpixels_;$/;"	m	class:base_local_planner::LineIterator
numpixels_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int den_, num_, numadd_, numpixels_;$/;"	m	class:base_local_planner::LineIterator
nw	navfn/include/navfn/navwin.h	/^      int nw,nh;			\/\/ width and height of image$/;"	m	class:navfn::NavWin
nwin	navfn/src/navtest.cpp	/^NavWin *nwin;$/;"	v
nx	navfn/include/navfn/navfn.h	/^      int nx, ny, ns;		\/**< size of grid, in pixels *\/$/;"	m	class:navfn::NavFn
nx_	global_planner/include/global_planner/expander.h	/^        int nx_, ny_, ns_; \/**< size of grid, in pixels *\/$/;"	m	class:global_planner::Expander
nx_	global_planner/include/global_planner/potential_calculator.h	/^        int nx_, ny_, ns_; \/**< size of grid, in pixels *\/$/;"	m	class:global_planner::PotentialCalculator
ny	navfn/include/navfn/navfn.h	/^      int nx, ny, ns;		\/**< size of grid, in pixels *\/$/;"	m	class:navfn::NavFn
ny_	global_planner/include/global_planner/expander.h	/^        int nx_, ny_, ns_; \/**< size of grid, in pixels *\/$/;"	m	class:global_planner::Expander
ny_	global_planner/include/global_planner/potential_calculator.h	/^        int nx_, ny_, ns_; \/**< size of grid, in pixels *\/$/;"	m	class:global_planner::PotentialCalculator
observation_buffers_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<boost::shared_ptr<costmap_2d::ObservationBuffer> > observation_buffers_;  \/\/\/< @brief Used to store observations from various sensors$/;"	m	class:costmap_2d::ObstacleLayer
observation_keep_time_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  const ros::Duration observation_keep_time_;$/;"	m	class:costmap_2d::ObservationBuffer
observation_list_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  std::list<Observation> observation_list_;$/;"	m	class:costmap_2d::ObservationBuffer
observation_notifiers_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<boost::shared_ptr<tf2_ros::MessageFilterBase> > observation_notifiers_;  \/\/\/< @brief Used to make sure that transforms are available for each sensor$/;"	m	class:costmap_2d::ObstacleLayer
observation_subscribers_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<boost::shared_ptr<message_filters::SubscriberBase> > observation_subscribers_;  \/\/\/< @brief Used for the observation message filters$/;"	m	class:costmap_2d::ObstacleLayer
obstacleCosts	base_local_planner/include/base_local_planner/map_grid.h	/^      inline double obstacleCosts() {$/;"	f	class:base_local_planner::MapGrid
obstacleCosts	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  double obstacleCosts() {$/;"	f	class:base_local_planner::MapGridCostFunction
obstacle_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::ObstacleCostFunction obstacle_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
obstacle_grid_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      voxel_grid::VoxelGrid obstacle_grid_;$/;"	m	class:base_local_planner::VoxelGridModel
obstacle_range_	costmap_2d/include/costmap_2d/observation.h	/^  double obstacle_range_, raytrace_range_;$/;"	m	class:costmap_2d::Observation
obstacle_range_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  double obstacle_range_, raytrace_range_;$/;"	m	class:costmap_2d::ObservationBuffer
occ_dist	amcl/include/amcl/map/map.h	/^  double occ_dist;$/;"	m	struct:__anon1
occ_state	amcl/include/amcl/map/map.h	/^  int occ_state;$/;"	m	struct:__anon1
occdist_scale_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double path_distance_bias_, goal_distance_bias_, occdist_scale_; \/\/\/< @brief Scaling factors for the controller's cost function$/;"	m	class:base_local_planner::TrajectoryPlanner
occdist_scale_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double path_distance_bias_, goal_distance_bias_, occdist_scale_;$/;"	m	class:dwa_local_planner::DWAPlanner
odomCallback	base_local_planner/src/odometry_helper_ros.cpp	/^void OdometryHelperRos::odomCallback(const nav_msgs::Odometry::ConstPtr& msg) {$/;"	f	class:base_local_planner::OdometryHelperRos
odom_	amcl/src/amcl_node.cpp	/^    AMCLOdom* odom_;$/;"	m	class:AmclNode	file:
odom_frame_id_	amcl/src/amcl_node.cpp	/^    std::string odom_frame_id_;$/;"	m	class:AmclNode	file:
odom_frame_id_	fake_localization/fake_localization.cpp	/^    std::string odom_frame_id_;$/;"	m	class:FakeOdomNode	file:
odom_helper_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      base_local_planner::OdometryHelperRos odom_helper_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
odom_helper_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      base_local_planner::OdometryHelperRos odom_helper_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
odom_lock_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      boost::recursive_mutex odom_lock_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
odom_model_t	amcl/include/amcl/sensors/amcl_odom.h	/^} odom_model_t;$/;"	t	namespace:amcl	typeref:enum:amcl::__anon9
odom_model_type_	amcl/src/amcl_node.cpp	/^    odom_model_t odom_model_type_;$/;"	m	class:AmclNode	file:
odom_mutex_	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  boost::mutex odom_mutex_;$/;"	m	class:base_local_planner::OdometryHelperRos
odom_sub_	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  ros::Subscriber odom_sub_;$/;"	m	class:base_local_planner::OdometryHelperRos
odom_topic_	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  std::string odom_topic_;$/;"	m	class:base_local_planner::OdometryHelperRos
odom_topic_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      std::string odom_topic_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
odt	amcl/cfg/AMCL.cfg	/^odt = gen.enum([gen.const("diff_const", str_t, "diff", "Use diff odom model"),$/;"	v
offset_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned int &offset_;$/;"	m	class:voxel_grid::VoxelGrid::GridOffset
old_config_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  costmap_2d::Costmap2DConfig old_config_;$/;"	m	class:costmap_2d::Costmap2DROS
old_navfn_behavior_	global_planner/include/global_planner/planner_core.h	/^        bool old_navfn_behavior_;$/;"	m	class:global_planner::GlobalPlanner
old_pose_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  geometry_msgs::PoseStamped old_pose_;$/;"	m	class:costmap_2d::Costmap2DROS
old_rot_speed_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      double limited_trans_speed_, limited_rot_speed_, old_trans_speed_, old_rot_speed_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
old_trans_speed_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      double limited_trans_speed_, limited_rot_speed_, old_trans_speed_, old_rot_speed_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
omode_	global_planner/include/global_planner/orientation_filter.h	/^        OrientationMode omode_;$/;"	m	class:global_planner::OrientationFilter
onFootprintChanged	costmap_2d/include/costmap_2d/layer.h	/^  virtual void onFootprintChanged() {}$/;"	f	class:costmap_2d::Layer
onFootprintChanged	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::onFootprintChanged()$/;"	f	class:costmap_2d::InflationLayer
onInitialize	costmap_2d/include/costmap_2d/layer.h	/^  virtual void onInitialize() {}$/;"	f	class:costmap_2d::Layer
onInitialize	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::onInitialize()$/;"	f	class:costmap_2d::InflationLayer
onInitialize	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::onInitialize()$/;"	f	class:costmap_2d::ObstacleLayer
onInitialize	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::onInitialize()$/;"	f	class:range_sensor_layer::RangeSensorLayer
onInitialize	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::onInitialize()$/;"	f	class:costmap_2d::StaticLayer
onInitialize	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::onInitialize()$/;"	f	class:costmap_2d::VoxelLayer
onNewSubscription	costmap_2d/src/costmap_2d_publisher.cpp	/^    void Costmap2DPublisher::onNewSubscription(const ros::SingleSubscriberPublisher& pub)$/;"	f	class:costmap_2d::Costmap2DPublisher
operator ()	base_local_planner/include/base_local_planner/map_grid.h	/^      inline MapCell operator() (unsigned int x, unsigned int y) const {$/;"	f	class:base_local_planner::MapGrid
operator ()	base_local_planner/include/base_local_planner/map_grid.h	/^      inline MapCell& operator() (unsigned int x, unsigned int y){$/;"	f	class:base_local_planner::MapGrid
operator ()	costmap_2d/include/costmap_2d/costmap_2d.h	/^    inline void operator()(unsigned int offset)$/;"	f	class:costmap_2d::Costmap2D::MarkCell
operator ()	costmap_2d/include/costmap_2d/costmap_2d.h	/^    inline void operator()(unsigned int offset)$/;"	f	class:costmap_2d::Costmap2D::PolygonOutlineCells
operator ()	global_planner/include/global_planner/astar.h	/^        bool operator()(const Index& a, const Index& b) const {$/;"	f	struct:global_planner::greater1
operator ()	voxel_grid/include/voxel_grid/voxel_grid.h	/^    inline void operator()(int offset_val)$/;"	f	class:voxel_grid::VoxelGrid::GridOffset
operator ()	voxel_grid/include/voxel_grid/voxel_grid.h	/^    inline void operator()(int offset_val)$/;"	f	class:voxel_grid::VoxelGrid::ZOffset
operator ()	voxel_grid/include/voxel_grid/voxel_grid.h	/^    inline void operator()(unsigned int offset, unsigned int z_mask)$/;"	f	class:voxel_grid::VoxelGrid::ClearVoxel
operator ()	voxel_grid/include/voxel_grid/voxel_grid.h	/^    inline void operator()(unsigned int offset, unsigned int z_mask)$/;"	f	class:voxel_grid::VoxelGrid::ClearVoxelInMap
operator ()	voxel_grid/include/voxel_grid/voxel_grid.h	/^    inline void operator()(unsigned int offset, unsigned int z_mask)$/;"	f	class:voxel_grid::VoxelGrid::MarkVoxel
operator ++	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      VelocityIterator& operator++(int){$/;"	f	class:base_local_planner::VelocityIterator
operator <	amcl/src/amcl/map/map_cspace.cpp	/^bool operator<(const CellData& a, const CellData& b)$/;"	f
operator =	base_local_planner/src/map_grid.cpp	/^  MapGrid& MapGrid::operator= (const MapGrid& mg){$/;"	f	class:base_local_planner::MapGrid
operator =	costmap_2d/src/costmap_2d.cpp	/^    Costmap2D& Costmap2D::operator=(const Costmap2D& map)$/;"	f	class:costmap_2d::Costmap2D
operator >>	map_server/src/main.cpp	/^void operator >> (const YAML::Node& node, T& i)$/;"	f
orient	base_local_planner/include/base_local_planner/point_grid.h	/^      inline double orient(const T& a, const T& b, const T& c){$/;"	f	class:base_local_planner::PointGrid
orient	base_local_planner/include/base_local_planner/point_grid.h	/^      inline double orient(const geometry_msgs::Point& a, const geometry_msgs::Point& b, const geometry_msgs::Point32& c){$/;"	f	class:base_local_planner::PointGrid
orient2d	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  int orient2d(int Ax, int Ay, int Bx, int By, int Cx, int Cy)$/;"	f	class:range_sensor_layer::RangeSensorLayer
orientation_enum	global_planner/cfg/GlobalPlanner.cfg	/^orientation_enum = gen.enum([$/;"	v
orientation_filter_	global_planner/include/global_planner/planner_core.h	/^        OrientationFilter* orientation_filter_;$/;"	m	class:global_planner::GlobalPlanner
origin	base_local_planner/include/base_local_planner/planar_laser_scan.h	/^      geometry_msgs::Point32 origin;$/;"	m	class:base_local_planner::PlanarLaserScan
origin	map_server/scripts/crop_map	/^    origin = map_data["origin"]$/;"	v
origin_	base_local_planner/include/base_local_planner/point_grid.h	/^      geometry_msgs::Point origin_; \/\/\/< @brief The origin point of the grid$/;"	m	class:base_local_planner::PointGrid
origin_	costmap_2d/include/costmap_2d/observation.h	/^  geometry_msgs::Point origin_;$/;"	m	class:costmap_2d::Observation
origin_x	amcl/include/amcl/map/map.h	/^  double origin_x, origin_y;$/;"	m	struct:__anon2
origin_x_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double origin_x_;$/;"	m	class:base_local_planner::VoxelGridModel
origin_x_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  double origin_x_;$/;"	m	class:costmap_2d::Costmap2D
origin_y	amcl/include/amcl/map/map.h	/^  double origin_x, origin_y;$/;"	m	struct:__anon2
origin_y_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double origin_y_;$/;"	m	class:base_local_planner::VoxelGridModel
origin_y_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  double origin_y_;$/;"	m	class:costmap_2d::Costmap2D
origin_z_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double origin_z_;$/;"	m	class:base_local_planner::VoxelGridModel
origin_z_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  double z_resolution_, origin_z_;$/;"	m	class:costmap_2d::VoxelLayer
oscillation_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::OscillationCostFunction oscillation_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
oscillation_distance_	move_base/include/move_base/move_base.h	/^      double oscillation_timeout_, oscillation_distance_;$/;"	m	class:move_base::MoveBase
oscillation_pose_	move_base/include/move_base/move_base.h	/^      geometry_msgs::PoseStamped oscillation_pose_;$/;"	m	class:move_base::MoveBase
oscillation_reset_angle_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  double oscillation_reset_dist_, oscillation_reset_angle_;$/;"	m	class:base_local_planner::OscillationCostFunction
oscillation_reset_dist_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  double oscillation_reset_dist_, oscillation_reset_angle_;$/;"	m	class:base_local_planner::OscillationCostFunction
oscillation_reset_dist_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double oscillation_reset_dist_; \/\/\/< @brief The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past$/;"	m	class:base_local_planner::TrajectoryPlanner
oscillation_timeout_	move_base/include/move_base/move_base.h	/^      double oscillation_timeout_, oscillation_distance_;$/;"	m	class:move_base::MoveBase
outer_radius_	base_local_planner/test/wavefront_map_accessor.h	/^    double outer_radius_;$/;"	m	class:base_local_planner::WavefrontMapAccessor
outlineMap	global_planner/src/planner_core.cpp	/^void GlobalPlanner::outlineMap(unsigned char* costarr, int nx, int ny, unsigned char value) {$/;"	f	class:global_planner::GlobalPlanner
outline_map_	global_planner/include/global_planner/planner_core.h	/^        bool outline_map_;$/;"	m	class:global_planner::GlobalPlanner
overBuffer_	global_planner/include/global_planner/dijkstra.h	/^        int *currentBuffer_, *nextBuffer_, *overBuffer_; \/**< priority buffer block ptrs *\/$/;"	m	class:global_planner::DijkstraExpansion
overEnd_	global_planner/include/global_planner/dijkstra.h	/^        int currentEnd_, nextEnd_, overEnd_; \/**< end points of arrays *\/$/;"	m	class:global_planner::DijkstraExpansion
overP	navfn/include/navfn/navfn.h	/^      int *curP, *nextP, *overP;	\/**< priority buffer block ptrs *\/$/;"	m	class:navfn::NavFn
overPe	navfn/include/navfn/navfn.h	/^      int curPe, nextPe, overPe; \/**< end points of arrays *\/$/;"	m	class:navfn::NavFn
p_calc_	global_planner/include/global_planner/expander.h	/^        PotentialCalculator* p_calc_;$/;"	m	class:global_planner::Expander
p_calc_	global_planner/include/global_planner/planner_core.h	/^        PotentialCalculator* p_calc_;$/;"	m	class:global_planner::GlobalPlanner
p_calc_	global_planner/include/global_planner/traceback.h	/^        PotentialCalculator* p_calc_;$/;"	m	class:global_planner::Traceback
p_freq_change_	move_base/include/move_base/move_base.h	/^      bool setup_, p_freq_change_, c_freq_change_;$/;"	m	class:move_base::MoveBase
package_dir	base_local_planner/setup.py	/^    package_dir = {'': 'src'},$/;"	v
packages	base_local_planner/setup.py	/^    packages = ['local_planner_limits'],$/;"	v
padFootprint	costmap_2d/src/footprint.cpp	/^void padFootprint(std::vector<geometry_msgs::Point>& footprint, double padding)$/;"	f	namespace:costmap_2d
padded_footprint_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::vector<geometry_msgs::Point> padded_footprint_;$/;"	m	class:costmap_2d::Costmap2DROS
parseVVF	costmap_2d/src/array_parser.cpp	/^std::vector<std::vector<float> > parseVVF(const std::string& input, std::string& error_return)$/;"	f	namespace:costmap_2d
particlecloud_pub_	amcl/src/amcl_node.cpp	/^    ros::Publisher particlecloud_pub_;$/;"	m	class:AmclNode	file:
path	navfn/include/navfn/navwin.h	/^      int *path;			\/\/ path buffer, cell indices$/;"	m	class:navfn::NavWin
pathStep	navfn/include/navfn/navfn.h	/^      float pathStep;		\/**< step size for following gradient *\/$/;"	m	class:navfn::NavFn
pathStep_	global_planner/include/global_planner/gradient_path.h	/^        float pathStep_; \/**< step size for following gradient *\/$/;"	m	class:global_planner::GradientPath
path_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::MapGridCostFunction path_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
path_distance_bias_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double path_distance_bias_, goal_distance_bias_, occdist_scale_; \/\/\/< @brief Scaling factors for the controller's cost function$/;"	m	class:base_local_planner::TrajectoryPlanner
path_distance_bias_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double path_distance_bias_, goal_distance_bias_, occdist_scale_;$/;"	m	class:dwa_local_planner::DWAPlanner
path_maker_	global_planner/include/global_planner/planner_core.h	/^        Traceback* path_maker_;$/;"	m	class:global_planner::GlobalPlanner
path_map_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      MapGrid path_map_; \/\/\/< @brief The local map grid where we propagate path distance$/;"	m	class:base_local_planner::TrajectoryPlanner
pathbuflen	navfn/include/navfn/navwin.h	/^      int pathbuflen;		\/\/ how big the path buffer is$/;"	m	class:navfn::NavWin
pathlen	navfn/include/navfn/navwin.h	/^      int pathlen;			\/\/ how many we have$/;"	m	class:navfn::NavWin
pathx	navfn/include/navfn/navfn.h	/^      float *pathx, *pathy;		\/**< path points, as subpixel cell coordinates *\/$/;"	m	class:navfn::NavFn
pathy	navfn/include/navfn/navfn.h	/^      float *pathx, *pathy;		\/**< path points, as subpixel cell coordinates *\/$/;"	m	class:navfn::NavFn
pause	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::pause()$/;"	f	class:costmap_2d::Costmap2DROS
pb1	navfn/include/navfn/navfn.h	/^      int *pb1, *pb2, *pb3;		\/**< storage buffers for priority blocks *\/$/;"	m	class:navfn::NavFn
pb2	navfn/include/navfn/navfn.h	/^      int *pb1, *pb2, *pb3;		\/**< storage buffers for priority blocks *\/$/;"	m	class:navfn::NavFn
pb3	navfn/include/navfn/navfn.h	/^      int *pb1, *pb2, *pb3;		\/**< storage buffers for priority blocks *\/$/;"	m	class:navfn::NavFn
pc	navfn/include/navfn/navwin.h	/^      int *pc, *pn, *po;		\/\/ priority buffers$/;"	m	class:navfn::NavWin
pce	navfn/include/navfn/navwin.h	/^      int pce, pne, poe;		\/\/ buffer sizes$/;"	m	class:navfn::NavWin
peer_subscribe	amcl/test/set_pose.py	/^    def peer_subscribe(self, topic_name, topic_publish, peer_publish):$/;"	m	class:PoseSetter
penalty_	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^  double penalty_;$/;"	m	class:base_local_planner::PreferForwardCostFunction
pending	navfn/include/navfn/navfn.h	/^      bool    *pending;		\/**< pending cells during propagation *\/$/;"	m	class:navfn::NavFn
pending_	global_planner/include/global_planner/dijkstra.h	/^        bool *pending_; \/**< pending_ cells during propagation *\/$/;"	m	class:global_planner::DijkstraExpansion
pf_	amcl/src/amcl_node.cpp	/^    pf_t *pf_;$/;"	m	class:AmclNode	file:
pf_action_model_fn_t	amcl/include/amcl/pf/pf.h	/^typedef void (*pf_action_model_fn_t) (void *action_data, $/;"	t
pf_alloc	amcl/src/amcl/pf/pf.c	/^pf_t *pf_alloc(int min_samples, int max_samples,$/;"	f
pf_cluster_stats	amcl/src/amcl/pf/pf.c	/^void pf_cluster_stats(pf_t *pf, pf_sample_set_t *set)$/;"	f
pf_cluster_t	amcl/include/amcl/pf/pf.h	/^} pf_cluster_t;$/;"	t	typeref:struct:__anon4
pf_draw_cep_stats	amcl/src/amcl/pf/pf_draw.c	/^void pf_draw_cep_stats(pf_t *pf, rtk_fig_t *fig)$/;"	f
pf_draw_cluster_stats	amcl/src/amcl/pf/pf_draw.c	/^void pf_draw_cluster_stats(pf_t *pf, rtk_fig_t *fig)$/;"	f
pf_draw_hist	amcl/src/amcl/pf/pf_draw.c	/^void pf_draw_hist(pf_t *pf, rtk_fig_t *fig)$/;"	f
pf_draw_samples	amcl/src/amcl/pf/pf_draw.c	/^void pf_draw_samples(pf_t *pf, rtk_fig_t *fig, int max_samples)$/;"	f
pf_err_	amcl/src/amcl_node.cpp	/^    double pf_err_, pf_z_;$/;"	m	class:AmclNode	file:
pf_free	amcl/src/amcl/pf/pf.c	/^void pf_free(pf_t *pf)$/;"	f
pf_get_cep_stats	amcl/src/amcl/pf/pf.c	/^void pf_get_cep_stats(pf_t *pf, pf_vector_t *mean, double *var)$/;"	f
pf_get_cluster_stats	amcl/src/amcl/pf/pf.c	/^int pf_get_cluster_stats(pf_t *pf, int clabel, double *weight,$/;"	f
pf_init	amcl/src/amcl/pf/pf.c	/^void pf_init(pf_t *pf, pf_vector_t mean, pf_matrix_t cov)$/;"	f
pf_init_	amcl/src/amcl_node.cpp	/^    bool pf_init_;$/;"	m	class:AmclNode	file:
pf_init_converged	amcl/src/amcl/pf/pf.c	/^void pf_init_converged(pf_t *pf){$/;"	f
pf_init_model	amcl/src/amcl/pf/pf.c	/^void pf_init_model(pf_t *pf, pf_init_model_fn_t init_fn, void *init_data)$/;"	f
pf_init_model_fn_t	amcl/include/amcl/pf/pf.h	/^typedef pf_vector_t (*pf_init_model_fn_t) (void *init_data);$/;"	t
pf_kdtree_alloc	amcl/src/amcl/pf/pf_kdtree.c	/^pf_kdtree_t *pf_kdtree_alloc(int max_size)$/;"	f
pf_kdtree_clear	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_clear(pf_kdtree_t *self)$/;"	f
pf_kdtree_cluster	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_cluster(pf_kdtree_t *self)$/;"	f
pf_kdtree_cluster_node	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_cluster_node(pf_kdtree_t *self, pf_kdtree_node_t *node, int depth)$/;"	f
pf_kdtree_draw	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_draw(pf_kdtree_t *self, rtk_fig_t *fig)$/;"	f
pf_kdtree_draw_node	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_draw_node(pf_kdtree_t *self, pf_kdtree_node_t *node, rtk_fig_t *fig)$/;"	f
pf_kdtree_equal	amcl/src/amcl/pf/pf_kdtree.c	/^int pf_kdtree_equal(pf_kdtree_t *self, int key_a[], int key_b[])$/;"	f
pf_kdtree_find_node	amcl/src/amcl/pf/pf_kdtree.c	/^pf_kdtree_node_t *pf_kdtree_find_node(pf_kdtree_t *self, pf_kdtree_node_t *node, int key[])$/;"	f
pf_kdtree_free	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_free(pf_kdtree_t *self)$/;"	f
pf_kdtree_get_cluster	amcl/src/amcl/pf/pf_kdtree.c	/^int pf_kdtree_get_cluster(pf_kdtree_t *self, pf_vector_t pose)$/;"	f
pf_kdtree_get_prob	amcl/src/amcl/pf/pf_kdtree.c	/^double pf_kdtree_get_prob(pf_kdtree_t *self, pf_vector_t pose)$/;"	f
pf_kdtree_insert	amcl/src/amcl/pf/pf_kdtree.c	/^void pf_kdtree_insert(pf_kdtree_t *self, pf_vector_t pose, double value)$/;"	f
pf_kdtree_insert_node	amcl/src/amcl/pf/pf_kdtree.c	/^pf_kdtree_node_t *pf_kdtree_insert_node(pf_kdtree_t *self, pf_kdtree_node_t *parent,$/;"	f
pf_kdtree_node	amcl/include/amcl/pf/pf_kdtree.h	/^typedef struct pf_kdtree_node$/;"	s
pf_kdtree_node_t	amcl/include/amcl/pf/pf_kdtree.h	/^} pf_kdtree_node_t;$/;"	t	typeref:struct:pf_kdtree_node
pf_kdtree_t	amcl/include/amcl/pf/pf_kdtree.h	/^} pf_kdtree_t;$/;"	t	typeref:struct:__anon8
pf_matrix_finite	amcl/src/amcl/pf/pf_vector.c	/^int pf_matrix_finite(pf_matrix_t a)$/;"	f
pf_matrix_fprintf	amcl/src/amcl/pf/pf_vector.c	/^void pf_matrix_fprintf(pf_matrix_t a, FILE *file, const char *fmt)$/;"	f
pf_matrix_t	amcl/include/amcl/pf/pf_vector.h	/^} pf_matrix_t;$/;"	t	typeref:struct:__anon6
pf_matrix_unitary	amcl/src/amcl/pf/pf_vector.c	/^void pf_matrix_unitary(pf_matrix_t *r, pf_matrix_t *d, pf_matrix_t a)$/;"	f
pf_matrix_zero	amcl/src/amcl/pf/pf_vector.c	/^pf_matrix_t pf_matrix_zero()$/;"	f
pf_odom_pose_	amcl/src/amcl_node.cpp	/^    pf_vector_t pf_odom_pose_;$/;"	m	class:AmclNode	file:
pf_pdf_gaussian_alloc	amcl/src/amcl/pf/pf_pdf.c	/^pf_pdf_gaussian_t *pf_pdf_gaussian_alloc(pf_vector_t x, pf_matrix_t cx)$/;"	f
pf_pdf_gaussian_free	amcl/src/amcl/pf/pf_pdf.c	/^void pf_pdf_gaussian_free(pf_pdf_gaussian_t *pdf)$/;"	f
pf_pdf_gaussian_sample	amcl/src/amcl/pf/pf_pdf.c	/^pf_vector_t pf_pdf_gaussian_sample(pf_pdf_gaussian_t *pdf)$/;"	f
pf_pdf_gaussian_t	amcl/include/amcl/pf/pf_pdf.h	/^} pf_pdf_gaussian_t;$/;"	t	typeref:struct:__anon7
pf_pdf_seed	amcl/src/amcl/pf/pf_pdf.c	/^static unsigned int pf_pdf_seed;$/;"	v	file:
pf_pose_cov	amcl/src/amcl_node.cpp	/^  pf_matrix_t pf_pose_cov;$/;"	m	struct:__anon11	file:
pf_pose_mean	amcl/src/amcl_node.cpp	/^  pf_vector_t pf_pose_mean;$/;"	m	struct:__anon11	file:
pf_ran_gaussian	amcl/src/amcl/pf/pf_pdf.c	/^double pf_ran_gaussian(double sigma)$/;"	f
pf_resample_limit	amcl/src/amcl/pf/pf.c	/^int pf_resample_limit(pf_t *pf, int k)$/;"	f
pf_sample_set_t	amcl/include/amcl/pf/pf.h	/^} pf_sample_set_t;$/;"	t	typeref:struct:_pf_sample_set_t
pf_sample_t	amcl/include/amcl/pf/pf.h	/^} pf_sample_t;$/;"	t	typeref:struct:__anon3
pf_sensor_model_fn_t	amcl/include/amcl/pf/pf.h	/^typedef double (*pf_sensor_model_fn_t) (void *sensor_data, $/;"	t
pf_set_selective_resampling	amcl/src/amcl/pf/pf.c	/^void pf_set_selective_resampling(pf_t *pf, int selective_resampling)$/;"	f
pf_t	amcl/include/amcl/pf/pf.h	/^} pf_t;$/;"	t	typeref:struct:_pf_t
pf_update_action	amcl/src/amcl/pf/pf.c	/^void pf_update_action(pf_t *pf, pf_action_model_fn_t action_fn, void *action_data)$/;"	f
pf_update_converged	amcl/src/amcl/pf/pf.c	/^int pf_update_converged(pf_t *pf)$/;"	f
pf_update_resample	amcl/src/amcl/pf/pf.c	/^void pf_update_resample(pf_t *pf)$/;"	f
pf_update_sensor	amcl/src/amcl/pf/pf.c	/^void pf_update_sensor(pf_t *pf, pf_sensor_model_fn_t sensor_fn, void *sensor_data)$/;"	f
pf_vector_add	amcl/src/amcl/pf/pf_vector.c	/^pf_vector_t pf_vector_add(pf_vector_t a, pf_vector_t b)$/;"	f
pf_vector_coord_add	amcl/src/amcl/pf/pf_vector.c	/^pf_vector_t pf_vector_coord_add(pf_vector_t a, pf_vector_t b)$/;"	f
pf_vector_coord_sub	amcl/src/amcl/pf/pf_vector.c	/^pf_vector_t pf_vector_coord_sub(pf_vector_t a, pf_vector_t b)$/;"	f
pf_vector_finite	amcl/src/amcl/pf/pf_vector.c	/^int pf_vector_finite(pf_vector_t a)$/;"	f
pf_vector_fprintf	amcl/src/amcl/pf/pf_vector.c	/^void pf_vector_fprintf(pf_vector_t a, FILE *file, const char *fmt)$/;"	f
pf_vector_sub	amcl/src/amcl/pf/pf_vector.c	/^pf_vector_t pf_vector_sub(pf_vector_t a, pf_vector_t b)$/;"	f
pf_vector_t	amcl/include/amcl/pf/pf_vector.h	/^} pf_vector_t;$/;"	t	typeref:struct:__anon5
pf_vector_zero	amcl/src/amcl/pf/pf_vector.c	/^pf_vector_t pf_vector_zero()$/;"	f
pf_z_	amcl/src/amcl_node.cpp	/^    double pf_err_, pf_z_;$/;"	m	class:AmclNode	file:
ph	navfn/include/navfn/navwin.h	/^      int pw,ph;			\/\/ width and height of pot field$/;"	m	class:navfn::NavWin
phi_v_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double max_angle_, phi_v_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
pivot_dim	amcl/include/amcl/pf/pf_kdtree.h	/^  int pivot_dim;$/;"	m	struct:pf_kdtree_node
pivot_value	amcl/include/amcl/pf/pf_kdtree.h	/^  double pivot_value;$/;"	m	struct:pf_kdtree_node
planService	move_base/src/move_base.cpp	/^    bool MoveBase::planService(nav_msgs::GetPlan::Request &req, nav_msgs::GetPlan::Response &resp){$/;"	f	class:move_base::MoveBase
planThread	move_base/src/move_base.cpp	/^    void MoveBase::planThread(){$/;"	f	class:move_base::MoveBase
plan_pub_	global_planner/include/global_planner/planner_core.h	/^        ros::Publisher plan_pub_;$/;"	m	class:global_planner::GlobalPlanner
plan_pub_	navfn/include/navfn/navfn_ros.h	/^      ros::Publisher plan_pub_;$/;"	m	class:navfn::NavfnROS
planner_	global_planner/include/global_planner/planner_core.h	/^        Expander* planner_;$/;"	m	class:global_planner::GlobalPlanner
planner_	move_base/include/move_base/move_base.h	/^      boost::shared_ptr<nav_core::BaseGlobalPlanner> planner_;$/;"	m	class:move_base::MoveBase
planner_	navfn/include/navfn/navfn_ros.h	/^      boost::shared_ptr<NavFn> planner_;$/;"	m	class:navfn::NavfnROS
planner_cond_	move_base/include/move_base/move_base.h	/^      boost::condition_variable_any planner_cond_;$/;"	m	class:move_base::MoveBase
planner_costmap_ros_	move_base/include/move_base/move_base.h	/^      costmap_2d::Costmap2DROS* planner_costmap_ros_, *controller_costmap_ros_;$/;"	m	class:move_base::MoveBase
planner_dynamic_reconfigure_service_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      ros::ServiceClient planner_dynamic_reconfigure_service_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
planner_frequency_	move_base/include/move_base/move_base.h	/^      double planner_frequency_, controller_frequency_, inscribed_radius_, circumscribed_radius_;$/;"	m	class:move_base::MoveBase
planner_goal_	move_base/include/move_base/move_base.h	/^      geometry_msgs::PoseStamped planner_goal_;$/;"	m	class:move_base::MoveBase
planner_mutex_	move_base/include/move_base/move_base.h	/^      boost::recursive_mutex planner_mutex_;$/;"	m	class:move_base::MoveBase
planner_nh_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      ros::NodeHandle private_nh_, planner_nh_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
planner_patience_	move_base/include/move_base/move_base.h	/^      double planner_patience_, controller_patience_;$/;"	m	class:move_base::MoveBase
planner_plan_	move_base/include/move_base/move_base.h	/^      std::vector<geometry_msgs::PoseStamped>* planner_plan_;$/;"	m	class:move_base::MoveBase
planner_thread_	move_base/include/move_base/move_base.h	/^      boost::thread* planner_thread_;$/;"	m	class:move_base::MoveBase
planner_util_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::LocalPlannerUtil *planner_util_;$/;"	m	class:dwa_local_planner::DWAPlanner
planner_util_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      base_local_planner::LocalPlannerUtil planner_util_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
planner_window_x_	global_planner/include/global_planner/planner_core.h	/^        double planner_window_x_, planner_window_y_, default_tolerance_;$/;"	m	class:global_planner::GlobalPlanner
planner_window_x_	navfn/include/navfn/navfn_ros.h	/^      double planner_window_x_, planner_window_y_, default_tolerance_;$/;"	m	class:navfn::NavfnROS
planner_window_y_	global_planner/include/global_planner/planner_core.h	/^        double planner_window_x_, planner_window_y_, default_tolerance_;$/;"	m	class:global_planner::GlobalPlanner
planner_window_y_	navfn/include/navfn/navfn_ros.h	/^      double planner_window_x_, planner_window_y_, default_tolerance_;$/;"	m	class:navfn::NavfnROS
planning_retries_	move_base/include/move_base/move_base.h	/^      uint32_t planning_retries_;$/;"	m	class:move_base::MoveBase
plugin_loader_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  pluginlib::ClassLoader<Layer> plugin_loader_;$/;"	m	class:costmap_2d::Costmap2DROS
plugins_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  std::vector<boost::shared_ptr<Layer> > plugins_;$/;"	m	class:costmap_2d::LayeredCostmap
pn	navfn/include/navfn/navwin.h	/^      int *pc, *pn, *po;		\/\/ priority buffers$/;"	m	class:navfn::NavWin
pne	navfn/include/navfn/navwin.h	/^      int pce, pne, poe;		\/\/ buffer sizes$/;"	m	class:navfn::NavWin
po	navfn/include/navfn/navwin.h	/^      int *pc, *pn, *po;		\/\/ priority buffers$/;"	m	class:navfn::NavWin
poe	navfn/include/navfn/navwin.h	/^      int pce, pne, poe;		\/\/ buffer sizes$/;"	m	class:navfn::NavWin
pointCloud2Callback	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::pointCloud2Callback(const sensor_msgs::PointCloud2ConstPtr& message,$/;"	f	class:costmap_2d::ObstacleLayer
pointCloudCallback	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::pointCloudCallback(const sensor_msgs::PointCloudConstPtr& message,$/;"	f	class:costmap_2d::ObstacleLayer
pointCost	base_local_planner/src/costmap_model.cpp	/^    double CostmapModel::pointCost(int x, int y) const {$/;"	f	class:base_local_planner::CostmapModel
pointCost	base_local_planner/src/trajectory_planner.cpp	/^  double TrajectoryPlanner::pointCost(int x, int y){$/;"	f	class:base_local_planner::TrajectoryPlanner
pointCost	base_local_planner/src/voxel_grid_model.cpp	/^  double VoxelGridModel::pointCost(int x, int y){$/;"	f	class:base_local_planner::VoxelGridModel
pointCostInflation	base_local_planner/src/costmap_model.cpp	/^    double CostmapModel::pointCostInflation(int x, int y) const {$/;"	f	class:base_local_planner::CostmapModel
points_	base_local_planner/include/base_local_planner/point_grid.h	/^      std::vector< std::list<geometry_msgs::Point32>* > points_;  \/\/\/< @brief The lists of points returned by a range search, made a member to save on memory allocation$/;"	m	class:base_local_planner::PointGrid
polygonOutlineCells	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::polygonOutlineCells(const std::vector<MapLocation>& polygon, std::vector<MapLocation>& polygon_cells)$/;"	f	class:costmap_2d::Costmap2D
pop_err	amcl/include/amcl/pf/pf.h	/^  double pop_err, pop_z;$/;"	m	struct:_pf_t
pop_z	amcl/include/amcl/pf/pf.h	/^  double pop_err, pop_z;$/;"	m	struct:_pf_t
pos_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  Eigen::Vector3f pos_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
pose	amcl/include/amcl/pf/pf.h	/^  pf_vector_t pose;$/;"	m	struct:__anon3
pose	amcl/include/amcl/sensors/amcl_odom.h	/^  public: pf_vector_t pose;$/;"	m	class:amcl::AMCLOdomData
pose	amcl/include/amcl/sensors/amcl_sensor.h	/^  public: pf_vector_t pose;$/;"	m	class:amcl::AMCLSensor
pose	amcl/test/set_pose.py	/^    pose = list(map(float, rospy.myargv()[1:4]))$/;"	v	class:PoseSetter
poseCallback	global_planner/src/plan_node.cpp	/^void PlannerWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal) {$/;"	f	class:global_planner::PlannerWithCostmap
poseCallback	navfn/src/navfn_node.cpp	/^void NavfnWithCostmap::poseCallback(const rm::PoseStamped::ConstPtr& goal) {$/;"	f	class:navfn::NavfnWithCostmap
pose_pub_	amcl/src/amcl_node.cpp	/^    ros::Publisher pose_pub_;$/;"	m	class:AmclNode	file:
pose_sub_	global_planner/src/plan_node.cpp	/^        ros::Subscriber pose_sub_;$/;"	m	class:global_planner::PlannerWithCostmap	file:
pose_sub_	navfn/src/navfn_node.cpp	/^  ros::Subscriber pose_sub_;$/;"	m	class:navfn::NavfnWithCostmap	file:
pot_value	navfn/include/navfn/potarr_point.h	/^        float pot_value;$/;"	m	struct:navfn::PotarrPoint
potarr	navfn/include/navfn/navfn.h	/^      float   *potarr;		\/**< potential array, navigation function potential *\/$/;"	m	class:navfn::NavFn
potarr_pub_	navfn/include/navfn/navfn_ros.h	/^      ros::Publisher potarr_pub_;$/;"	m	class:navfn::NavfnROS
potential_array_	global_planner/include/global_planner/planner_core.h	/^        float* potential_array_;$/;"	m	class:global_planner::GlobalPlanner
potential_pub_	global_planner/include/global_planner/planner_core.h	/^        ros::Publisher potential_pub_;$/;"	m	class:global_planner::GlobalPlanner
precise_	global_planner/include/global_planner/dijkstra.h	/^        bool precise_;$/;"	m	class:global_planner::DijkstraExpansion
prepare	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool prepare() {return true;};$/;"	f	class:base_local_planner::OscillationCostFunction
prepare	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^  bool prepare() {return true;};$/;"	f	class:base_local_planner::PreferForwardCostFunction
prepare	base_local_planner/include/base_local_planner/twirling_cost_function.h	/^  bool prepare() {return true;};$/;"	f	class:base_local_planner::TwirlingCostFunction
prepare	base_local_planner/src/map_grid_cost_function.cpp	/^    bool MapGridCostFunction::prepare() {$/;"	f	class:base_local_planner::MapGridCostFunction
prepare	base_local_planner/src/obstacle_cost_function.cpp	/^    bool ObstacleCostFunction::prepare() {$/;"	f	class:base_local_planner::ObstacleCostFunction
prepareGrid	costmap_2d/src/costmap_2d_publisher.cpp	/^    void Costmap2DPublisher::prepareGrid()$/;"	f	class:costmap_2d::Costmap2DPublisher
prev_stationary_pos_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  Eigen::Vector3f prev_stationary_pos_;$/;"	m	class:base_local_planner::OscillationCostFunction
prev_x_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double prev_x_, prev_y_; \/\/\/< @brief Used to calculate the distance the robot has traveled before reseting oscillation booleans$/;"	m	class:base_local_planner::TrajectoryPlanner
prev_y_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double prev_x_, prev_y_; \/\/\/< @brief Used to calculate the distance the robot has traveled before reseting oscillation booleans$/;"	m	class:base_local_planner::TrajectoryPlanner
priInc	navfn/include/navfn/navfn.h	/^      float priInc;			\/**< priority threshold increment *\/$/;"	m	class:navfn::NavFn
printColumnGrid	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::printColumnGrid(){$/;"	f	class:voxel_grid::VoxelGrid
printMap	costmap_2d/include/costmap_2d/testing_helper.h	/^void printMap(costmap_2d::Costmap2D& costmap)$/;"	f
printPSFooter	base_local_planner/src/point_grid_node.cpp	/^void printPSFooter(){$/;"	f
printPSHeader	base_local_planner/src/point_grid_node.cpp	/^void printPSHeader(){$/;"	f
printPoint	base_local_planner/src/point_grid_node.cpp	/^void printPoint(const geometry_msgs::Point& pt){$/;"	f
printPolygonPS	base_local_planner/src/point_grid_node.cpp	/^void printPolygonPS(const std::vector<geometry_msgs::Point32>& poly, double line_width){$/;"	f
printVoxelGrid	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::printVoxelGrid(){$/;"	f	class:voxel_grid::VoxelGrid
print_neighborhood_of_last_path_entry	navfn/test/path_calc_test.cpp	/^void print_neighborhood_of_last_path_entry( navfn::NavFn* nav )  $/;"	f
printableCost	costmap_2d/include/costmap_2d/testing_helper.h	/^char printableCost(unsigned char cost)$/;"	f
printableCost	costmap_2d/test/module_tests.cpp	/^char printableCost( unsigned char cost )$/;"	f
priorityIncrement_	global_planner/include/global_planner/dijkstra.h	/^        float priorityIncrement_; \/**< priority threshold increment *\/$/;"	m	class:global_planner::DijkstraExpansion
private_nh_	amcl/src/amcl_node.cpp	/^    ros::NodeHandle private_nh_;$/;"	m	class:AmclNode	file:
private_nh_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      ros::NodeHandle private_nh_, planner_nh_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
processFixedRangeMsg	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::processFixedRangeMsg(sensor_msgs::Range& range_message)$/;"	f	class:range_sensor_layer::RangeSensorLayer
processPath	global_planner/src/orientation_filter.cpp	/^void OrientationFilter::processPath(const geometry_msgs::PoseStamped& start, $/;"	f	class:global_planner::OrientationFilter
processRangeMessageFunc_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  boost::function<void(sensor_msgs::Range& range_message)> processRangeMessageFunc_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
processRangeMsg	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::processRangeMsg(sensor_msgs::Range& range_message)$/;"	f	class:range_sensor_layer::RangeSensorLayer
processVariableRangeMsg	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::processVariableRangeMsg(sensor_msgs::Range& range_message)$/;"	f	class:range_sensor_layer::RangeSensorLayer
projector_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  laser_geometry::LaserProjection projector_;  \/\/\/< @brief Used to project laser scans into point clouds$/;"	m	class:costmap_2d::ObstacleLayer
propNavFnAstar	navfn/src/navfn.cpp	/^    NavFn::propNavFnAstar(int cycles)	$/;"	f	class:navfn::NavFn
propNavFnDijkstra	navfn/src/navfn.cpp	/^    NavFn::propNavFnDijkstra(int cycles, bool atStart)	$/;"	f	class:navfn::NavFn
prunePlan	base_local_planner/src/goal_functions.cpp	/^  void prunePlan(const geometry_msgs::PoseStamped& global_pose, std::vector<geometry_msgs::PoseStamped>& plan, std::vector<geometry_msgs::PoseStamped>& global_plan){$/;"	f	namespace:base_local_planner
prune_plan	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  bool   prune_plan;$/;"	m	class:base_local_planner::LocalPlannerLimits
prune_plan_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool prune_plan_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
ptInPolygon	base_local_planner/src/point_grid.cpp	/^  bool PointGrid::ptInPolygon(const geometry_msgs::Point32& pt, const std::vector<geometry_msgs::Point>& poly){$/;"	f	class:base_local_planner::PointGrid
ptInScan	base_local_planner/src/point_grid.cpp	/^  bool PointGrid::ptInScan(const geometry_msgs::Point32& pt, const PlanarLaserScan& laser_scan){$/;"	f	class:base_local_planner::PointGrid
pub	amcl/test/set_pose.py	/^    pub = rospy.Publisher("initialpose", PoseWithCovarianceStamped, PoseSetter(pose, stamp=t_stamp, publish_time=t_publish), queue_size=1)$/;"	v	class:PoseSetter
pub_	base_local_planner/include/base_local_planner/map_grid_visualizer.h	/^            ros::Publisher pub_;$/;"	m	class:base_local_planner::MapGridVisualizer
publishCostCloud	base_local_planner/src/map_grid_visualizer.cpp	/^  void MapGridVisualizer::publishCostCloud(const costmap_2d::Costmap2D* costmap_p_) {$/;"	f	class:base_local_planner::MapGridVisualizer
publishCostmap	costmap_2d/src/costmap_2d_publisher.cpp	/^    void Costmap2DPublisher::publishCostmap()$/;"	f	class:costmap_2d::Costmap2DPublisher
publishGlobalPlan	dwa_local_planner/src/dwa_planner_ros.cpp	/^            void DWAPlannerROS::publishGlobalPlan(std::vector<geometry_msgs::PoseStamped>& path) {$/;"	f	class:dwa_local_planner::DWAPlannerROS
publishLocalPlan	dwa_local_planner/src/dwa_planner_ros.cpp	/^            void DWAPlannerROS::publishLocalPlan(std::vector<geometry_msgs::PoseStamped>& path) {$/;"	f	class:dwa_local_planner::DWAPlannerROS
publishOdom	fake_localization/static_odom_broadcaster.py	/^def publishOdom():$/;"	f
publishPlan	base_local_planner/src/goal_functions.cpp	/^  void publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, const ros::Publisher& pub) {$/;"	f	namespace:base_local_planner
publishPlan	global_planner/src/planner_core.cpp	/^void GlobalPlanner::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path) {$/;"	f	class:global_planner::GlobalPlanner
publishPlan	navfn/src/navfn_ros.cpp	/^  void NavfnROS::publishPlan(const std::vector<geometry_msgs::PoseStamped>& path, double r, double g, double b, double a){$/;"	f	class:navfn::NavfnROS
publishPotential	global_planner/src/planner_core.cpp	/^void GlobalPlanner::publishPotential(float* potential)$/;"	f	class:global_planner::GlobalPlanner
publishZeroVelocity	move_base/src/move_base.cpp	/^    void MoveBase::publishZeroVelocity(){$/;"	f	class:move_base::MoveBase
publish_cost_grid_pc_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      bool publish_cost_grid_pc_; \/\/\/< @brief Whether or not to build and publish a PointCloud$/;"	m	class:dwa_local_planner::DWAPlanner
publish_cycle	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  ros::Duration publish_cycle;$/;"	m	class:costmap_2d::Costmap2DROS
publish_potential_	global_planner/include/global_planner/planner_core.h	/^        bool publish_potential_;$/;"	m	class:global_planner::GlobalPlanner
publish_scale_	global_planner/include/global_planner/planner_core.h	/^        int publish_scale_;$/;"	m	class:global_planner::GlobalPlanner
publish_traj_pc_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      bool publish_traj_pc_;$/;"	m	class:dwa_local_planner::DWAPlanner
publish_voxel_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  bool publish_voxel_;$/;"	m	class:costmap_2d::VoxelLayer
publisher_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  Costmap2DPublisher* publisher_;$/;"	m	class:costmap_2d::Costmap2DROS
purgeStaleObservations	costmap_2d/src/observation_buffer.cpp	/^void ObservationBuffer::purgeStaleObservations()$/;"	f	class:costmap_2d::ObservationBuffer
push_cur	global_planner/include/global_planner/dijkstra.h	51;"	d
push_cur	navfn/src/navfn.cpp	351;"	d	file:
push_next	global_planner/include/global_planner/dijkstra.h	52;"	d
push_next	navfn/src/navfn.cpp	354;"	d	file:
push_over	global_planner/include/global_planner/dijkstra.h	53;"	d
push_over	navfn/src/navfn.cpp	357;"	d	file:
pw	navfn/include/navfn/navwin.h	/^      int pw,ph;			\/\/ width and height of pot field$/;"	m	class:navfn::NavWin
queue_	global_planner/include/global_planner/astar.h	/^        std::vector<Index> queue_;$/;"	m	class:global_planner::AStarExpansion
random_pose_data	amcl/include/amcl/pf/pf.h	/^  void *random_pose_data;$/;"	m	struct:_pf_t
random_pose_fn	amcl/include/amcl/pf/pf.h	/^  pf_init_model_fn_t random_pose_fn;$/;"	m	struct:_pf_t
range_count	amcl/include/amcl/sensors/amcl_laser.h	/^  public: int range_count;$/;"	m	class:amcl::AMCLLaserData
range_max	amcl/include/amcl/sensors/amcl_laser.h	/^  public: double range_max;$/;"	m	class:amcl::AMCLLaserData
range_message_mutex_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  boost::mutex range_message_mutex_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
range_msgs_buffer_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  std::list<sensor_msgs::Range> range_msgs_buffer_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
range_sensor_layer	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^namespace range_sensor_layer$/;"	n
range_sensor_layer	costmap_2d/plugins/range_sensor_layer.cpp	/^        namespace range_sensor_layer$/;"	n	file:
range_subs_	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  std::vector<ros::Subscriber> range_subs_;$/;"	m	class:range_sensor_layer::RangeSensorLayer
ranges	amcl/include/amcl/sensors/amcl_laser.h	/^  public: double (*ranges)[2];$/;"	m	class:amcl::AMCLLaserData
raytraceFreespace	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::raytraceFreespace(const Observation& clearing_observation, double* min_x, double* min_y,$/;"	f	class:costmap_2d::ObstacleLayer
raytraceFreespace	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::raytraceFreespace(const Observation& clearing_observation, double* min_x, double* min_y,$/;"	f	class:costmap_2d::VoxelLayer
raytraceLine	costmap_2d/include/costmap_2d/costmap_2d.h	/^    inline void raytraceLine(ActionType at, unsigned int x0, unsigned int y0, unsigned int x1, unsigned int y1,$/;"	f	class:costmap_2d::Costmap2D
raytraceLine	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline void raytraceLine($/;"	f	class:voxel_grid::VoxelGrid
raytrace_range_	costmap_2d/include/costmap_2d/observation.h	/^  double obstacle_range_, raytrace_range_;$/;"	m	class:costmap_2d::Observation
raytrace_range_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  double obstacle_range_, raytrace_range_;$/;"	m	class:costmap_2d::ObservationBuffer
reached_goal_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool reached_goal_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
readFootprintFromConfig	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::readFootprintFromConfig(const costmap_2d::Costmap2DConfig &new_config,$/;"	f	class:costmap_2d::Costmap2DROS
readPGM	navfn/src/navtest.cpp	/^readPGM(const char *fname, int *width, int *height, bool raw)$/;"	f
readPGM	navfn/src/read_pgm_costmap.cpp	/^readPGM(const char *fname, int *width, int *height, bool raw)$/;"	f
reallocTempData	amcl/src/amcl/sensors/amcl_laser.cpp	/^void AMCLLaser::reallocTempData(int new_max_samples, int new_max_obs){$/;"	f	class:AMCLLaser
reconfigure	base_local_planner/src/trajectory_planner.cpp	/^  void TrajectoryPlanner::reconfigure(BaseLocalPlannerConfig &cfg)$/;"	f	class:base_local_planner::TrajectoryPlanner
reconfigure	dwa_local_planner/src/dwa_planner.cpp	/^  void DWAPlanner::reconfigure(DWAPlannerConfig &config)$/;"	f	class:dwa_local_planner::DWAPlanner
reconfigureCB	amcl/src/amcl_node.cpp	/^void AmclNode::reconfigureCB(AMCLConfig &config, uint32_t level)$/;"	f	class:AmclNode
reconfigureCB	base_local_planner/src/local_planner_util.cpp	/^void LocalPlannerUtil::reconfigureCB(LocalPlannerLimits &config, bool restore_defaults)$/;"	f	class:base_local_planner::LocalPlannerUtil
reconfigureCB	base_local_planner/src/trajectory_planner_ros.cpp	/^  void TrajectoryPlannerROS::reconfigureCB(BaseLocalPlannerConfig &config, uint32_t level) {$/;"	f	class:base_local_planner::TrajectoryPlannerROS
reconfigureCB	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::reconfigureCB(costmap_2d::InflationPluginConfig &config, uint32_t level)$/;"	f	class:costmap_2d::InflationLayer
reconfigureCB	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::reconfigureCB(costmap_2d::ObstaclePluginConfig &config, uint32_t level)$/;"	f	class:costmap_2d::ObstacleLayer
reconfigureCB	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::reconfigureCB(range_sensor_layer::RangeSensorLayerConfig &config, uint32_t level)$/;"	f	class:range_sensor_layer::RangeSensorLayer
reconfigureCB	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::reconfigureCB(costmap_2d::GenericPluginConfig &config, uint32_t level)$/;"	f	class:costmap_2d::StaticLayer
reconfigureCB	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::reconfigureCB(costmap_2d::VoxelPluginConfig &config, uint32_t level)$/;"	f	class:costmap_2d::VoxelLayer
reconfigureCB	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::reconfigureCB(costmap_2d::Costmap2DConfig &config, uint32_t level)$/;"	f	class:costmap_2d::Costmap2DROS
reconfigureCB	dwa_local_planner/src/dwa_planner_ros.cpp	/^            void DWAPlannerROS::reconfigureCB(DWAPlannerConfig &config, uint32_t level) {$/;"	f	class:dwa_local_planner::DWAPlannerROS
reconfigureCB	global_planner/src/planner_core.cpp	/^void GlobalPlanner::reconfigureCB(global_planner::GlobalPlannerConfig& config, uint32_t level) {$/;"	f	class:global_planner::GlobalPlanner
reconfigureCB	move_base/src/move_base.cpp	/^    void MoveBase::reconfigureCB(move_base::MoveBaseConfig &config, uint32_t level){$/;"	f	class:move_base::MoveBase
recovery_behavior_enabled_	move_base/include/move_base/move_base.h	/^      bool shutdown_costmaps_, clearing_rotation_allowed_, recovery_behavior_enabled_;$/;"	m	class:move_base::MoveBase
recovery_behaviors_	move_base/include/move_base/move_base.h	/^      std::vector<boost::shared_ptr<nav_core::RecoveryBehavior> > recovery_behaviors_;$/;"	m	class:move_base::MoveBase
recovery_index_	move_base/include/move_base/move_base.h	/^      unsigned int recovery_index_;$/;"	m	class:move_base::MoveBase
recovery_loader_	move_base/include/move_base/move_base.h	/^      pluginlib::ClassLoader<nav_core::RecoveryBehavior> recovery_loader_;$/;"	m	class:move_base::MoveBase
recovery_trigger_	move_base/include/move_base/move_base.h	/^      RecoveryTrigger recovery_trigger_;$/;"	m	class:move_base::MoveBase
removePointsInPolygon	base_local_planner/src/point_grid.cpp	/^  void PointGrid::removePointsInPolygon(const std::vector<geometry_msgs::Point> poly){$/;"	f	class:base_local_planner::PointGrid
removePointsInScanBoundry	base_local_planner/src/point_grid.cpp	/^  void PointGrid::removePointsInScanBoundry(const PlanarLaserScan& laser_scan){$/;"	f	class:base_local_planner::PointGrid
removePointsInScanBoundry	base_local_planner/src/voxel_grid_model.cpp	/^  void VoxelGridModel::removePointsInScanBoundry(const PlanarLaserScan& laser_scan, double raytrace_range){$/;"	f	class:base_local_planner::VoxelGridModel
removeSpeedLimit	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    void MoveSlowAndClear::removeSpeedLimit()$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
remove_limit_thread_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      boost::thread* remove_limit_thread_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
requestMap	amcl/src/amcl_node.cpp	/^AmclNode::requestMap()$/;"	f	class:AmclNode
resample_count_	amcl/src/amcl_node.cpp	/^    int resample_count_;$/;"	m	class:AmclNode	file:
resample_interval_	amcl/src/amcl_node.cpp	/^    int resample_interval_;$/;"	m	class:AmclNode	file:
reset	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      void reset(){$/;"	f	class:base_local_planner::VelocityIterator
reset	costmap_2d/include/costmap_2d/inflation_layer.h	/^  virtual void reset() { onInitialize(); }$/;"	f	class:costmap_2d::InflationLayer
reset	costmap_2d/include/costmap_2d/layer.h	/^  virtual void reset() {}$/;"	f	class:costmap_2d::Layer
reset	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::reset()$/;"	f	class:costmap_2d::ObstacleLayer
reset	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::reset()$/;"	f	class:range_sensor_layer::RangeSensorLayer
reset	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::reset()$/;"	f	class:costmap_2d::StaticLayer
reset	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::reset()$/;"	f	class:costmap_2d::VoxelLayer
reset	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::reset(){$/;"	f	class:voxel_grid::VoxelGrid
resetLastUpdated	costmap_2d/src/observation_buffer.cpp	/^void ObservationBuffer::resetLastUpdated()$/;"	f	class:costmap_2d::ObservationBuffer
resetLatching	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^  void resetLatching() {$/;"	f	class:base_local_planner::LatchedStopRotateController
resetLayers	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::resetLayers()$/;"	f	class:costmap_2d::Costmap2DROS
resetMap	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::resetMap(unsigned int x0, unsigned int y0, unsigned int xn, unsigned int yn)$/;"	f	class:costmap_2d::Costmap2D
resetMaps	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::resetMaps()$/;"	f	class:costmap_2d::VoxelLayer
resetMaps	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::resetMaps()$/;"	f	class:costmap_2d::Costmap2D
resetOscillationFlags	base_local_planner/src/oscillation_cost_function.cpp	/^    void OscillationCostFunction::resetOscillationFlags() {$/;"	f	class:base_local_planner::OscillationCostFunction
resetOscillationFlagsIfPossible	base_local_planner/src/oscillation_cost_function.cpp	/^    void OscillationCostFunction::resetOscillationFlagsIfPossible(const Eigen::Vector3f& pos, const Eigen::Vector3f& prev) {$/;"	f	class:base_local_planner::OscillationCostFunction
resetPathDist	base_local_planner/src/map_grid.cpp	/^  void MapGrid::resetPathDist(){$/;"	f	class:base_local_planner::MapGrid
resetPoints	base_local_planner/src/trajectory.cpp	/^  void Trajectory::resetPoints(){$/;"	f	class:base_local_planner::Trajectory
resetRange	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::resetRange()$/;"	f	class:range_sensor_layer::RangeSensorLayer
resetState	move_base/src/move_base.cpp	/^    void MoveBase::resetState(){$/;"	f	class:move_base::MoveBase
reset_distance_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      double reset_distance_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
resize	voxel_grid/src/voxel_grid.cpp	/^  void VoxelGrid::resize(unsigned int size_x, unsigned int size_y, unsigned int size_z)$/;"	f	class:voxel_grid::VoxelGrid
resizeMap	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::resizeMap(unsigned int size_x, unsigned int size_y, double resolution,$/;"	f	class:costmap_2d::Costmap2D
resizeMap	costmap_2d/src/layered_costmap.cpp	/^    void LayeredCostmap::resizeMap(unsigned int size_x, unsigned int size_y, double resolution, double origin_x,$/;"	f	class:costmap_2d::LayeredCostmap
resolution	amcl/src/amcl_node.cpp	/^    double resolution;$/;"	m	class:AmclNode	file:
resolution	map_server/scripts/crop_map	/^    resolution = map_data["resolution"]$/;"	v
resolution_	base_local_planner/include/base_local_planner/point_grid.h	/^      double resolution_; \/\/\/< @brief The resolution of the grid in meters\/cell$/;"	m	class:base_local_planner::PointGrid
resolution_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  double resolution_;$/;"	m	class:costmap_2d::Costmap2D
resolution_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double resolution_;$/;"	m	class:costmap_2d::InflationLayer
restore_defaults	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  bool   restore_defaults;$/;"	m	class:base_local_planner::LocalPlannerLimits
result_traj_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::Trajectory result_traj_;$/;"	m	class:dwa_local_planner::DWAPlanner
resume	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::resume()$/;"	f	class:costmap_2d::Costmap2DROS
robot_base_frame_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      std::string robot_base_frame_; \/\/\/< @brief Used as the base frame id of the robot$/;"	m	class:base_local_planner::TrajectoryPlannerROS
robot_base_frame_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::string robot_base_frame_;  \/\/\/< @brief The frame_id of the robot base$/;"	m	class:costmap_2d::Costmap2DROS
robot_base_frame_	move_base/include/move_base/move_base.h	/^      std::string robot_base_frame_, global_frame_;$/;"	m	class:move_base::MoveBase
robot_stopped_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool stop_updates_, initialized_, stopped_, robot_stopped_;$/;"	m	class:costmap_2d::Costmap2DROS
rolling_window_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool rolling_window_;  \/\/\/ < @brief Whether or not the costmap should roll with the robot$/;"	m	class:costmap_2d::LayeredCostmap
rolling_window_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  bool rolling_window_;$/;"	m	class:costmap_2d::ObstacleLayer
root	amcl/include/amcl/pf/pf_kdtree.h	/^  pf_kdtree_node_t *root;$/;"	m	struct:__anon8
rot_neg_only_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool rot_pos_only_, rot_neg_only_, rotating_pos_, rotating_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
rot_pos_only_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool rot_pos_only_, rot_neg_only_, rotating_pos_, rotating_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
rot_stopped_velocity_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double rot_stopped_velocity_, trans_stopped_velocity_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
rotateToGoal	base_local_planner/src/latched_stop_rotate_controller.cpp	/^bool LatchedStopRotateController::rotateToGoal($/;"	f	class:base_local_planner::LatchedStopRotateController
rotateToGoal	base_local_planner/src/trajectory_planner_ros.cpp	/^  bool TrajectoryPlannerROS::rotateToGoal(const geometry_msgs::PoseStamped& global_pose, const geometry_msgs::PoseStamped& robot_vel, double goal_th, geometry_msgs::Twist& cmd_vel){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
rotate_recovery	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^namespace rotate_recovery$/;"	n
rotate_recovery	rotate_recovery/src/rotate_recovery.cpp	/^        namespace rotate_recovery$/;"	n	file:
rotating_left	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool rotating_left, rotating_right; \/\/\/< @brief Booleans to keep track of the direction of rotation for the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
rotating_neg_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool rot_pos_only_, rot_neg_only_, rotating_pos_, rotating_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
rotating_pos_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool rot_pos_only_, rot_neg_only_, rotating_pos_, rotating_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
rotating_right	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool rotating_left, rotating_right; \/\/\/< @brief Booleans to keep track of the direction of rotation for the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
rotating_to_goal_	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^  bool rotating_to_goal_;$/;"	m	class:base_local_planner::LatchedStopRotateController
rotating_to_goal_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool rotating_to_goal_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
runBehavior	clear_costmap_recovery/src/clear_costmap_recovery.cpp	/^            void ClearCostmapRecovery::runBehavior(){$/;"	f	class:clear_costmap_recovery::ClearCostmapRecovery
runBehavior	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    void MoveSlowAndClear::runBehavior()$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
runBehavior	rotate_recovery/src/rotate_recovery.cpp	/^    void RotateRecovery::runBehavior()$/;"	f	class:rotate_recovery::RotateRecovery
runFromBag	amcl/src/amcl_node.cpp	/^void AmclNode::runFromBag(const std::string &in_bag_fn, bool trigger_global_localization)$/;"	f	class:AmclNode
runPlanner_	move_base/include/move_base/move_base.h	/^      bool runPlanner_;$/;"	m	class:move_base::MoveBase
sample_count	amcl/include/amcl/pf/pf.h	/^  int sample_count;$/;"	m	struct:_pf_sample_set_t
sample_params_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  std::vector<Eigen::Vector3f> sample_params_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
samples	amcl/include/amcl/pf/pf.h	/^  pf_sample_t *samples;$/;"	m	struct:_pf_sample_set_t
samples_	base_local_planner/include/base_local_planner/velocity_iterator.h	/^      std::vector<double> samples_;$/;"	m	class:base_local_planner::VelocityIterator
saveMap	costmap_2d/src/costmap_2d.cpp	/^    bool Costmap2D::saveMap(std::string file_name)$/;"	f	class:costmap_2d::Costmap2D
savePoseToServer	amcl/src/amcl_node.cpp	/^void AmclNode::savePoseToServer()$/;"	f	class:AmclNode
save_pose_last_time	amcl/src/amcl_node.cpp	/^    ros::Time save_pose_last_time;$/;"	m	class:AmclNode	file:
save_pose_period	amcl/src/amcl_node.cpp	/^    ros::Duration save_pose_period;$/;"	m	class:AmclNode	file:
saved_map_	map_server/src/map_saver.cpp	/^    bool saved_map_;$/;"	m	class:MapGenerator	file:
saved_origin_x_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  double saved_origin_x_, saved_origin_y_;$/;"	m	class:costmap_2d::Costmap2DPublisher
saved_origin_y_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  double saved_origin_x_, saved_origin_y_;$/;"	m	class:costmap_2d::Costmap2DPublisher
savemap	navfn/src/navfn.cpp	/^    NavFn::savemap(const char *fname)$/;"	f	class:navfn::NavFn
scale	amcl/include/amcl/map/map.h	/^  double scale;$/;"	m	struct:__anon2
scale_	amcl/src/amcl/map/map_cspace.cpp	/^    double scale_;$/;"	m	class:CachedDistanceMap	file:
scale_	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^  double scale_;$/;"	m	class:base_local_planner::TrajectoryCostFunction
scaling_speed_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  double max_scaling_factor_, scaling_speed_;$/;"	m	class:base_local_planner::ObstacleCostFunction
scan_topic_	amcl/src/amcl_node.cpp	/^static const std::string scan_topic_ = "scan";$/;"	v	file:
scoreTrajectory	base_local_planner/src/map_grid_cost_function.cpp	/^   double MapGridCostFunction::scoreTrajectory(Trajectory &traj) {$/;"	f	class:base_local_planner::MapGridCostFunction
scoreTrajectory	base_local_planner/src/obstacle_cost_function.cpp	/^    double ObstacleCostFunction::scoreTrajectory(Trajectory &traj) {$/;"	f	class:base_local_planner::ObstacleCostFunction
scoreTrajectory	base_local_planner/src/oscillation_cost_function.cpp	/^    double OscillationCostFunction::scoreTrajectory(Trajectory &traj) {$/;"	f	class:base_local_planner::OscillationCostFunction
scoreTrajectory	base_local_planner/src/prefer_forward_cost_function.cpp	/^    double PreferForwardCostFunction::scoreTrajectory(Trajectory &traj) {$/;"	f	class:base_local_planner::PreferForwardCostFunction
scoreTrajectory	base_local_planner/src/simple_scored_sampling_planner.cpp	/^    double SimpleScoredSamplingPlanner::scoreTrajectory(Trajectory& traj, double best_traj_cost) {$/;"	f	class:base_local_planner::SimpleScoredSamplingPlanner
scoreTrajectory	base_local_planner/src/trajectory_planner.cpp	/^  double TrajectoryPlanner::scoreTrajectory(double x, double y, double theta, double vx, double vy,$/;"	f	class:base_local_planner::TrajectoryPlanner
scoreTrajectory	base_local_planner/src/trajectory_planner_ros.cpp	/^  double TrajectoryPlannerROS::scoreTrajectory(double vx_samp, double vy_samp, double vtheta_samp, bool update_map){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
scoreTrajectory	base_local_planner/src/twirling_cost_function.cpp	/^    double TwirlingCostFunction::scoreTrajectory(Trajectory &traj) {$/;"	f	class:base_local_planner::TwirlingCostFunction
scored_sampling_planner_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::SimpleScoredSamplingPlanner scored_sampling_planner_;$/;"	m	class:dwa_local_planner::DWAPlanner
seen_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  bool* seen_;$/;"	m	class:costmap_2d::InflationLayer
seen_size_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  int seen_size_;$/;"	m	class:costmap_2d::InflationLayer
segIntersect	base_local_planner/include/base_local_planner/point_grid.h	/^      inline bool segIntersect(const geometry_msgs::Point32& v1, const geometry_msgs::Point32& v2,$/;"	f	class:base_local_planner::PointGrid
selective_resampling	amcl/include/amcl/pf/pf.h	/^  int selective_resampling;$/;"	m	struct:_pf_t
selective_resampling_	amcl/src/amcl_node.cpp	/^    bool selective_resampling_;$/;"	m	class:AmclNode	file:
sensor	amcl/include/amcl/sensors/amcl_sensor.h	/^  public: AMCLSensor *sensor;$/;"	m	class:amcl::AMCLSensorData
sensor_frame_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  std::string sensor_frame_;$/;"	m	class:costmap_2d::ObservationBuffer
sensor_model	costmap_2d/plugins/range_sensor_layer.cpp	/^    double RangeSensorLayer::sensor_model(double r, double phi, double theta)$/;"	f	class:range_sensor_layer::RangeSensorLayer
sent_first_transform_	amcl/src/amcl_node.cpp	/^    bool sent_first_transform_;$/;"	m	class:AmclNode	file:
service	map_server/src/main.cpp	/^    ros::ServiceServer service;$/;"	m	class:MapServer	file:
setAngleBasedOnPositionDerivative	global_planner/src/orientation_filter.cpp	/^void OrientationFilter::setAngleBasedOnPositionDerivative(std::vector<geometry_msgs::PoseStamped>& path, int index)$/;"	f	class:global_planner::OrientationFilter
setArray	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  void setArray(XmlRpc::XmlRpcValue::ValueArray* a)$/;"	f	class:SuperValue
setConvexPolygonCost	costmap_2d/src/costmap_2d.cpp	/^    bool Costmap2D::setConvexPolygonCost(const std::vector<geometry_msgs::Point>& polygon, unsigned char cost_value)$/;"	f	class:costmap_2d::Costmap2D
setCost	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::setCost(unsigned int mx, unsigned int my, unsigned char cost)$/;"	f	class:costmap_2d::Costmap2D
setCostmap	navfn/src/navfn.cpp	/^    NavFn::setCostmap(const COSTTYPE *cmap, bool isROS, bool allow_unknown)$/;"	f	class:navfn::NavFn
setDefaultValue	costmap_2d/include/costmap_2d/costmap_2d.h	/^  void setDefaultValue(unsigned char c)$/;"	f	class:costmap_2d::Costmap2D
setFactor	global_planner/include/global_planner/expander.h	/^        void setFactor(float factor) {$/;"	f	class:global_planner::Expander
setFootprint	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      void setFootprint( std::vector<geometry_msgs::Point> footprint ) { footprint_spec_ = footprint; }$/;"	f	class:base_local_planner::TrajectoryPlanner
setFootprint	base_local_planner/src/obstacle_cost_function.cpp	/^    void ObstacleCostFunction::setFootprint(std::vector<geometry_msgs::Point> footprint_spec) {$/;"	f	class:base_local_planner::ObstacleCostFunction
setFootprint	costmap_2d/src/layered_costmap.cpp	/^    void LayeredCostmap::setFootprint(const std::vector<geometry_msgs::Point>& footprint_spec)$/;"	f	class:costmap_2d::LayeredCostmap
setGlobalFrame	costmap_2d/src/observation_buffer.cpp	/^bool ObservationBuffer::setGlobalFrame(const std::string new_global_frame)$/;"	f	class:costmap_2d::ObservationBuffer
setGoal	navfn/src/navfn.cpp	/^    NavFn::setGoal(int *g)$/;"	f	class:navfn::NavFn
setHasUnknown	global_planner/include/global_planner/expander.h	/^        void setHasUnknown(bool unknown) {$/;"	f	class:global_planner::Expander
setInflationParameters	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::setInflationParameters(double inflation_radius, double cost_scaling_factor)$/;"	f	class:costmap_2d::InflationLayer
setLethalCost	global_planner/include/global_planner/expander.h	/^        void setLethalCost(unsigned char lethal_cost) {$/;"	f	class:global_planner::Expander
setLethalCost	global_planner/include/global_planner/traceback.h	/^        void setLethalCost(unsigned char lethal_cost) {$/;"	f	class:global_planner::Traceback
setLocalGoal	base_local_planner/src/map_grid.cpp	/^  void MapGrid::setLocalGoal(const costmap_2d::Costmap2D& costmap,$/;"	f	class:base_local_planner::MapGrid
setMapCallback	amcl/src/amcl_node.cpp	/^AmclNode::setMapCallback(nav_msgs::SetMap::Request& req,$/;"	f	class:AmclNode
setMode	global_planner/include/global_planner/orientation_filter.h	/^        void setMode(OrientationMode new_mode){ omode_ = new_mode; }$/;"	f	class:global_planner::OrientationFilter
setMode	global_planner/include/global_planner/orientation_filter.h	/^        void setMode(int new_mode){ setMode((OrientationMode) new_mode); }$/;"	f	class:global_planner::OrientationFilter
setNavArr	navfn/src/navfn.cpp	/^    NavFn::setNavArr(int xs, int ys)$/;"	f	class:navfn::NavFn
setNeutralCost	global_planner/include/global_planner/dijkstra.h	/^        void setNeutralCost(unsigned char neutral_cost) {$/;"	f	class:global_planner::DijkstraExpansion
setNeutralCost	global_planner/include/global_planner/expander.h	/^        void setNeutralCost(unsigned char neutral_cost) {$/;"	f	class:global_planner::Expander
setOdomTopic	base_local_planner/src/odometry_helper_ros.cpp	/^void OdometryHelperRos::setOdomTopic(std::string odom_topic)$/;"	f	class:base_local_planner::OdometryHelperRos
setOscillationFlags	base_local_planner/src/oscillation_cost_function.cpp	/^    bool OscillationCostFunction::setOscillationFlags(base_local_planner::Trajectory* t, double min_vel_trans) {$/;"	f	class:base_local_planner::OscillationCostFunction
setOscillationResetDist	base_local_planner/src/oscillation_cost_function.cpp	/^    void OscillationCostFunction::setOscillationResetDist(double dist, double angle) {$/;"	f	class:base_local_planner::OscillationCostFunction
setParameters	base_local_planner/src/simple_trajectory_generator.cpp	/^void SimpleTrajectoryGenerator::setParameters($/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
setParams	base_local_planner/src/obstacle_cost_function.cpp	/^    void ObstacleCostFunction::setParams(double max_trans_vel, double max_scaling_factor, double scaling_speed) {$/;"	f	class:base_local_planner::ObstacleCostFunction
setPenalty	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^  void setPenalty(double penalty) {$/;"	f	class:base_local_planner::PreferForwardCostFunction
setPlan	base_local_planner/src/local_planner_util.cpp	/^bool LocalPlannerUtil::setPlan(const std::vector<geometry_msgs::PoseStamped>& orig_global_plan) {$/;"	f	class:base_local_planner::LocalPlannerUtil
setPlan	base_local_planner/src/trajectory_planner_ros.cpp	/^  bool TrajectoryPlannerROS::setPlan(const std::vector<geometry_msgs::PoseStamped>& orig_global_plan){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
setPlan	dwa_local_planner/src/dwa_planner.cpp	/^  bool DWAPlanner::setPlan(const std::vector<geometry_msgs::PoseStamped>& orig_global_plan) {$/;"	f	class:dwa_local_planner::DWAPlanner
setPlan	dwa_local_planner/src/dwa_planner_ros.cpp	/^            bool DWAPlannerROS::setPlan(const std::vector<geometry_msgs::PoseStamped>& orig_global_plan) {$/;"	f	class:dwa_local_planner::DWAPlannerROS
setPoint	base_local_planner/src/trajectory.cpp	/^  void Trajectory::setPoint(unsigned int index, double x, double y, double th){$/;"	f	class:base_local_planner::Trajectory
setPreciseStart	global_planner/include/global_planner/dijkstra.h	/^        void setPreciseStart(bool precise){ precise_ = precise; }$/;"	f	class:global_planner::DijkstraExpansion
setRadii	costmap_2d/test/inflation_tests.cpp	/^std::vector<Point> setRadii(LayeredCostmap& layers, double length, double width, double inflation_radius)$/;"	f
setRobotSpeed	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    void MoveSlowAndClear::setRobotSpeed(double trans_speed, double rot_speed)$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
setScale	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^  void setScale(double scale) {$/;"	f	class:base_local_planner::TrajectoryCostFunction
setSize	global_planner/include/global_planner/expander.h	/^        virtual void setSize(int nx, int ny) {$/;"	f	class:global_planner::Expander
setSize	global_planner/include/global_planner/potential_calculator.h	/^        virtual void setSize(int nx, int ny) {$/;"	f	class:global_planner::PotentialCalculator
setSize	global_planner/include/global_planner/traceback.h	/^        virtual void setSize(int xs, int ys) {$/;"	f	class:global_planner::Traceback
setSize	global_planner/src/dijkstra.cpp	/^void DijkstraExpansion::setSize(int xs, int ys) {$/;"	f	class:global_planner::DijkstraExpansion
setSize	global_planner/src/gradient_path.cpp	/^void GradientPath::setSize(int xs, int ys) {$/;"	f	class:global_planner::GradientPath
setStart	navfn/src/navfn.cpp	/^    NavFn::setStart(int *g)$/;"	f	class:navfn::NavFn
setStopOnFailure	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  void setStopOnFailure(bool stop_on_failure) {stop_on_failure_ = stop_on_failure;}$/;"	f	class:base_local_planner::MapGridCostFunction
setStruct	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  void setStruct(XmlRpc::XmlRpcValue::ValueStruct* a)$/;"	f	class:SuperValue
setSumScores	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  void setSumScores(bool score_sums){ sum_scores_=score_sums; }$/;"	f	class:base_local_planner::ObstacleCostFunction
setTargetCells	base_local_planner/src/map_grid.cpp	/^  void MapGrid::setTargetCells(const costmap_2d::Costmap2D& costmap,$/;"	f	class:base_local_planner::MapGrid
setTargetPoses	base_local_planner/src/map_grid_cost_function.cpp	/^    void MapGridCostFunction::setTargetPoses(std::vector<geometry_msgs::PoseStamped> target_poses) {$/;"	f	class:base_local_planner::MapGridCostFunction
setTmpCost	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::setTmpCost(unsigned int mx, unsigned int my, unsigned char cost)$/;"	f	class:costmap_2d::Costmap2D
setUnpaddedRobotFootprint	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::setUnpaddedRobotFootprint(const std::vector<geometry_msgs::Point>& points)$/;"	f	class:costmap_2d::Costmap2DROS
setUnpaddedRobotFootprintPolygon	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::setUnpaddedRobotFootprintPolygon(const geometry_msgs::Polygon& footprint)$/;"	f	class:costmap_2d::Costmap2DROS
setUp	amcl/test/basic_localization.py	/^    def setUp(self):$/;"	m	class:TestBasicLocalization
setValues	costmap_2d/include/costmap_2d/testing_helper.h	/^void setValues(costmap_2d::Costmap2D& costmap, const unsigned char* map)$/;"	f
setWindowSize	global_planner/include/global_planner/orientation_filter.h	/^        void setWindowSize(size_t window_size){ window_size_ = window_size; }$/;"	f	class:global_planner::OrientationFilter
setXShift	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  void setXShift(double xshift) {xshift_ = xshift;}$/;"	f	class:base_local_planner::MapGridCostFunction
setYShift	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  void setYShift(double yshift) {yshift_ = yshift;}$/;"	f	class:base_local_planner::MapGridCostFunction
set_angle	global_planner/src/orientation_filter.cpp	/^void set_angle(geometry_msgs::PoseStamped* pose, double angle)$/;"	f	namespace:global_planner
set_map_srv_	amcl/src/amcl_node.cpp	/^    ros::ServiceServer set_map_srv_;$/;"	m	class:AmclNode	file:
setcostobs	navfn/src/navtest.cpp	/^setcostobs(COSTTYPE *cmap, int n, int w)$/;"	f
setcostobs	navfn/src/read_pgm_costmap.cpp	/^setcostobs(COSTTYPE *cmap, int n, int w)$/;"	f
setcostunk	navfn/src/navtest.cpp	/^void setcostunk(COSTTYPE *cmap, int n, int w)$/;"	f
setcostunk	navfn/src/read_pgm_costmap.cpp	/^void setcostunk(COSTTYPE *cmap, int n, int w)$/;"	f
sets	amcl/include/amcl/pf/pf.h	/^  pf_sample_set_t sets[2];$/;"	m	struct:_pf_t
setupDynamicReconfigure	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::setupDynamicReconfigure(ros::NodeHandle& nh)$/;"	f	class:costmap_2d::ObstacleLayer
setupDynamicReconfigure	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::setupDynamicReconfigure(ros::NodeHandle& nh)$/;"	f	class:costmap_2d::VoxelLayer
setupNavFn	navfn/src/navfn.cpp	/^    NavFn::setupNavFn(bool keepit)$/;"	f	class:navfn::NavFn
setup_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  bool setup_;$/;"	m	class:base_local_planner::LocalPlannerUtil
setup_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool setup_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
setup_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      bool setup_;$/;"	m	class:dwa_local_planner::DWAPlannerROS
setup_	move_base/include/move_base/move_base.h	/^      bool setup_, p_freq_change_, c_freq_change_;$/;"	m	class:move_base::MoveBase
setup_testclass_singleton	base_local_planner/test/utest.cpp	/^TrajectoryPlannerTest* setup_testclass_singleton() {$/;"	f	namespace:base_local_planner
shutdown_costmaps_	move_base/include/move_base/move_base.h	/^      bool shutdown_costmaps_, clearing_rotation_allowed_, recovery_behavior_enabled_;$/;"	m	class:move_base::MoveBase
sigintHandler	amcl/src/amcl_node.cpp	/^void sigintHandler(int sig)$/;"	f
sigma_hit	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double sigma_hit;$/;"	m	class:amcl::AMCLLaser
sigma_hit_	amcl/src/amcl_node.cpp	/^    double z_hit_, z_short_, z_max_, z_rand_, sigma_hit_, lambda_short_;$/;"	m	class:AmclNode	file:
sign	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^  inline double sign(double x){$/;"	f	class:base_local_planner::LatchedStopRotateController
sign	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double sign(double x){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
sign	costmap_2d/include/costmap_2d/costmap_2d.h	/^  inline int sign(int x)$/;"	f	class:costmap_2d::Costmap2D
sign	costmap_2d/include/costmap_2d/costmap_math.h	/^inline double sign(double x)$/;"	f
sign	voxel_grid/include/voxel_grid/voxel_grid.h	/^  inline int sign(int i)$/;"	f	class:voxel_grid::VoxelGrid
sign0	costmap_2d/include/costmap_2d/costmap_math.h	/^inline double sign0(double x)$/;"	f
sim_granularity_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  double sim_time_, sim_granularity_, angular_sim_granularity_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
sim_granularity_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double sim_granularity_; \/\/\/< @brief The distance between simulation points$/;"	m	class:base_local_planner::TrajectoryPlanner
sim_granularity_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  double sim_granularity_, min_rotational_vel_, max_rotational_vel_, acc_lim_th_, tolerance_, frequency_;$/;"	m	class:rotate_recovery::RotateRecovery
sim_period_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  double sim_period_; \/\/ only for dwa$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
sim_period_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double sim_period_; \/\/\/< @brief The number of seconds to use to compute max\/min vels for dwa$/;"	m	class:base_local_planner::TrajectoryPlanner
sim_period_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double sim_period_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
sim_period_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double sim_period_;\/\/\/< @brief The number of seconds to use to compute max\/min vels for dwa$/;"	m	class:dwa_local_planner::DWAPlanner
sim_time_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  double sim_time_, sim_granularity_, angular_sim_granularity_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
sim_time_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double sim_time_; \/\/\/< @brief The number of seconds each trajectory is "rolled-out"$/;"	m	class:base_local_planner::TrajectoryPlanner
simple_attractor_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool simple_attractor_;  \/\/\/< @brief Enables simple attraction to a goal point$/;"	m	class:base_local_planner::TrajectoryPlanner
size	amcl/include/amcl/pf/pf_kdtree.h	/^  double size[3];$/;"	m	struct:__anon8
sizeCheck	base_local_planner/src/map_grid.cpp	/^  void MapGrid::sizeCheck(unsigned int size_x, unsigned int size_y){$/;"	f	class:base_local_planner::MapGrid
sizeX	voxel_grid/src/voxel_grid.cpp	/^  unsigned int VoxelGrid::sizeX(){$/;"	f	class:voxel_grid::VoxelGrid
sizeY	voxel_grid/src/voxel_grid.cpp	/^  unsigned int VoxelGrid::sizeY(){$/;"	f	class:voxel_grid::VoxelGrid
sizeZ	voxel_grid/src/voxel_grid.cpp	/^  unsigned int VoxelGrid::sizeZ(){$/;"	f	class:voxel_grid::VoxelGrid
size_locked_	costmap_2d/include/costmap_2d/layered_costmap.h	/^  bool size_locked_;$/;"	m	class:costmap_2d::LayeredCostmap
size_x	amcl/include/amcl/map/map.h	/^  int size_x, size_y;$/;"	m	struct:__anon2
size_x_	base_local_planner/include/base_local_planner/map_grid.h	/^      unsigned int size_x_, size_y_; \/\/\/< @brief The dimensions of the grid$/;"	m	class:base_local_planner::MapGrid
size_x_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned int size_x_;$/;"	m	class:costmap_2d::Costmap2D
size_x_	voxel_grid/include/voxel_grid/voxel_grid.h	/^  unsigned int size_x_, size_y_, size_z_;$/;"	m	class:voxel_grid::VoxelGrid
size_y	amcl/include/amcl/map/map.h	/^  int size_x, size_y;$/;"	m	struct:__anon2
size_y_	base_local_planner/include/base_local_planner/map_grid.h	/^      unsigned int size_x_, size_y_; \/\/\/< @brief The dimensions of the grid$/;"	m	class:base_local_planner::MapGrid
size_y_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned int size_y_;$/;"	m	class:costmap_2d::Costmap2D
size_y_	voxel_grid/include/voxel_grid/voxel_grid.h	/^  unsigned int size_x_, size_y_, size_z_;$/;"	m	class:voxel_grid::VoxelGrid
size_z_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  unsigned int unknown_threshold_, mark_threshold_, size_z_;$/;"	m	class:costmap_2d::VoxelLayer
size_z_	voxel_grid/include/voxel_grid/voxel_grid.h	/^  unsigned int size_x_, size_y_, size_z_;$/;"	m	class:voxel_grid::VoxelGrid
speed_limit_pose_	move_slow_and_clear/include/move_slow_and_clear/move_slow_and_clear.h	/^      geometry_msgs::PoseStamped speed_limit_pose_;$/;"	m	class:move_slow_and_clear::MoveSlowAndClear
sq_distance	base_local_planner/include/base_local_planner/point_grid.h	/^      inline double sq_distance(const geometry_msgs::Point32& pt1, const geometry_msgs::Point32& pt2){$/;"	f	class:base_local_planner::PointGrid
sq_distance	navfn/include/navfn/navfn_ros.h	/^      inline double sq_distance(const geometry_msgs::PoseStamped& p1, const geometry_msgs::PoseStamped& p2){$/;"	f	class:navfn::NavfnROS
sq_min_separation_	base_local_planner/include/base_local_planner/point_grid.h	/^      double sq_min_separation_;  \/\/\/< @brief The minimum square distance required between points in the grid$/;"	m	class:base_local_planner::PointGrid
sq_obstacle_range_	base_local_planner/include/base_local_planner/point_grid.h	/^      double sq_obstacle_range_;  \/\/\/< @brief The square distance at which we no longer add obstacles to the grid$/;"	m	class:base_local_planner::PointGrid
sq_obstacle_range_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double sq_obstacle_range_;  \/\/\/< @brief The square distance at which we no longer add obstacles to the grid$/;"	m	class:base_local_planner::VoxelGridModel
srand48	amcl/src/include/portable_utils.hpp	/^static void srand48(long int seedval)$/;"	f
src_i_	amcl/src/amcl/map/map_cspace.cpp	/^    unsigned int src_i_, src_j_;$/;"	m	class:CellData	file:
src_j_	amcl/src/amcl/map/map_cspace.cpp	/^    unsigned int src_i_, src_j_;$/;"	m	class:CellData	file:
src_x_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int src_x_, src_y_;$/;"	m	class:costmap_2d::CellData
src_y_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int src_x_, src_y_;$/;"	m	class:costmap_2d::CellData
standardDeviationDiagnostics	amcl/src/amcl_node.cpp	/^AmclNode::standardDeviationDiagnostics(diagnostic_updater::DiagnosticStatusWrapper& diagnostic_status)$/;"	f	class:AmclNode
start	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::start()$/;"	f	class:costmap_2d::Costmap2DROS
start	navfn/include/navfn/navfn.h	/^      int start[2];$/;"	m	class:navfn::NavFn
start	navfn/include/navfn/navwin.h	/^      int start[2];$/;"	m	class:navfn::NavWin
start	navfn/src/navtest.cpp	/^int start[2];$/;"	v
start_x_	global_planner/include/global_planner/planner_core.h	/^        unsigned int start_x_, start_y_, end_x_, end_y_;$/;"	m	class:global_planner::GlobalPlanner
start_y_	global_planner/include/global_planner/planner_core.h	/^        unsigned int start_x_, start_y_, end_x_, end_y_;$/;"	m	class:global_planner::GlobalPlanner
state_	move_base/include/move_base/move_base.h	/^      MoveBaseState state_;$/;"	m	class:move_base::MoveBase
static_clearing_observations_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<costmap_2d::Observation> static_clearing_observations_, static_marking_observations_;$/;"	m	class:costmap_2d::ObstacleLayer
static_marking_observations_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<costmap_2d::Observation> static_clearing_observations_, static_marking_observations_;$/;"	m	class:costmap_2d::ObstacleLayer
status	costmap_2d/src/costmap_2d_cloud.cpp	/^  voxel_grid::VoxelStatus status;$/;"	m	struct:Cell	file:
status	costmap_2d/src/costmap_2d_markers.cpp	/^  voxel_grid::VoxelStatus status;$/;"	m	struct:Cell	file:
std_warn_level_x_	amcl/src/amcl_node.cpp	/^    double std_warn_level_x_;$/;"	m	class:AmclNode	file:
std_warn_level_y_	amcl/src/amcl_node.cpp	/^    double std_warn_level_y_;$/;"	m	class:AmclNode	file:
std_warn_level_yaw_	amcl/src/amcl_node.cpp	/^    double std_warn_level_yaw_;$/;"	m	class:AmclNode	file:
step_size_	carrot_planner/include/carrot_planner/carrot_planner.h	/^      double step_size_, min_dist_from_robot_;$/;"	m	class:carrot_planner::CarrotPlanner
stop	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::stop()$/;"	f	class:costmap_2d::Costmap2DROS
stopWithAccLimits	base_local_planner/src/latched_stop_rotate_controller.cpp	/^bool LatchedStopRotateController::stopWithAccLimits(const geometry_msgs::PoseStamped& global_pose,$/;"	f	class:base_local_planner::LatchedStopRotateController
stopWithAccLimits	base_local_planner/src/trajectory_planner_ros.cpp	/^  bool TrajectoryPlannerROS::stopWithAccLimits(const geometry_msgs::PoseStamped& global_pose, const geometry_msgs::PoseStamped& robot_vel, geometry_msgs::Twist& cmd_vel){$/;"	f	class:base_local_planner::TrajectoryPlannerROS
stop_on_failure_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  bool stop_on_failure_;$/;"	m	class:base_local_planner::MapGridCostFunction
stop_time_buffer_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      double stop_time_buffer_; \/\/\/< @brief How long before hitting something we're going to enforce that the robot stop$/;"	m	class:base_local_planner::TrajectoryPlanner
stop_time_buffer_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      double stop_time_buffer_; \/\/\/< @brief How long before hitting something we're going to enforce that the robot stop$/;"	m	class:dwa_local_planner::DWAPlanner
stop_updates_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool stop_updates_, initialized_, stopped_, robot_stopped_;$/;"	m	class:costmap_2d::Costmap2DROS
stopped	base_local_planner/src/goal_functions.cpp	/^  bool stopped(const nav_msgs::Odometry& base_odom, $/;"	f	namespace:base_local_planner
stopped_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  bool stop_updates_, initialized_, stopped_, robot_stopped_;$/;"	m	class:costmap_2d::Costmap2DROS
strafe_left	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool strafe_right, strafe_left; \/\/\/< @brief Booleans to keep track of strafe direction for the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
strafe_neg_only_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool strafe_pos_only_, strafe_neg_only_, strafing_pos_, strafing_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
strafe_pos_only_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool strafe_pos_only_, strafe_neg_only_, strafing_pos_, strafing_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
strafe_right	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool strafe_right, strafe_left; \/\/\/< @brief Booleans to keep track of strafe direction for the robot$/;"	m	class:base_local_planner::TrajectoryPlanner
strafing_neg_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool strafe_pos_only_, strafe_neg_only_, strafing_pos_, strafing_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
strafing_pos_	base_local_planner/include/base_local_planner/oscillation_cost_function.h	/^  bool strafe_pos_only_, strafe_neg_only_, strafing_pos_, strafing_neg_;$/;"	m	class:base_local_planner::OscillationCostFunction
stripSlash	amcl/src/amcl_node.cpp	/^std::string stripSlash(const std::string& in)$/;"	f
stuck_left	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool stuck_left, stuck_right; \/\/\/< @brief Booleans to keep the robot from oscillating during rotation$/;"	m	class:base_local_planner::TrajectoryPlanner
stuck_left_strafe	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool stuck_left_strafe, stuck_right_strafe; \/\/\/< @brief Booleans to keep the robot from oscillating during strafing$/;"	m	class:base_local_planner::TrajectoryPlanner
stuck_right	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool stuck_left, stuck_right; \/\/\/< @brief Booleans to keep the robot from oscillating during rotation$/;"	m	class:base_local_planner::TrajectoryPlanner
stuck_right_strafe	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      bool stuck_left_strafe, stuck_right_strafe; \/\/\/< @brief Booleans to keep the robot from oscillating during strafing$/;"	m	class:base_local_planner::TrajectoryPlanner
stuffFilter	fake_localization/fake_localization.cpp	/^    void stuffFilter(const nav_msgs::OdometryConstPtr& odom_msg){$/;"	f	class:FakeOdomNode
stuff_sub_	fake_localization/fake_localization.cpp	/^    ros::Subscriber stuff_sub_; $/;"	m	class:FakeOdomNode	file:
subscribe_to_updates_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool subscribe_to_updates_;$/;"	m	class:costmap_2d::StaticLayer
sum_scores_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  bool sum_scores_;$/;"	m	class:base_local_planner::ObstacleCostFunction
sx	amcl/src/amcl_node.cpp	/^    int sx, sy;$/;"	m	class:AmclNode	file:
sy	amcl/src/amcl_node.cpp	/^    int sx, sy;$/;"	m	class:AmclNode	file:
synchronize	base_local_planner/test/wavefront_map_accessor.h	/^    void synchronize(){$/;"	f	class:base_local_planner::WavefrontMapAccessor
t_publish	amcl/test/set_pose.py	/^    t_publish = rospy.Time()$/;"	v	class:PoseSetter
t_stamp	amcl/test/set_pose.py	/^    t_stamp = rospy.Time()$/;"	v	class:PoseSetter
target_dist	base_local_planner/include/base_local_planner/map_cell.h	/^      double target_dist; \/\/\/< @brief Distance to planner's path$/;"	m	class:base_local_planner::MapCell
target_mark	base_local_planner/include/base_local_planner/map_cell.h	/^      bool target_mark; \/\/\/< @brief Marks for computing path\/goal distances$/;"	m	class:base_local_planner::MapCell
target_poses_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  std::vector<geometry_msgs::PoseStamped> target_poses_;$/;"	m	class:base_local_planner::MapGridCostFunction
tc	base_local_planner/test/utest.cpp	/^    TrajectoryPlanner tc;$/;"	m	class:base_local_planner::TrajectoryPlannerTest	file:
tc_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      TrajectoryPlanner* tc_; \/\/\/< @brief The trajectory controller$/;"	m	class:base_local_planner::TrajectoryPlannerROS
tc_	move_base/include/move_base/move_base.h	/^      boost::shared_ptr<nav_core::BaseLocalPlanner> tc_;$/;"	m	class:move_base::MoveBase
tct	base_local_planner/test/utest.cpp	/^TrajectoryPlannerTest* tct = NULL;$/;"	m	namespace:base_local_planner	file:
temp_obs	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double **temp_obs;$/;"	m	class:amcl::AMCLLaser
testCallback	costmap_2d/test/costmap_tester.cpp	/^void testCallback(const ros::TimerEvent& e){$/;"	f
testClearBehavior	clear_costmap_recovery/test/clear_tester.cpp	/^void testClearBehavior(std::string name, $/;"	f
testCountLethal	clear_costmap_recovery/test/clear_tester.cpp	/^void testCountLethal(std::string name, double distance, bool obstacles, bool static_map, int global_lethal, int local_lethal=0)$/;"	f
test_basic_localization	amcl/test/basic_localization.py	/^    def test_basic_localization(self):$/;"	m	class:TestBasicLocalization
test_consumer	map_server/test/consumer.py	/^    def test_consumer(self):$/;"	m	class:TestConsumer
tf2_buffer_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  tf2_ros::Buffer& tf2_buffer_;$/;"	m	class:costmap_2d::ObservationBuffer
tf_	amcl/src/amcl_node.cpp	/^    std::shared_ptr<tf2_ros::Buffer> tf_;$/;"	m	class:AmclNode	file:
tf_	base_local_planner/include/base_local_planner/local_planner_util.h	/^  tf2_ros::Buffer* tf_;$/;"	m	class:base_local_planner::LocalPlannerUtil
tf_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      tf2_ros::Buffer* tf_; \/\/\/< @brief Used for transforming point clouds$/;"	m	class:base_local_planner::TrajectoryPlannerROS
tf_	clear_costmap_recovery/include/clear_costmap_recovery/clear_costmap_recovery.h	/^      tf2_ros::Buffer* tf_;$/;"	m	class:clear_costmap_recovery::ClearCostmapRecovery
tf_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  tf2_ros::Buffer& tf_;  \/\/\/< @brief Used for transforming point clouds$/;"	m	class:costmap_2d::Costmap2DROS
tf_	costmap_2d/include/costmap_2d/layer.h	/^  tf2_ros::Buffer *tf_;$/;"	m	class:costmap_2d::Layer
tf_	costmap_2d/test/footprint_tests.cpp	/^tf2_ros::Buffer* tf_;$/;"	v
tf_	dwa_local_planner/include/dwa_local_planner/dwa_planner_ros.h	/^      tf2_ros::Buffer* tf_; \/\/\/< @brief Used for transforming point clouds$/;"	m	class:dwa_local_planner::DWAPlannerROS
tf_	move_base/include/move_base/move_base.h	/^      tf2_ros::Buffer& tf_;$/;"	m	class:move_base::MoveBase
tf_broadcast_	amcl/src/amcl_node.cpp	/^    bool tf_broadcast_;$/;"	m	class:AmclNode	file:
tf_cb	amcl/test/basic_localization.py	/^    def tf_cb(self, msg):$/;"	m	class:TestBasicLocalization
tf_tolerance_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  double tf_tolerance_;$/;"	m	class:costmap_2d::ObservationBuffer
tfb_	amcl/src/amcl_node.cpp	/^    std::shared_ptr<tf2_ros::TransformBroadcaster> tfb_;$/;"	m	class:AmclNode	file:
tfl	clear_costmap_recovery/test/clear_tester.cpp	/^tf2_ros::TransformListener* tfl;$/;"	v
tfl_	amcl/src/amcl_node.cpp	/^    std::shared_ptr<tf2_ros::TransformListener> tfl_;$/;"	m	class:AmclNode	file:
tg	base_local_planner/test/trajectory_generator_test.cpp	/^	SimpleTrajectoryGenerator tg;$/;"	m	class:base_local_planner::TrajectoryGeneratorTest	file:
th_pts_	base_local_planner/include/base_local_planner/trajectory.h	/^      std::vector<double> th_pts_; \/\/\/< @brief The theta points in the trajectory$/;"	m	class:base_local_planner::Trajectory
theta_stopped_vel	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double theta_stopped_vel;$/;"	m	class:base_local_planner::LocalPlannerLimits
thetav_	base_local_planner/include/base_local_planner/trajectory.h	/^      double xv_, yv_, thetav_; \/\/\/< @brief The x, y, and theta velocities of the trajectory$/;"	m	class:base_local_planner::Trajectory
threshold_	global_planner/include/global_planner/dijkstra.h	/^        float threshold_; \/**< current threshold *\/$/;"	m	class:global_planner::DijkstraExpansion
threshold_free_	map_server/src/map_saver.cpp	/^    int threshold_free_;$/;"	m	class:MapGenerator	file:
threshold_occupied_	map_server/src/map_saver.cpp	/^    int threshold_occupied_;$/;"	m	class:MapGenerator	file:
time	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double time;$/;"	m	class:amcl::AMCLLaser
time	amcl/include/amcl/sensors/amcl_odom.h	/^  private: double time;$/;"	m	class:amcl::AMCLOdom
time	amcl/include/amcl/sensors/amcl_sensor.h	/^  public: double time;$/;"	m	class:amcl::AMCLSensorData
time_delta_	base_local_planner/include/base_local_planner/trajectory.h	/^      double time_delta_; \/\/\/< @brief The time gap between points$/;"	m	class:base_local_planner::Trajectory
timer_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  ros::Timer timer_;$/;"	m	class:costmap_2d::Costmap2DROS
tmp_costmap_	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned char* tmp_costmap_;$/;"	m	class:costmap_2d::Costmap2D
toIndex	global_planner/include/global_planner/expander.h	/^        inline int toIndex(int x, int y) {$/;"	f	class:global_planner::Expander
toIndex	global_planner/include/global_planner/potential_calculator.h	/^        inline int toIndex(int x, int y) {$/;"	f	class:global_planner::PotentialCalculator
toPoint	costmap_2d/src/footprint.cpp	/^geometry_msgs::Point toPoint(geometry_msgs::Point32 pt)$/;"	f	namespace:costmap_2d
toPoint32	costmap_2d/src/footprint.cpp	/^geometry_msgs::Point32 toPoint32(geometry_msgs::Point pt)$/;"	f	namespace:costmap_2d
toPointVector	costmap_2d/src/footprint.cpp	/^std::vector<geometry_msgs::Point> toPointVector(geometry_msgs::Polygon polygon)$/;"	f	namespace:costmap_2d
toPolygon	costmap_2d/src/footprint.cpp	/^geometry_msgs::Polygon toPolygon(std::vector<geometry_msgs::Point> pts)$/;"	f	namespace:costmap_2d
to_cost	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  unsigned char to_cost(double p)$/;"	f	class:range_sensor_layer::RangeSensorLayer
to_prob	costmap_2d/include/costmap_2d/range_sensor_layer.h	/^  double to_prob(unsigned char c)$/;"	f	class:range_sensor_layer::RangeSensorLayer
tolerance_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  double sim_granularity_, min_rotational_vel_, max_rotational_vel_, acc_lim_th_, tolerance_, frequency_;$/;"	m	class:rotate_recovery::RotateRecovery
topic_name_	costmap_2d/include/costmap_2d/observation_buffer.h	/^  std::string topic_name_;$/;"	m	class:costmap_2d::ObservationBuffer
touch	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::touch(double x, double y, double* min_x, double* min_y, double* max_x, double* max_y)$/;"	f	class:costmap_2d::CostmapLayer
tql2	amcl/src/amcl/pf/eig3.c	/^static void tql2(double V[n][n], double d[n], double e[n]) {$/;"	f	file:
track_unknown_space_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool track_unknown_space_;$/;"	m	class:costmap_2d::StaticLayer
traj_cloud_pub_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      ros::Publisher traj_cloud_pub_;$/;"	m	class:dwa_local_planner::DWAPlanner
traj_one	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      Trajectory traj_one, traj_two; \/\/\/< @brief Used for scoring trajectories$/;"	m	class:base_local_planner::TrajectoryPlanner
traj_two	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      Trajectory traj_one, traj_two; \/\/\/< @brief Used for scoring trajectories$/;"	m	class:base_local_planner::TrajectoryPlanner
trans_stopped_vel	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double trans_stopped_vel;$/;"	m	class:base_local_planner::LocalPlannerLimits
trans_stopped_velocity_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double rot_stopped_velocity_, trans_stopped_velocity_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
transformFootprint	costmap_2d/src/footprint.cpp	/^void transformFootprint(double x, double y, double theta, const std::vector<geometry_msgs::Point>& footprint_spec,$/;"	f	namespace:costmap_2d
transformGlobalPlan	base_local_planner/src/goal_functions.cpp	/^  bool transformGlobalPlan($/;"	f	namespace:base_local_planner
transform_tolerance_	amcl/src/amcl_node.cpp	/^    ros::Duration transform_tolerance_;$/;"	m	class:AmclNode	file:
transform_tolerance_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  double transform_tolerance_;  \/\/\/< timeout before transform errors$/;"	m	class:costmap_2d::Costmap2DROS
transform_tolerance_	fake_localization/fake_localization.cpp	/^    double transform_tolerance_;$/;"	m	class:FakeOdomNode	file:
transformed_footprint_	costmap_2d/include/costmap_2d/obstacle_layer.h	/^  std::vector<geometry_msgs::Point> transformed_footprint_;$/;"	m	class:costmap_2d::ObstacleLayer
transformer	clear_costmap_recovery/test/clear_tester.cpp	/^tf2_ros::Buffer* transformer;$/;"	v
tred2	amcl/src/amcl/pf/eig3.c	/^static void tred2(double V[n][n], double d[n], double e[n]) {$/;"	f	file:
trinary_costmap_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool trinary_costmap_;$/;"	m	class:costmap_2d::StaticLayer
twirling_costs_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      base_local_planner::TwirlingCostFunction twirling_costs_;$/;"	m	class:dwa_local_planner::DWAPlanner
uniformPoseGenerator	amcl/src/amcl_node.cpp	/^AmclNode::uniformPoseGenerator(void* arg)$/;"	f	class:AmclNode
unknown_	global_planner/include/global_planner/expander.h	/^        bool unknown_;$/;"	m	class:global_planner::Expander
unknown_clear_threshold_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned int unknown_clear_threshold_, marked_clear_threshold_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxelInMap
unknown_cost_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned char free_cost_, unknown_cost_;$/;"	m	class:voxel_grid::VoxelGrid::ClearVoxelInMap
unknown_cost_value_	costmap_2d/include/costmap_2d/static_layer.h	/^  unsigned char lethal_threshold_, unknown_cost_value_;$/;"	m	class:costmap_2d::StaticLayer
unknown_gray	navfn/src/navtest.cpp	237;"	d	file:
unknown_gray	navfn/src/read_pgm_costmap.cpp	70;"	d	file:
unknown_threshold_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  unsigned int unknown_threshold_, mark_threshold_, size_z_;$/;"	m	class:costmap_2d::VoxelLayer
unlock	costmap_2d/include/costmap_2d/observation_buffer.h	/^  inline void unlock()$/;"	f	class:costmap_2d::ObservationBuffer
unpadded_footprint_	costmap_2d/include/costmap_2d/costmap_2d_ros.h	/^  std::vector<geometry_msgs::Point> unpadded_footprint_;$/;"	m	class:costmap_2d::Costmap2DROS
unreachableCellCosts	base_local_planner/include/base_local_planner/map_grid.h	/^      inline double unreachableCellCosts() {$/;"	f	class:base_local_planner::MapGrid
unreachableCellCosts	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  double unreachableCellCosts() {$/;"	f	class:base_local_planner::MapGridCostFunction
update	fake_localization/fake_localization.cpp	/^    void update(const nav_msgs::OdometryConstPtr& message){$/;"	f	class:FakeOdomNode
updateBounds	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  void updateBounds(unsigned int x0, unsigned int xn, unsigned int y0, unsigned int yn)$/;"	f	class:costmap_2d::Costmap2DPublisher
updateBounds	costmap_2d/include/costmap_2d/layer.h	/^  virtual void updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x, double* min_y,$/;"	f	class:costmap_2d::Layer
updateBounds	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x,$/;"	f	class:costmap_2d::InflationLayer
updateBounds	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x,$/;"	f	class:costmap_2d::ObstacleLayer
updateBounds	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::updateBounds(double robot_x, double robot_y, double robot_yaw,$/;"	f	class:range_sensor_layer::RangeSensorLayer
updateBounds	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x, double* min_y,$/;"	f	class:costmap_2d::StaticLayer
updateBounds	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::updateBounds(double robot_x, double robot_y, double robot_yaw, double* min_x,$/;"	f	class:costmap_2d::VoxelLayer
updateCell	global_planner/src/dijkstra.cpp	/^inline void DijkstraExpansion::updateCell(unsigned char* costs, float* potential, int n) {$/;"	f	class:global_planner::DijkstraExpansion
updateCell	navfn/src/navfn.cpp	/^    NavFn::updateCell(int n)$/;"	f	class:navfn::NavFn
updateCellAstar	navfn/src/navfn.cpp	/^    NavFn::updateCellAstar(int n)$/;"	f	class:navfn::NavFn
updateCostmap	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::updateCostmap()$/;"	f	class:range_sensor_layer::RangeSensorLayer
updateCostmap	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::updateCostmap(sensor_msgs::Range& range_message, bool clear_sensor_cone)$/;"	f	class:range_sensor_layer::RangeSensorLayer
updateCosts	costmap_2d/include/costmap_2d/layer.h	/^  virtual void updateCosts(Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j) {}$/;"	f	class:costmap_2d::Layer
updateCosts	costmap_2d/plugins/inflation_layer.cpp	/^    void InflationLayer::updateCosts(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::InflationLayer
updateCosts	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::updateCosts(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::ObstacleLayer
updateCosts	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::updateCosts(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:range_sensor_layer::RangeSensorLayer
updateCosts	costmap_2d/plugins/static_layer.cpp	/^    void StaticLayer::updateCosts(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::StaticLayer
updateFootprint	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::updateFootprint(double robot_x, double robot_y, double robot_yaw, double* min_x, double* min_y,$/;"	f	class:costmap_2d::ObstacleLayer
updateMap	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::updateMap()$/;"	f	class:costmap_2d::Costmap2DROS
updateMap	costmap_2d/src/layered_costmap.cpp	/^    void LayeredCostmap::updateMap(double robot_x, double robot_y, double robot_yaw)$/;"	f	class:costmap_2d::LayeredCostmap
updateOrigin	costmap_2d/plugins/voxel_layer.cpp	/^void VoxelLayer::updateOrigin(double new_origin_x, double new_origin_y)$/;"	f	class:costmap_2d::VoxelLayer
updateOrigin	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::updateOrigin(double new_origin_x, double new_origin_y)$/;"	f	class:costmap_2d::Costmap2D
updateOscillationFlags	base_local_planner/src/oscillation_cost_function.cpp	/^    void OscillationCostFunction::updateOscillationFlags(Eigen::Vector3f pos, base_local_planner::Trajectory* traj, double min_vel_trans) {$/;"	f	class:base_local_planner::OscillationCostFunction
updatePathCell	base_local_planner/src/map_grid.cpp	/^  inline bool MapGrid::updatePathCell(MapCell* current_cell, MapCell* check_cell,$/;"	f	class:base_local_planner::MapGrid
updatePlan	base_local_planner/src/trajectory_planner.cpp	/^  void TrajectoryPlanner::updatePlan(const vector<geometry_msgs::PoseStamped>& new_plan, bool compute_dists){$/;"	f	class:base_local_planner::TrajectoryPlanner
updatePlanAndLocalCosts	dwa_local_planner/src/dwa_planner.cpp	/^  void DWAPlanner::updatePlanAndLocalCosts($/;"	f	class:dwa_local_planner::DWAPlanner
updatePoseFromServer	amcl/src/amcl_node.cpp	/^void AmclNode::updatePoseFromServer()$/;"	f	class:AmclNode
updateRaytraceBounds	costmap_2d/plugins/obstacle_layer.cpp	/^    void ObstacleLayer::updateRaytraceBounds(double ox, double oy, double wx, double wy, double range,$/;"	f	class:costmap_2d::ObstacleLayer
updateWithAddition	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::updateWithAddition(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::CostmapLayer
updateWithMax	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::updateWithMax(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::CostmapLayer
updateWithOverwrite	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::updateWithOverwrite(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::CostmapLayer
updateWithTmp	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::updateWithTmp(costmap_2d::Costmap2D& master_grid, int min_i, int min_j, int max_i, int max_j)$/;"	f	class:costmap_2d::CostmapLayer
updateWithTrueOverwrite	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::updateWithTrueOverwrite(costmap_2d::Costmap2D& master_grid, int min_i, int min_j,$/;"	f	class:costmap_2d::CostmapLayer
updateWorld	base_local_planner/src/point_grid.cpp	/^  void PointGrid::updateWorld(const std::vector<geometry_msgs::Point>& footprint,$/;"	f	class:base_local_planner::PointGrid
updateWorld	base_local_planner/src/voxel_grid_model.cpp	/^  void VoxelGridModel::updateWorld(const std::vector<geometry_msgs::Point>& footprint, $/;"	f	class:base_local_planner::VoxelGridModel
update_cell	costmap_2d/plugins/range_sensor_layer.cpp	/^    void RangeSensorLayer::update_cell(double ox, double oy, double ot, double r, double nx, double ny, bool clear)$/;"	f	class:range_sensor_layer::RangeSensorLayer
useExtraBounds	costmap_2d/src/costmap_layer.cpp	/^    void CostmapLayer::useExtraBounds(double* min_x, double* min_y, double* max_x, double* max_y)$/;"	f	class:costmap_2d::CostmapLayer
use_dwa_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  bool use_dwa_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
use_map_topic_	amcl/src/amcl_node.cpp	/^    bool use_map_topic_;$/;"	m	class:AmclNode	file:
use_maximum_	costmap_2d/include/costmap_2d/static_layer.h	/^  bool use_maximum_;$/;"	m	class:costmap_2d::StaticLayer
v	amcl/include/amcl/pf/pf_vector.h	/^  double v[3];$/;"	m	struct:__anon5
validPointPotential	navfn/src/navfn_ros.cpp	/^  bool NavfnROS::validPointPotential(const geometry_msgs::Point& world_point){$/;"	f	class:navfn::NavfnROS
validPointPotential	navfn/src/navfn_ros.cpp	/^  bool NavfnROS::validPointPotential(const geometry_msgs::Point& world_point, double tolerance){$/;"	f	class:navfn::NavfnROS
validatePointInflation	costmap_2d/test/inflation_tests.cpp	/^void validatePointInflation(unsigned int mx, unsigned int my, Costmap2D* costmap, InflationLayer* ilayer, double inflation_radius)$/;"	f
value	amcl/include/amcl/pf/pf_kdtree.h	/^  double value;$/;"	m	struct:pf_kdtree_node
value_	costmap_2d/include/costmap_2d/costmap_2d.h	/^    unsigned char value_;$/;"	m	class:costmap_2d::Costmap2D::MarkCell
vel_	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  Eigen::Vector3f vel_;$/;"	m	class:base_local_planner::SimpleTrajectoryGenerator
vel_pub_	move_base/include/move_base/move_base.h	/^      ros::Publisher current_goal_pub_, vel_pub_, action_goal_pub_;$/;"	m	class:move_base::MoveBase
visualize_potential_	navfn/include/navfn/navfn_ros.h	/^      bool initialized_, allow_unknown_, visualize_potential_;$/;"	m	class:navfn::NavfnROS
voxelCallback	costmap_2d/src/costmap_2d_cloud.cpp	/^void voxelCallback(const ros::Publisher& pub_marked, const ros::Publisher& pub_unknown,$/;"	f
voxelCallback	costmap_2d/src/costmap_2d_markers.cpp	/^void voxelCallback(const ros::Publisher& pub, const costmap_2d::VoxelGridConstPtr& grid)$/;"	f
voxel_dsrv_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  dynamic_reconfigure::Server<costmap_2d::VoxelPluginConfig> *voxel_dsrv_;$/;"	m	class:costmap_2d::VoxelLayer
voxel_grid	voxel_grid/include/voxel_grid/voxel_grid.h	/^namespace voxel_grid$/;"	n
voxel_grid	voxel_grid/src/voxel_grid.cpp	/^namespace voxel_grid {$/;"	n	file:
voxel_grid_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  voxel_grid::VoxelGrid voxel_grid_;$/;"	m	class:costmap_2d::VoxelLayer
voxel_pub_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  ros::Publisher voxel_pub_;$/;"	m	class:costmap_2d::VoxelLayer
vsamples_	dwa_local_planner/include/dwa_local_planner/dwa_planner.h	/^      Eigen::Vector3f vsamples_;$/;"	m	class:dwa_local_planner::DWAPlanner
vtheta_samples_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      int vtheta_samples_; \/\/\/< @brief The number of samples we'll take in the theta dimension of the control space$/;"	m	class:base_local_planner::TrajectoryPlanner
vx_samples_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      int vx_samples_; \/\/\/< @brief The number of samples we'll take in the x dimenstion of the control space$/;"	m	class:base_local_planner::TrajectoryPlanner
w_fast	amcl/include/amcl/pf/pf.h	/^  double w_slow, w_fast;$/;"	m	struct:_pf_t
w_slow	amcl/include/amcl/pf/pf.h	/^  double w_slow, w_fast;$/;"	m	struct:_pf_t
wa	base_local_planner/test/utest.cpp	/^    WavefrontMapAccessor* wa;$/;"	m	class:base_local_planner::TrajectoryPlannerTest	file:
wakePlanner	move_base/src/move_base.cpp	/^    void MoveBase::wakePlanner(const ros::TimerEvent& event)$/;"	f	class:move_base::MoveBase
warnForOldParameters	costmap_2d/src/costmap_2d_ros.cpp	/^    void Costmap2DROS::warnForOldParameters(ros::NodeHandle& nh)$/;"	f	class:costmap_2d::Costmap2DROS
warnRenamedParameter	nav_core/include/nav_core/parameter_magic.h	/^void warnRenamedParameter(const ros::NodeHandle& nh, const std::string current_name, const std::string old_name)$/;"	f	namespace:nav_core
weight	amcl/include/amcl/pf/pf.h	/^  double weight;$/;"	m	struct:__anon3
weight	amcl/include/amcl/pf/pf.h	/^  double weight;$/;"	m	struct:__anon4
weight	amcl/src/amcl_node.cpp	/^  double weight;$/;"	m	struct:__anon11	file:
weight_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  double weight_;$/;"	m	class:costmap_2d::InflationLayer
width_	base_local_planner/include/base_local_planner/point_grid.h	/^      unsigned int width_; \/\/\/< @brief The width of the grid in cells$/;"	m	class:base_local_planner::PointGrid
width_	costmap_2d/include/costmap_2d/static_layer.h	/^  unsigned int x_, y_, width_, height_;$/;"	m	class:costmap_2d::StaticLayer
window_size_	global_planner/include/global_planner/orientation_filter.h	/^        int window_size_;$/;"	m	class:global_planner::OrientationFilter
within_robot	base_local_planner/include/base_local_planner/map_cell.h	/^      bool within_robot; \/\/\/< @brief Mark for cells within the robot footprint$/;"	m	class:base_local_planner::MapCell
worldToIndex	costmap_2d/test/module_tests.cpp	/^unsigned int worldToIndex(Costmap2D& map, double wx, double wy){$/;"	f
worldToMap	costmap_2d/src/costmap_2d.cpp	/^    bool Costmap2D::worldToMap(double wx, double wy, unsigned int& mx, unsigned int& my) const$/;"	f	class:costmap_2d::Costmap2D
worldToMap	global_planner/src/planner_core.cpp	/^bool GlobalPlanner::worldToMap(double wx, double wy, double& mx, double& my) {$/;"	f	class:global_planner::GlobalPlanner
worldToMap2D	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      inline bool worldToMap2D(double wx, double wy, unsigned int& mx, unsigned int& my){$/;"	f	class:base_local_planner::VoxelGridModel
worldToMap3D	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      inline bool worldToMap3D(double wx, double wy, double wz, unsigned int& mx, unsigned int& my, unsigned int& mz){$/;"	f	class:base_local_planner::VoxelGridModel
worldToMap3D	costmap_2d/include/costmap_2d/voxel_layer.h	/^  inline bool worldToMap3D(double wx, double wy, double wz, unsigned int& mx, unsigned int& my, unsigned int& mz)$/;"	f	class:costmap_2d::VoxelLayer
worldToMap3DFloat	costmap_2d/include/costmap_2d/voxel_layer.h	/^  inline bool worldToMap3DFloat(double wx, double wy, double wz, double& mx, double& my, double& mz)$/;"	f	class:costmap_2d::VoxelLayer
worldToMapEnforceBounds	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::worldToMapEnforceBounds(double wx, double wy, int& mx, int& my) const$/;"	f	class:costmap_2d::Costmap2D
worldToMapNoBounds	costmap_2d/src/costmap_2d.cpp	/^    void Costmap2D::worldToMapNoBounds(double wx, double wy, int& mx, int& my) const$/;"	f	class:costmap_2d::Costmap2D
world_model_	base_local_planner/include/base_local_planner/obstacle_cost_function.h	/^  base_local_planner::WorldModel* world_model_;$/;"	m	class:base_local_planner::ObstacleCostFunction
world_model_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      WorldModel& world_model_; \/\/\/< @brief The world model that the controller uses for collision detection$/;"	m	class:base_local_planner::TrajectoryPlanner
world_model_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      WorldModel* world_model_; \/\/\/< @brief The world model that the controller will use$/;"	m	class:base_local_planner::TrajectoryPlannerROS
world_model_	carrot_planner/include/carrot_planner/carrot_planner.h	/^      base_local_planner::WorldModel* world_model_; \/\/\/< @brief The world model that the controller will use$/;"	m	class:carrot_planner::CarrotPlanner
world_model_	rotate_recovery/include/rotate_recovery/rotate_recovery.h	/^  base_local_planner::CostmapModel* world_model_;$/;"	m	class:rotate_recovery::RotateRecovery
writeFootprintToParam	costmap_2d/src/footprint.cpp	/^void writeFootprintToParam(ros::NodeHandle& nh, const std::vector<geometry_msgs::Point>& footprint)$/;"	f	namespace:costmap_2d
x	amcl/include/amcl/pf/pf_pdf.h	/^  pf_vector_t x;$/;"	m	struct:__anon7
x	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned int x;$/;"	m	struct:costmap_2d::MapLocation
x	costmap_2d/src/costmap_2d_cloud.cpp	/^  double x;$/;"	m	struct:Cell	file:
x	costmap_2d/src/costmap_2d_markers.cpp	/^  double x;$/;"	m	struct:Cell	file:
x	navfn/include/navfn/potarr_point.h	/^        float x;$/;"	m	struct:navfn::PotarrPoint
x0_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int x0_; \/\/\/< X coordinate of first end point.$/;"	m	class:base_local_planner::LineIterator
x0_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  unsigned int x0_, xn_, y0_, yn_;$/;"	m	class:costmap_2d::Costmap2DPublisher
x1_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int x1_; \/\/\/< X coordinate of second end point.$/;"	m	class:base_local_planner::LineIterator
x_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int x_; \/\/\/< X coordinate of current point.$/;"	m	class:base_local_planner::LineIterator
x_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int x_, y_;$/;"	m	class:costmap_2d::CellData
x_	costmap_2d/include/costmap_2d/static_layer.h	/^  unsigned int x_, y_, width_, height_;$/;"	m	class:costmap_2d::StaticLayer
x_pts_	base_local_planner/include/base_local_planner/trajectory.h	/^      std::vector<double> x_pts_; \/\/\/< @brief The x points in the trajectory$/;"	m	class:base_local_planner::Trajectory
xinc1_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int xinc1_, xinc2_, yinc1_, yinc2_;$/;"	m	class:base_local_planner::LineIterator
xinc2_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int xinc1_, xinc2_, yinc1_, yinc2_;$/;"	m	class:base_local_planner::LineIterator
xn_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  unsigned int x0_, xn_, y0_, yn_;$/;"	m	class:costmap_2d::Costmap2DPublisher
xs_	global_planner/include/global_planner/traceback.h	/^        int xs_, ys_;$/;"	m	class:global_planner::Traceback
xshift_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  double xshift_;$/;"	m	class:base_local_planner::MapGridCostFunction
xv_	base_local_planner/include/base_local_planner/trajectory.h	/^      double xv_, yv_, thetav_; \/\/\/< @brief The x, y, and theta velocities of the trajectory$/;"	m	class:base_local_planner::Trajectory
xy_goal_tolerance	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double xy_goal_tolerance;$/;"	m	class:base_local_planner::LocalPlannerLimits
xy_goal_tolerance_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double xy_goal_tolerance_, yaw_goal_tolerance_, min_in_place_vel_th_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
xy_resolution_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double xy_resolution_;$/;"	m	class:base_local_planner::VoxelGridModel
xy_tolerance_latch_	base_local_planner/include/base_local_planner/latched_stop_rotate_controller.h	/^  bool latch_xy_goal_tolerance_, xy_tolerance_latch_;$/;"	m	class:base_local_planner::LatchedStopRotateController
xy_tolerance_latch_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      bool latch_xy_goal_tolerance_, xy_tolerance_latch_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
y	costmap_2d/include/costmap_2d/costmap_2d.h	/^  unsigned int y;$/;"	m	struct:costmap_2d::MapLocation
y	costmap_2d/src/costmap_2d_cloud.cpp	/^  double y;$/;"	m	struct:Cell	file:
y	costmap_2d/src/costmap_2d_markers.cpp	/^  double y;$/;"	m	struct:Cell	file:
y	navfn/include/navfn/potarr_point.h	/^        float y;$/;"	m	struct:navfn::PotarrPoint
y0_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int y0_; \/\/\/< Y coordinate of first end point.$/;"	m	class:base_local_planner::LineIterator
y0_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  unsigned int x0_, xn_, y0_, yn_;$/;"	m	class:costmap_2d::Costmap2DPublisher
y1_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int y1_; \/\/\/< Y coordinate of second end point.$/;"	m	class:base_local_planner::LineIterator
y_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int y_; \/\/\/< Y coordinate of current point.$/;"	m	class:base_local_planner::LineIterator
y_	costmap_2d/include/costmap_2d/inflation_layer.h	/^  unsigned int x_, y_;$/;"	m	class:costmap_2d::CellData
y_	costmap_2d/include/costmap_2d/static_layer.h	/^  unsigned int x_, y_, width_, height_;$/;"	m	class:costmap_2d::StaticLayer
y_pts_	base_local_planner/include/base_local_planner/trajectory.h	/^      std::vector<double> y_pts_; \/\/\/< @brief The y points in the trajectory$/;"	m	class:base_local_planner::Trajectory
y_vels_	base_local_planner/include/base_local_planner/trajectory_planner.h	/^      std::vector<double> y_vels_; \/\/\/< @brief Y velocities to explore$/;"	m	class:base_local_planner::TrajectoryPlanner
yaw_goal_tolerance	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  double yaw_goal_tolerance;$/;"	m	class:base_local_planner::LocalPlannerLimits
yaw_goal_tolerance_	base_local_planner/include/base_local_planner/trajectory_planner_ros.h	/^      double xy_goal_tolerance_, yaw_goal_tolerance_, min_in_place_vel_th_;$/;"	m	class:base_local_planner::TrajectoryPlannerROS
yinc1_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int xinc1_, xinc2_, yinc1_, yinc2_;$/;"	m	class:base_local_planner::LineIterator
yinc2_	base_local_planner/include/base_local_planner/line_iterator.h	/^  int xinc1_, xinc2_, yinc1_, yinc2_;$/;"	m	class:base_local_planner::LineIterator
yn_	costmap_2d/include/costmap_2d/costmap_2d_publisher.h	/^  unsigned int x0_, xn_, y0_, yn_;$/;"	m	class:costmap_2d::Costmap2DPublisher
ys_	global_planner/include/global_planner/traceback.h	/^        int xs_, ys_;$/;"	m	class:global_planner::Traceback
yshift_	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  double yshift_;$/;"	m	class:base_local_planner::MapGridCostFunction
yv_	base_local_planner/include/base_local_planner/trajectory.h	/^      double xv_, yv_, thetav_; \/\/\/< @brief The x, y, and theta velocities of the trajectory$/;"	m	class:base_local_planner::Trajectory
z	costmap_2d/src/costmap_2d_cloud.cpp	/^  double z;$/;"	m	struct:Cell	file:
z	costmap_2d/src/costmap_2d_markers.cpp	/^  double z;$/;"	m	struct:Cell	file:
z	navfn/include/navfn/potarr_point.h	/^        float z;$/;"	m	struct:navfn::PotarrPoint
z_hit	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double z_hit;$/;"	m	class:amcl::AMCLLaser
z_hit_	amcl/src/amcl_node.cpp	/^    double z_hit_, z_short_, z_max_, z_rand_, sigma_hit_, lambda_short_;$/;"	m	class:AmclNode	file:
z_mask_	voxel_grid/include/voxel_grid/voxel_grid.h	/^    unsigned int & z_mask_;$/;"	m	class:voxel_grid::VoxelGrid::ZOffset
z_max	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double z_max;$/;"	m	class:amcl::AMCLLaser
z_max_	amcl/src/amcl_node.cpp	/^    double z_hit_, z_short_, z_max_, z_rand_, sigma_hit_, lambda_short_;$/;"	m	class:AmclNode	file:
z_rand	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double z_rand;$/;"	m	class:amcl::AMCLLaser
z_rand_	amcl/src/amcl_node.cpp	/^    double z_hit_, z_short_, z_max_, z_rand_, sigma_hit_, lambda_short_;$/;"	m	class:AmclNode	file:
z_resolution_	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      double z_resolution_;$/;"	m	class:base_local_planner::VoxelGridModel
z_resolution_	costmap_2d/include/costmap_2d/voxel_layer.h	/^  double z_resolution_, origin_z_;$/;"	m	class:costmap_2d::VoxelLayer
z_short	amcl/include/amcl/sensors/amcl_laser.h	/^  private: double z_short;$/;"	m	class:amcl::AMCLLaser
z_short_	amcl/src/amcl_node.cpp	/^    double z_hit_, z_short_, z_max_, z_rand_, sigma_hit_, lambda_short_;$/;"	m	class:AmclNode	file:
~AMCLLaser	amcl/src/amcl/sensors/amcl_laser.cpp	/^AMCLLaser::~AMCLLaser()$/;"	f	class:AMCLLaser
~AMCLLaserData	amcl/include/amcl/sensors/amcl_laser.h	/^    virtual ~AMCLLaserData() {delete [] ranges;};$/;"	f	class:amcl::AMCLLaserData
~AMCLSensor	amcl/src/amcl/sensors/amcl_sensor.cpp	/^AMCLSensor::~AMCLSensor()$/;"	f	class:AMCLSensor
~AMCLSensorData	amcl/include/amcl/sensors/amcl_sensor.h	/^          virtual ~AMCLSensorData() {}$/;"	f	class:amcl::AMCLSensorData
~AmclNode	amcl/src/amcl_node.cpp	/^AmclNode::~AmclNode()$/;"	f	class:AmclNode
~BaseGlobalPlanner	nav_core/include/nav_core/base_global_planner.h	/^      virtual ~BaseGlobalPlanner(){}$/;"	f	class:nav_core::BaseGlobalPlanner
~BaseLocalPlanner	nav_core/include/nav_core/base_local_planner.h	/^      virtual ~BaseLocalPlanner(){}$/;"	f	class:nav_core::BaseLocalPlanner
~CachedDistanceMap	amcl/src/amcl/map/map_cspace.cpp	/^    ~CachedDistanceMap()$/;"	f	class:CachedDistanceMap
~Costmap2D	costmap_2d/src/costmap_2d.cpp	/^    Costmap2D::~Costmap2D()$/;"	f	class:costmap_2d::Costmap2D
~Costmap2DPublisher	costmap_2d/src/costmap_2d_publisher.cpp	/^    Costmap2DPublisher::~Costmap2DPublisher()$/;"	f	class:costmap_2d::Costmap2DPublisher
~Costmap2DROS	costmap_2d/src/costmap_2d_ros.cpp	/^    Costmap2DROS::~Costmap2DROS()$/;"	f	class:costmap_2d::Costmap2DROS
~CostmapModel	base_local_planner/include/base_local_planner/costmap_model.h	/^      virtual ~CostmapModel(){}$/;"	f	class:base_local_planner::CostmapModel
~DWAPlannerROS	dwa_local_planner/src/dwa_planner_ros.cpp	/^            DWAPlannerROS::~DWAPlannerROS(){$/;"	f	class:dwa_local_planner::DWAPlannerROS
~DijkstraExpansion	global_planner/src/dijkstra.cpp	/^DijkstraExpansion::~DijkstraExpansion() {$/;"	f	class:global_planner::DijkstraExpansion
~FakeOdomNode	fake_localization/fake_localization.cpp	/^    ~FakeOdomNode(void)$/;"	f	class:FakeOdomNode
~FootprintHelper	base_local_planner/src/footprint_helper.cpp	/^FootprintHelper::~FootprintHelper() {$/;"	f	class:base_local_planner::FootprintHelper
~GlobalPlanner	global_planner/src/planner_core.cpp	/^GlobalPlanner::~GlobalPlanner() {$/;"	f	class:global_planner::GlobalPlanner
~GradientPath	global_planner/src/gradient_path.cpp	/^GradientPath::~GradientPath() {$/;"	f	class:global_planner::GradientPath
~InflationLayer	costmap_2d/include/costmap_2d/inflation_layer.h	/^  virtual ~InflationLayer()$/;"	f	class:costmap_2d::InflationLayer
~LatchedStopRotateController	base_local_planner/src/latched_stop_rotate_controller.cpp	/^LatchedStopRotateController::~LatchedStopRotateController() {}$/;"	f	class:base_local_planner::LatchedStopRotateController
~Layer	costmap_2d/include/costmap_2d/layer.h	/^  virtual ~Layer() {}$/;"	f	class:costmap_2d::Layer
~LayeredCostmap	costmap_2d/src/layered_costmap.cpp	/^    LayeredCostmap::~LayeredCostmap()$/;"	f	class:costmap_2d::LayeredCostmap
~LocalPlannerLimits	base_local_planner/include/base_local_planner/local_planner_limits.h	/^  ~LocalPlannerLimits() {}$/;"	f	class:base_local_planner::LocalPlannerLimits
~LocalPlannerUtil	base_local_planner/include/base_local_planner/local_planner_util.h	/^  ~LocalPlannerUtil() {$/;"	f	class:base_local_planner::LocalPlannerUtil
~MapClientTest	map_server/test/rtest.cpp	/^    ~MapClientTest()$/;"	f	class:MapClientTest
~MapGrid	base_local_planner/include/base_local_planner/map_grid.h	/^      ~MapGrid(){}$/;"	f	class:base_local_planner::MapGrid
~MapGridCostFunction	base_local_planner/include/base_local_planner/map_grid_cost_function.h	/^  ~MapGridCostFunction() {}$/;"	f	class:base_local_planner::MapGridCostFunction
~MoveBase	move_base/src/move_base.cpp	/^    MoveBase::~MoveBase(){$/;"	f	class:move_base::MoveBase
~MoveSlowAndClear	move_slow_and_clear/src/move_slow_and_clear.cpp	/^    MoveSlowAndClear::~MoveSlowAndClear()$/;"	f	class:move_slow_and_clear::MoveSlowAndClear
~NavFn	navfn/src/navfn.cpp	/^  NavFn::~NavFn()$/;"	f	class:navfn::NavFn
~NavWin	navfn/src/navwin.cpp	/^NavWin::~NavWin()$/;"	f	class:navfn::NavWin
~NavfnROS	navfn/include/navfn/navfn_ros.h	/^      ~NavfnROS(){}$/;"	f	class:navfn::NavfnROS
~Observation	costmap_2d/include/costmap_2d/observation.h	/^  virtual ~Observation()$/;"	f	class:costmap_2d::Observation
~ObservationBuffer	costmap_2d/src/observation_buffer.cpp	/^ObservationBuffer::~ObservationBuffer()$/;"	f	class:costmap_2d::ObservationBuffer
~ObstacleCostFunction	base_local_planner/src/obstacle_cost_function.cpp	/^    ObstacleCostFunction::~ObstacleCostFunction() {$/;"	f	class:base_local_planner::ObstacleCostFunction
~ObstacleLayer	costmap_2d/plugins/obstacle_layer.cpp	/^    ObstacleLayer::~ObstacleLayer()$/;"	f	class:costmap_2d::ObstacleLayer
~OdometryHelperRos	base_local_planner/include/base_local_planner/odometry_helper_ros.h	/^  ~OdometryHelperRos() {}$/;"	f	class:base_local_planner::OdometryHelperRos
~OscillationCostFunction	base_local_planner/src/oscillation_cost_function.cpp	/^    OscillationCostFunction::~OscillationCostFunction() {$/;"	f	class:base_local_planner::OscillationCostFunction
~PointGrid	base_local_planner/include/base_local_planner/point_grid.h	/^      virtual ~PointGrid(){}$/;"	f	class:base_local_planner::PointGrid
~PreferForwardCostFunction	base_local_planner/include/base_local_planner/prefer_forward_cost_function.h	/^  ~PreferForwardCostFunction() {}$/;"	f	class:base_local_planner::PreferForwardCostFunction
~RecoveryBehavior	nav_core/include/nav_core/recovery_behavior.h	/^      virtual ~RecoveryBehavior(){}$/;"	f	class:nav_core::RecoveryBehavior
~RotateRecovery	rotate_recovery/src/rotate_recovery.cpp	/^    RotateRecovery::~RotateRecovery()$/;"	f	class:rotate_recovery::RotateRecovery
~SimpleScoredSamplingPlanner	base_local_planner/include/base_local_planner/simple_scored_sampling_planner.h	/^  ~SimpleScoredSamplingPlanner() {}$/;"	f	class:base_local_planner::SimpleScoredSamplingPlanner
~SimpleTrajectoryGenerator	base_local_planner/include/base_local_planner/simple_trajectory_generator.h	/^  ~SimpleTrajectoryGenerator() {}$/;"	f	class:base_local_planner::SimpleTrajectoryGenerator
~StaticLayer	costmap_2d/plugins/static_layer.cpp	/^    StaticLayer::~StaticLayer()$/;"	f	class:costmap_2d::StaticLayer
~TrajectoryCostFunction	base_local_planner/include/base_local_planner/trajectory_cost_function.h	/^  virtual ~TrajectoryCostFunction() {}$/;"	f	class:base_local_planner::TrajectoryCostFunction
~TrajectoryPlanner	base_local_planner/src/trajectory_planner.cpp	/^  TrajectoryPlanner::~TrajectoryPlanner(){}$/;"	f	class:base_local_planner::TrajectoryPlanner
~TrajectoryPlannerROS	base_local_planner/src/trajectory_planner_ros.cpp	/^  TrajectoryPlannerROS::~TrajectoryPlannerROS() {$/;"	f	class:base_local_planner::TrajectoryPlannerROS
~TrajectorySampleGenerator	base_local_planner/include/base_local_planner/trajectory_sample_generator.h	/^  virtual ~TrajectorySampleGenerator() {}$/;"	f	class:base_local_planner::TrajectorySampleGenerator
~TrajectorySearch	base_local_planner/include/base_local_planner/trajectory_search.h	/^  virtual ~TrajectorySearch() {}$/;"	f	class:base_local_planner::TrajectorySearch
~TwirlingCostFunction	base_local_planner/include/base_local_planner/twirling_cost_function.h	/^  ~TwirlingCostFunction() {}$/;"	f	class:base_local_planner::TwirlingCostFunction
~VoxelGrid	voxel_grid/src/voxel_grid.cpp	/^  VoxelGrid::~VoxelGrid()$/;"	f	class:voxel_grid::VoxelGrid
~VoxelGridModel	base_local_planner/include/base_local_planner/voxel_grid_model.h	/^      virtual ~VoxelGridModel(){}$/;"	f	class:base_local_planner::VoxelGridModel
~VoxelLayer	costmap_2d/plugins/voxel_layer.cpp	/^VoxelLayer::~VoxelLayer()$/;"	f	class:costmap_2d::VoxelLayer
~WavefrontMapAccessor	base_local_planner/test/wavefront_map_accessor.h	/^    virtual ~WavefrontMapAccessor(){};$/;"	f	class:base_local_planner::WavefrontMapAccessor
~WorldModel	base_local_planner/include/base_local_planner/world_model.h	/^            virtual ~WorldModel(){}$/;"	f	class:base_local_planner::WorldModel
